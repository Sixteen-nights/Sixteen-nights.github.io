<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Big Ben的个人博客</title>
  
  <subtitle>做一件事在成功之前，要保持不动声色却满心澎湃。</subtitle>
  <link href="https://sixteen-nights.github.io/atom.xml" rel="self"/>
  
  <link href="https://sixteen-nights.github.io/"/>
  <updated>2023-05-06T06:00:55.907Z</updated>
  <id>https://sixteen-nights.github.io/</id>
  
  <author>
    <name>Big Ben</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法课题目与代码</title>
    <link href="https://sixteen-nights.github.io/2023/04/03/%E7%AE%97%E6%B3%95%E8%AF%BE%E9%A2%98%E7%9B%AE%E4%B8%8E%E4%BB%A3%E7%A0%81/"/>
    <id>https://sixteen-nights.github.io/2023/04/03/%E7%AE%97%E6%B3%95%E8%AF%BE%E9%A2%98%E7%9B%AE%E4%B8%8E%E4%BB%A3%E7%A0%81/</id>
    <published>2023-04-03T13:00:00.000Z</published>
    <updated>2023-05-06T06:00:55.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法课题目与代码"><a href="#算法课题目与代码" class="headerlink" title="算法课题目与代码"></a>算法课题目与代码</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里用来记录算法课所有涉及到的题目的题面以及代码，供大家参考学习。</p><p>所有讲解视频已经上传B站，B站名称：小猪佩奇_教学</p><p>有任何问题请加QQ联系我</p><span id="more"></span><h2 id="作业1-排序及排序分析"><a href="#作业1-排序及排序分析" class="headerlink" title="作业1 排序及排序分析"></a>作业1 排序及排序分析</h2><p>分析排序算法，给出时间复杂度分析（这里选择基数排序）</p><p><code>CMakeLists.txt</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">0</span>)</span><br><span class="line"><span class="keyword">project</span>(task VERSION <span class="number">0.1</span>.<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(CTest)</span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(task main.cpp main.h auxiliary.cpp Radix_sort.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CPACK_PROJECT_NAME <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(CPACK_PROJECT_VERSION <span class="variable">$&#123;PROJECT_VERSION&#125;</span>)</span><br><span class="line"><span class="keyword">include</span>(CPack)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>main.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *elem;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125; Arr, *ArrPtr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RightMethod</span><span class="params">(ArrPtr pArr1)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *_a, <span class="type">const</span> <span class="type">void</span> *_b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> i, <span class="type">int</span> j)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(ArrPtr pArr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Generate_Random_Array</span><span class="params">(ArrPtr pArr1, <span class="type">int</span> maxSize, <span class="type">int</span> maxVal)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Copy_Array</span><span class="params">(ArrPtr pArr1, ArrPtr pArr2)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Compare</span><span class="params">(ArrPtr pArr1, ArrPtr pArr2)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Radix_sort</span><span class="params">(ArrPtr pArr2)</span></span>;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">clock_t</span> start1, stop1, start2, stop2;</span><br><span class="line"></span><br><span class="line">    Arr Arr1, Arr2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> time1, time2;</span><br><span class="line">        time1 = time2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> maxSize = i * <span class="number">100000</span>;</span><br><span class="line">        <span class="type">int</span> maxVal = i * <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> succeed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">Generate_Random_Array</span>(&amp;Arr1, maxSize, maxVal);</span><br><span class="line">            <span class="built_in">Copy_Array</span>(&amp;Arr1, &amp;Arr2);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printf(&quot;已产生随机数组:\n&quot;);</span></span><br><span class="line">            <span class="comment">// traverse(&amp;Arr1);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// start1 = clock();</span></span><br><span class="line">            <span class="built_in">RightMethod</span>(&amp;Arr1);</span><br><span class="line">            <span class="comment">// stop1 = clock();</span></span><br><span class="line">            <span class="comment">// time1 += (double(stop1 - start1) / CLK_TCK);</span></span><br><span class="line"></span><br><span class="line">            start2 = <span class="built_in">clock</span>();</span><br><span class="line">            <span class="built_in">Radix_sort</span>(&amp;Arr2);</span><br><span class="line">            stop2 = <span class="built_in">clock</span>();</span><br><span class="line">            time2 += (<span class="built_in">double</span>(stop2 - start2) / CLK_TCK);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printf(&quot;排序结果为:\n&quot;);</span></span><br><span class="line">            <span class="comment">// traverse(&amp;Arr2);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">Compare</span>(&amp;Arr1, &amp;Arr2))</span><br><span class="line">                succeed = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(succeed ? <span class="string">&quot;排序成功!\n&quot;</span> : <span class="string">&quot;排序失败!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// printf(&quot;针对数组长度为: %d万的随机数组,系统快排算法排序%d次的平均运行时间为: %lf ms\n&quot;, maxSize / 10000, 10, time1 / 10);</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;针对数组长度为: %d万的随机数组,基数排序算法排序%d次的平均运行时间为: %lf ms\n&quot;</span>, maxSize / <span class="number">10000</span>, <span class="number">10</span>, time2 / <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(Arr1.elem);</span><br><span class="line">        <span class="built_in">free</span>(Arr2.elem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>auxiliary.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RightMethod</span><span class="params">(ArrPtr pArr1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qsort</span>(pArr1-&gt;elem, pArr1-&gt;length, <span class="built_in">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *_a, <span class="type">const</span> <span class="type">void</span> *_b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span> *)_a - *(<span class="type">int</span> *)_b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    arr[j] = arr[i] ^ arr[j];</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(ArrPtr pArr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pArr-&gt;elem == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, pArr-&gt;elem[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Generate_Random_Array</span><span class="params">(ArrPtr pArr1, <span class="type">int</span> maxSize, <span class="type">int</span> maxVal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    pArr1-&gt;length = maxSize;</span><br><span class="line">    pArr1-&gt;elem = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * pArr1-&gt;length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr1-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pArr1-&gt;elem[i] = <span class="built_in">rand</span>() % (maxVal + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Copy_Array</span><span class="params">(ArrPtr pArr1, ArrPtr pArr2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pArr2-&gt;length = pArr1-&gt;length;</span><br><span class="line">    pArr2-&gt;elem = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * pArr2-&gt;length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr2-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pArr2-&gt;elem[i] = pArr1-&gt;elem[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Compare</span><span class="params">(ArrPtr pArr1, ArrPtr pArr2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr1-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pArr1-&gt;elem[i] != pArr2-&gt;elem[i])</span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Radix_sort.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Radix_sort</span><span class="params">(ArrPtr pArr2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *temp = (<span class="type">int</span> *)<span class="built_in">calloc</span>(pArr2-&gt;length, <span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配临时数组用于存储每一趟的排序结果</span></span><br><span class="line">    <span class="type">int</span> exp = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> maxval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历找到随机数组中的最大值，根据其位数确定需要几趟排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr2-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pArr2-&gt;elem[i] &gt; maxval)</span><br><span class="line">        &#123;</span><br><span class="line">            maxval = pArr2-&gt;elem[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环开始从低数位到高数位排序，该过程不可逆，因为高数位的权值更大</span></span><br><span class="line">    <span class="keyword">while</span> (maxval &gt;= exp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *cnt = (<span class="type">int</span> *)<span class="built_in">calloc</span>(<span class="number">10</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 创建分配数组，即 0-9</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按当前排序数位分配的过程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr2-&gt;length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> digit = (pArr2-&gt;elem[i] / exp) % <span class="number">10</span>;</span><br><span class="line">            cnt[digit]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新分配数组，建立一种映射关系让收集时temp里面的元素是按当前数位有序排列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 收集过程，必须逆序针对原数组进行遍历收集，因为分配时是顺序进行分配的，如果一个桶里不止一个成员，那么先进去的成员应该先出来，即顺序遍历时先遍历到并分配入桶中的成员先出来，但因数组不好实现这一过程，故选择逆序收集，从数组尾开始收集后进去的成员</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = pArr2-&gt;length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> digit = (pArr2-&gt;elem[i] / exp) % <span class="number">10</span>;</span><br><span class="line">            temp[--cnt[digit]] = pArr2-&gt;elem[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将按当前数位排序好的数组复制到原数组当中，并更新数位</span></span><br><span class="line">        <span class="built_in">memcpy</span>(pArr2-&gt;elem, temp, <span class="built_in">sizeof</span>(<span class="type">int</span>) * pArr2-&gt;length);</span><br><span class="line">        exp *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作业2-归并排序"><a href="#作业2-归并排序" class="headerlink" title="作业2 归并排序"></a>作业2 归并排序</h2><p>给定你一个长度为 n 的整数数列。</p><p>请你使用归并排序对这个数列按照从小到大进行排序。</p><p>并将排好序的数列按顺序输出。</p><p>输入格式<br>输入共两行，第一行包含整数 n。</p><p>第二行包含 n 个整数（所有整数均在 1∼100 范围内），表示整个数列。</p><p>输出格式<br>输出共一行，包含 n 个整数，表示排好序的数列。</p><p>数据范围<br>1≤n≤100000</p><p>输入样例：<br>5<br>3 1 2 4 5<br>输出样例：<br>1 2 3 4 5</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + (r - l &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid), <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j])</span><br><span class="line">            tmp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmp[k++] = q[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">        tmp[k++] = q[i++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">        tmp[k++] = q[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++)</span><br><span class="line">        q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">merge_sort</span>(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作业3-最大连续和"><a href="#作业3-最大连续和" class="headerlink" title="作业3 最大连续和"></a>作业3 最大连续和</h2><p>给你一个长度为n的整数序列{A1, A2,… ,An},求最大连续和。</p><p>输入格式<br>第一行整数n；</p><p>第二行为n个用空格分开的整数序列，每个数的绝对值都小于100。</p><p>输出格式<br>仅一个整数，表示该整数序列的最大连续和。</p><p>数据范围<br>1≤n≤100000</p><p>输入样例：<br>4<br>1 -2 3 2<br>输出样例：<br>7</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define max(a, b) (((a) &gt; (b)) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxsum</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (R - L == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> q[L];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = L + (R - L &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxs = <span class="built_in">max</span>(<span class="built_in">maxsum</span>(q, L, mid), <span class="built_in">maxsum</span>(q, mid, R));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left_value = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left_sum = q[mid - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = mid - <span class="number">1</span>; i &gt;= L; i--)</span><br><span class="line">        left_sum = <span class="built_in">max</span>(left_sum, left_value += q[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> right_value = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right_sum = q[mid];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = mid; i &lt; R; i++)</span><br><span class="line">        right_sum = <span class="built_in">max</span>(right_sum, right_value += q[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\t&quot;</span>, maxs, left_sum + right_sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(maxs, left_sum + right_sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">maxsum</span>(a, <span class="number">0</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作业4-螺旋矩阵"><a href="#作业4-螺旋矩阵" class="headerlink" title="作业4 螺旋矩阵"></a>作业4 螺旋矩阵</h2><p>给你一个正整数 n ，生成一个包含 1 到 n*n 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</p><p>输入格式<br>正整数n。</p><p>输出格式<br>所生成的矩阵。</p><p>数据范围<br>1≤n≤20</p><p>输入样例：<br>3</p><p>输出样例：<br>1   2   3<br>8   9   4<br>7   6   5</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generateMatrix</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> **q, <span class="type">int</span> begin, <span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q[begin][begin] = number;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = begin, j = begin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; length - <span class="number">1</span>; k++)</span><br><span class="line">        q[i][j++] = number++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; length - <span class="number">1</span>; k++)</span><br><span class="line">        q[i++][j] = number++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; length - <span class="number">1</span>; k++)</span><br><span class="line">        q[i][j--] = number++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; length - <span class="number">1</span>; k++)</span><br><span class="line">        q[i--][j] = number++;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">generateMatrix</span>(n, q, begin + <span class="number">1</span>, length - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int a[n][n];</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> **a = (<span class="type">int</span> **)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span> *) * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        a[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">generateMatrix</span>(n, a, <span class="number">0</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, a[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作业5-百钱百鸡"><a href="#作业5-百钱百鸡" class="headerlink" title="作业5 百钱百鸡"></a>作业5 百钱百鸡</h2><p>我国古代数学家张丘建在《算经》一书中曾提出过著名的“百钱买百鸡”问题，该问题叙述如下：<br>鸡翁一，值钱五；鸡母一，值钱三；鸡雏三，值钱一；百钱买百鸡，则翁、母、雏各几何？<br>翻译过来，意思是公鸡一个五块钱，母鸡一个三块钱，小鸡三个一块钱，<br>现在要用一百块钱买一百只鸡，问公鸡、母鸡、小鸡各多少只？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt;= <span class="number">12</span>; x += <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = (<span class="number">100</span> - <span class="number">7</span> * x) / <span class="number">4</span>;</span><br><span class="line">        <span class="type">int</span> z = <span class="number">6</span> * x + <span class="number">3</span> * y;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作业6-超大数四则运算"><a href="#作业6-超大数四则运算" class="headerlink" title="作业6 超大数四则运算"></a>作业6 超大数四则运算</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><p>给定两个正整数（不含前导 0），计算它们的和。</p><p>输入格式<br>共两行，每行包含一个整数。</p><p>输出格式<br>共一行，包含所求的和。</p><p>数据范围<br>1≤整数长度≤100000</p><p>输入样例：<br>12<br>23<br>输出样例：<br>35</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>())</span><br><span class="line">            t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t)</span><br><span class="line">        C.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">add</span>(A, B);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        cout &lt;&lt; C[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><p>给定两个正整数（不含前导 0），计算它们的差，计算结果可能为负数。</p><p>输入格式<br>共两行，每行包含一个整数。</p><p>输出格式<br>共一行，包含所求的差。</p><p>数据范围<br>1≤整数长度≤105</p><p>输入样例：<br>32<br>11<br>输出样例：<br>21</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>())</span><br><span class="line">            t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>)</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp</span>(A, B))</span><br><span class="line">        C = <span class="built_in">sub</span>(A, B);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        C = <span class="built_in">sub</span>(B, A), cout &lt;&lt; <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        cout &lt;&lt; C[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><p>给定两个非负整数（不含前导 0） A 和 B，请你计算 A×B的值。</p><p>输入格式<br>共两行，第一行包含整数 A，第二行包含整数 B。</p><p>输出格式<br>共一行，包含 A×B的值。</p><p>数据范围<br>1≤A的长度≤100000,<br>0≤B≤10000</p><p>输入样例：<br>2<br>3<br>输出样例：<br>6</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">            t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">mul</span>(A, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><p>给定两个非负整数（不含前导 0） A，B，请你计算 A&#x2F;B 的商和余数。</p><p>输入格式<br>共两行，第一行包含整数 A，第二行包含整数 B。</p><p>输出格式<br>共两行，第一行输出所求的商，第二行输出所求余数。</p><p>数据范围<br>1≤A的长度≤100000,<br>1≤B≤10000,<br>B 一定不为 0</p><p>输入样例：<br>7<br>2<br>输出样例：<br>3<br>1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> B;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">div</span>(A, B, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        cout &lt;&lt; C[i];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl</span><br><span class="line">         &lt;&lt; r &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h3><p>求1000！的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">            t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    A.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">1000</span>; i++)</span><br><span class="line">        A = <span class="built_in">mul</span>(A, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, A[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作业7-姓名密码"><a href="#作业7-姓名密码" class="headerlink" title="作业7 姓名密码"></a>作业7 姓名密码</h2><p>没找到合适的题目，忽略该题</p><h2 id="作业8-最大公约数和最小公倍数"><a href="#作业8-最大公约数和最小公倍数" class="headerlink" title="作业8 最大公约数和最小公倍数"></a>作业8 最大公约数和最小公倍数</h2><p>输入两个正整数 m 和 n，求其最大公约数和最小公倍数。</p><p>输入格式<br>一行，两个整数 m 和 n。</p><p>输出格式<br>一行，输出两个数的最大公约数和最小公倍数。</p><p>数据范围<br>1≤n,m≤10000<br>输入样例：<br>5 7<br>输出样例：<br>1 35</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">    <span class="comment">// while (b)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     int temp = b;</span></span><br><span class="line">    <span class="comment">//     b = a % b;</span></span><br><span class="line">    <span class="comment">//     a = temp;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// return a;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="comment">// printf(&quot;%d\n%d\n&quot;, gcd(a, b), a * b / gcd(a, b));</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d\n&quot;</span>, __gcd(a, b), a * b / __gcd(a, b));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作业9-二叉树的前中后序遍历"><a href="#作业9-二叉树的前中后序遍历" class="headerlink" title="作业9 二叉树的前中后序遍历"></a>作业9 二叉树的前中后序遍历</h2><p>二叉树的前序遍历：<a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">https://leetcode.cn/problems/binary-tree-preorder-traversal/</a><br>二叉树的中序遍历：<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">https://leetcode.cn/problems/binary-tree-inorder-traversal/</a><br>二叉树的后序遍历：<a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">https://leetcode.cn/problems/binary-tree-postorder-traversal/</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">preorderTraversal</span><span class="params">(<span class="keyword">struct</span> TreeNode *root, <span class="type">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *res = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">100</span>);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span> *stk[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span> *node = root;</span><br><span class="line">    <span class="type">int</span> stk_top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (stk_top &gt; <span class="number">0</span> || node != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res[(*returnSize)++] = node-&gt;val;</span><br><span class="line">            stk[stk_top++] = node;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        node = stk[--stk_top];</span><br><span class="line">        node = node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">inorderTraversal</span><span class="params">(<span class="keyword">struct</span> TreeNode *root, <span class="type">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *res = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">100</span>);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span> *stk[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span> *node = root;</span><br><span class="line">    <span class="type">int</span> stk_top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (stk_top &gt; <span class="number">0</span> || node != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stk[stk_top++] = node;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        node = stk[--stk_top];</span><br><span class="line">        res[(*returnSize)++] = node-&gt;val;</span><br><span class="line">        node = node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">postorderTraversal</span><span class="params">(<span class="keyword">struct</span> TreeNode *root, <span class="type">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *res = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">100</span>);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span> *stk[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span> *node = root;</span><br><span class="line">    <span class="type">int</span> stk_top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (stk_top &gt; <span class="number">0</span> || node != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res[(*returnSize)++] = node-&gt;val;</span><br><span class="line">            stk[stk_top++] = node;</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        node = stk[--stk_top];</span><br><span class="line">        node = node-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; *returnSize / <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = res[i];</span><br><span class="line">        res[i] = res[*returnSize - <span class="number">1</span> - i];</span><br><span class="line">        res[*returnSize - <span class="number">1</span> - i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作业10-母牛的故事"><a href="#作业10-母牛的故事" class="headerlink" title="作业10 母牛的故事"></a>作业10 母牛的故事</h2><p>有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。<br>请编程实现在第n年的时候，共有多少头母牛？</p><p>输入格式<br>输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n，n的含义如题目中描述。<br>n&#x3D;0表示输入数据的结束，不做处理。</p><p>输出格式<br>对于每个测试实例，输出在第n年的时候母牛的数量。<br>每个输出占一行。</p><p>数据范围<br>0≤n&lt;55<br>输入样例：<br>2<br>4<br>5<br>0<br>输出样例：<br>2<br>4<br>6</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> res[N], pi;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">55</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">5</span>)</span><br><span class="line">            a[i] = i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a[i] = a[i - <span class="number">1</span>] + a[i - <span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cow</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF &amp;&amp; n)</span><br><span class="line">        res[pi++] = a[n];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pi; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    LL total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : a)</span><br><span class="line">        total += i;</span><br><span class="line">    cout &lt;&lt; total;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="作业11-打印图形"><a href="#作业11-打印图形" class="headerlink" title="作业11 打印图形"></a>作业11 打印图形</h2><p>本题题面不好描述，请自己查找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; w; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; w; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, buf[i * w + j] == <span class="number">0</span> ? <span class="string">&#x27; &#x27;</span> : <span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> w, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buf[y * w + x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = size / <span class="number">3</span>; <span class="comment">// 填空</span></span><br><span class="line">    <span class="built_in">draw</span>(buf, w, x, y, n);</span><br><span class="line">    <span class="built_in">draw</span>(buf, w, x - n, y, n);</span><br><span class="line">    <span class="built_in">draw</span>(buf, w, x + n, y, n);</span><br><span class="line">    <span class="built_in">draw</span>(buf, w, x, y - n, n);</span><br><span class="line">    <span class="built_in">draw</span>(buf, w, x, y + n, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        t *= <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(t * t);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; t * t; i++)</span><br><span class="line">        buf[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">draw</span>(buf, t, t / <span class="number">2</span>, t / <span class="number">2</span>, t);</span><br><span class="line">    <span class="built_in">show</span>(buf, t);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="作业12-埃及分数"><a href="#作业12-埃及分数" class="headerlink" title="作业12 埃及分数"></a>作业12 埃及分数</h2><p>在古埃及，人们使用单位分数的和（形如 1&#x2F;a 的，a是自然数）表示一切有理数。<br>如：2&#x2F;3 &#x3D; 1&#x2F;2 + 1&#x2F;6，但不允许 2&#x2F;3 &#x3D; 1&#x2F;3 + 1&#x2F;3，因为加数中有相同的。<br>给出 a,b，编程计算一种可行解的表达方式。</p><p>输入格式<br>一行两个整数，分别为 a 和 b 的值。</p><p>输出格式<br>输出若干个数，自小到大排列，依次是单位分数的分母。</p><p>数据范围<br>0&lt;a&lt;b&lt;1000<br>输入样例：<br>19 45<br>输出样例：<br>3 12 180</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y == <span class="number">0</span> ? x : <span class="built_in">gcd</span>(y, x % y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(b);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c = b / a + <span class="number">1</span>;</span><br><span class="line">    ans.<span class="built_in">push_back</span>(c);</span><br><span class="line"></span><br><span class="line">    a -= b % a;</span><br><span class="line">    b *= c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">find</span>(a / <span class="built_in">gcd</span>(a, b), b / <span class="built_in">gcd</span>(a, b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">find</span>(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : ans)</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作业13-Kruskal算法求最小生成树"><a href="#作业13-Kruskal算法求最小生成树" class="headerlink" title="作业13 Kruskal算法求最小生成树"></a>作业13 Kruskal算法求最小生成树</h2><p>给定一个 n 个点 m 条边的无向图，图中可能存在重边和自环，边权可能为负数。</p><p>求最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。</p><p>给定一张边带权的无向图 G&#x3D;(V,E)，其中 V 表示图中点的集合，E 表示图中边的集合，n&#x3D;|V|，m&#x3D;|E|。</p><p>由 V 中的全部 n 个顶点和 E 中 n−1 条边构成的无向连通子图被称为 G 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 G 的最小生成树。</p><p>输入格式<br>第一行包含两个整数 n 和 m。</p><p>接下来 m 行，每行包含三个整数 u,v,w，表示点 u 和点 v 之间存在一条权值为 w 的边。</p><p>输出格式<br>共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。</p><p>数据范围<br>1≤n≤10^5,<br>1≤m≤2∗10^5,<br>图中涉及边的边权的绝对值均不超过 1000。</p><p>输入样例：<br>4 5<br>1 2 1<br>1 3 2<br>1 4 3<br>2 3 2<br>3 4 4<br>输出样例：<br>6</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge &amp;W) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edges[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">kruskal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t == INF)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作业14-贪心法找零钱"><a href="#作业14-贪心法找零钱" class="headerlink" title="作业14 贪心法找零钱"></a>作业14 贪心法找零钱</h2><p>人民币的面额有100元、50元、20元、10元、5元、1元等。现在要求使用贪心的方法来针对某一目标钱数 n 进行找零</p><p>输入格式<br>一行一个整数，n 的值</p><p>输出格式<br>输出若干个数，自大到小排列，每个数为一种人民币面额</p><p>数据范围<br>0&lt;n&lt;1000<br>输入样例：<br>514<br>输出样例：<br>100 100 100 100 100 10 1 1 1 1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> currency[<span class="number">6</span>] = &#123;<span class="number">100</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!n)</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> q = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &gt;= currency[i])</span><br><span class="line">            &#123;</span><br><span class="line">                q = n / currency[i];</span><br><span class="line">                n %= currency[i];</span><br><span class="line">                <span class="keyword">while</span> (q--)</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(currency[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : ans)</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作业15-贪心的自助餐"><a href="#作业15-贪心的自助餐" class="headerlink" title="作业15 贪心的自助餐"></a>作业15 贪心的自助餐</h2><p>小B同学想去吃自助餐，但是他是那种比较节俭的的人，既不想浪费食物，又想尽可能吃的贵一点，他于是私下里做了调查。</p><p>小蓝餐厅的自助餐有n种食材，每种食材都有它的价格。</p><p>而且也能估计出每一份的重量，所以他列了一个表格：<br>菜品价格（元）重量（g）<br>红烧牛肉    30    300<br>油闷大虾8    5<br>四喜丸子4    8<br>三文鱼5   3<br>排骨        18    200<br>麻辣兔头20    120<br>高汤海参40  70<br>扇贝粉丝8    32<br>牛排        79    240</p><p>小B的饭量C(g)，他想知道在不超过饭量的情况下他最多能吃多少钱的菜品。</p><p>请你设计一个程序帮助小B计算他的最多吃了多少钱。（假设自助餐厅的菜品供应同样的菜品每个人只能取一份。）</p><p>输入格式<br>第一行输入两个整数 n,C ，其中n为菜品数量，C 为小B的肚子容量。<br>接下来n行每行输入两个数 v[i],w[i]<br>v[i] 是第i个菜品的价值，w[i]表示第i个菜品的重量。</p><p>输出格式<br>输出一行数据，表示最大的价值，保留小数点后三位数。</p><p>数据范围<br>0≤n≤10^3,0≤C≤10^4<br>0≤v[i],w[i]≤10^4<br>输入样例：<br>20 1000<br>1 22<br>2 43<br>123 214<br>12 2<br>123 432<br>21 223<br>22 16<br>77 49<br>34 78<br>34 9<br>43 677<br>21 34<br>23 23<br>12 56<br>332 56<br>21 99<br>123 545<br>389 33<br>12 999<br>23 88<br>输出样例：<br>1204.114</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> C;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Food</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> v, w, p;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Food &amp;F) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> p &gt; F.p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Food[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(Food, Food + n);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Food[i].w &lt;= C)</span><br><span class="line">        &#123;</span><br><span class="line">            C -= Food[i].w;</span><br><span class="line">            value += Food[i].v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            value += Food[i].p * C;</span><br><span class="line">            C = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (C == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> total_v = <span class="number">0</span>, total_w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; Food[i].v &gt;&gt; Food[i].w;</span><br><span class="line">        total_v += Food[i].v;</span><br><span class="line">        total_w += Food[i].w;</span><br><span class="line">        Food[i].p = Food[i].v / Food[i].w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (total_w &lt;= C)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.3f&quot;</span>, total_v);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.3f&quot;</span>, <span class="built_in">Eat</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作业16-差值与斐波那契查找"><a href="#作业16-差值与斐波那契查找" class="headerlink" title="作业16 差值与斐波那契查找"></a>作业16 差值与斐波那契查找</h2><p>针对给定的数组a,设计插值查找函数与斐波那契查找函数来针对给定元素n,查找它在数组在的下标，如果不存在则返回-1</p><p>输入格式<br>一行一个整数，n 的值</p><p>输出格式<br>一行为一种查找所找出的结果，总共两行</p><p>数据范围<br>0&lt;n&lt;20<br>输入样例：<br>5<br>输出样例：<br>4<br>4</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> max_size = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinarySearch2</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> value, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = low + (value - a[low]) / (a[high] - a[low]) * (high - low);</span><br><span class="line">        <span class="keyword">if</span> (a[mid] == value)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt; value)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BinarySearch2</span>(a, value, low, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt; value)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BinarySearch2</span>(a, value, mid + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> *F)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    F[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    F[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; max_size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        F[i] = F[i - <span class="number">1</span>] + F[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Fibonacci_Search</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> Key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> high = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> F[max_size];</span><br><span class="line">    <span class="built_in">Fibonacci</span>(F);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; F[k] - <span class="number">1</span>)</span><br><span class="line">        ++k;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *temp;</span><br><span class="line">    temp = <span class="keyword">new</span> <span class="type">int</span>[F[k] - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(temp, a, n * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt; F[k] - <span class="number">1</span>; ++i)</span><br><span class="line">        temp[i] = a[n - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = low + F[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (Key &lt; temp[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">            k -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Key &gt; temp[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">            k -= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid &lt; n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] temp;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">BinarySearch2</span>(a, n, <span class="number">0</span>, <span class="number">8</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Fibonacci_Search</span>(a, <span class="number">9</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验四-动态规划-数塔问题"><a href="#实验四-动态规划-数塔问题" class="headerlink" title="实验四 动态规划-数塔问题"></a>实验四 动态规划-数塔问题</h2><p>给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。</p><pre><code>        7      3   8    8   1   0  2   7   4   44   5   2   6   5</code></pre><p>输入格式<br>第一行包含整数 n，表示数字三角形的层数。<br>接下来 n 行，每行包含若干整数，其中第 i 行表示数字三角形第 i 层包含的整数。</p><p>输出格式<br>输出一个整数，表示最大的路径数字和。</p><p>数据范围<br>1≤n≤500,−10000≤三角形中的整数≤10000</p><p>输入样例：<br>5<br>7<br>3 8<br>8 1 0<br>2 7 4 4<br>4 5 2 6 5<br>输出样例：<br>30</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j ++ )</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i + <span class="number">1</span>; j ++ )</span><br><span class="line">            f[i][j] = -INF;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j ++ )</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j], f[i - <span class="number">1</span>][j] + a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res = <span class="built_in">max</span>(res, f[n][i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验一-快速排序递归和非递归算法实现"><a href="#实验一-快速排序递归和非递归算法实现" class="headerlink" title="实验一 快速排序递归和非递归算法实现"></a>实验一 快速排序递归和非递归算法实现</h2><p>给定你一个长度为 n 的整数数列。</p><p>请你使用快速排序对这个数列按照从小到大进行排序。</p><p>并将排好序的数列按顺序输出。</p><p>输入格式</p><p>输入共两行，第一行包含整数 n。</p><p>第二行包含 n 个整数（所有整数均在 1∼1e9 范围内），表示整个数列。</p><p>输出格式</p><p>输出共一行，包含 n 个整数，表示排好序的数列。</p><p>数据范围</p><p>1≤n≤100000</p><p>输入样例：</p><p>5<br>3 1 2 4 5</p><p>输出样例：</p><p>1 2 3 4 5</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">stack&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; stc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> x = a[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">while</span> (a[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">while</span> (a[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">            <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(l, j), <span class="built_in">quick_sort</span>(j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">non_recursive_quick_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stc.<span class="built_in">push</span>(&#123;l, r&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!stc.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [l, r] = stc.<span class="built_in">top</span>();</span><br><span class="line">        stc.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> base = a[mid];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">while</span> (a[i] &lt; base);</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">while</span> (a[j] &gt; base);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">                <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        stc.<span class="built_in">push</span>(&#123;l, j&#125;);</span><br><span class="line">        stc.<span class="built_in">push</span>(&#123;j + <span class="number">1</span>, r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// quick_sort(0, n - 1);</span></span><br><span class="line">    <span class="built_in">non_recursive_quick_sort</span>(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作业17-冒泡排序的优化"><a href="#作业17-冒泡排序的优化" class="headerlink" title="作业17 冒泡排序的优化"></a>作业17 冒泡排序的优化</h2><p><code>CMakeLists.txt</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">0</span>)</span><br><span class="line"><span class="keyword">project</span>(task VERSION <span class="number">0.1</span>.<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(CTest)</span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(task main.cpp main.h auxiliary.cpp Bubble_sort.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CPACK_PROJECT_NAME <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(CPACK_PROJECT_VERSION <span class="variable">$&#123;PROJECT_VERSION&#125;</span>)</span><br><span class="line"><span class="keyword">include</span>(CPack)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>main.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *elem;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125; Arr, *ArrPtr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RightMethod</span><span class="params">(ArrPtr pArr1)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *_a, <span class="type">const</span> <span class="type">void</span> *_b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(ArrPtr pArr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Generate_Random_Array</span><span class="params">(ArrPtr pArr1, <span class="type">int</span> maxSize, <span class="type">int</span> maxVal)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Copy_Array</span><span class="params">(ArrPtr pArr1, ArrPtr pArr2)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Compare</span><span class="params">(ArrPtr pArr1, ArrPtr pArr2)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bubble_sort</span><span class="params">(ArrPtr pArr2)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bubble_sort1</span><span class="params">(ArrPtr pArr2)</span></span>;</span><br></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">clock_t</span> start1, stop1, start2, stop2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> time1, time2;</span><br><span class="line">        time1 = time2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> maxSize = i * <span class="number">10000</span>;</span><br><span class="line">        <span class="type">int</span> maxVal = i * <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> succeed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            Arr Arr1, Arr2;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">Generate_Random_Array</span>(&amp;Arr1, maxSize, maxVal);</span><br><span class="line">            <span class="built_in">Copy_Array</span>(&amp;Arr1, &amp;Arr2);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printf(&quot;已产生随机数组:\n&quot;);</span></span><br><span class="line">            <span class="comment">// traverse(&amp;Arr1);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// start1 = clock();</span></span><br><span class="line">            <span class="built_in">RightMethod</span>(&amp;Arr1);</span><br><span class="line">            <span class="comment">// stop1 = clock();</span></span><br><span class="line">            <span class="comment">// time1 += (double(stop1 - start1) / CLK_TCK);</span></span><br><span class="line"></span><br><span class="line">            start2 = <span class="built_in">clock</span>();</span><br><span class="line">            <span class="built_in">Bubble_sort</span>(&amp;Arr2);</span><br><span class="line">            <span class="comment">// Bubble_sort1(&amp;Arr2);</span></span><br><span class="line">            stop2 = <span class="built_in">clock</span>();</span><br><span class="line">            time2 += (<span class="built_in">double</span>(stop2 - start2) / CLK_TCK);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printf(&quot;排序结果为:\n&quot;);</span></span><br><span class="line">            <span class="comment">// traverse(&amp;Arr2);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">Compare</span>(&amp;Arr1, &amp;Arr2))</span><br><span class="line">                succeed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">free</span>(Arr1.elem);</span><br><span class="line">            <span class="built_in">free</span>(Arr2.elem);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(succeed ? <span class="string">&quot;排序成功!\n&quot;</span> : <span class="string">&quot;排序失败!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// printf(&quot;针对数组长度为: %.1f万的随机数组,系统快排算法排序%d次的平均运行时间为: %lf s\n&quot;, maxSize / 10000.0, 10, time1 / 10);</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;针对数组长度为: %.1f万的随机数组,冒泡排序算法排序%d次的平均运行时间为: %lf s\n&quot;</span>, maxSize / <span class="number">10000.0</span>, <span class="number">10</span>, time2 / <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>auxiliary.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RightMethod</span><span class="params">(ArrPtr pArr1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qsort</span>(pArr1-&gt;elem, pArr1-&gt;length, <span class="built_in">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *_a, <span class="type">const</span> <span class="type">void</span> *_b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span> *)_a - *(<span class="type">int</span> *)_b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(ArrPtr pArr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pArr-&gt;elem == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, pArr-&gt;elem[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Generate_Random_Array</span><span class="params">(ArrPtr pArr1, <span class="type">int</span> maxSize, <span class="type">int</span> maxVal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    pArr1-&gt;length = maxSize;</span><br><span class="line">    pArr1-&gt;elem = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * pArr1-&gt;length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr1-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pArr1-&gt;elem[i] = <span class="built_in">rand</span>() % (maxVal + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Copy_Array</span><span class="params">(ArrPtr pArr1, ArrPtr pArr2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pArr2-&gt;length = pArr1-&gt;length;</span><br><span class="line">    pArr2-&gt;elem = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * pArr2-&gt;length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr2-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pArr2-&gt;elem[i] = pArr1-&gt;elem[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Compare</span><span class="params">(ArrPtr pArr1, ArrPtr pArr2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr1-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pArr1-&gt;elem[i] != pArr2-&gt;elem[i])</span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Bubble_sort.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bubble_sort</span><span class="params">(ArrPtr pArr2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> hasSwap = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> lastSwapIndex = pArr2-&gt;length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr2-&gt;length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasSwap)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        hasSwap = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> end = lastSwapIndex;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; end; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pArr2-&gt;elem[j] &gt; pArr2-&gt;elem[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(&amp;pArr2-&gt;elem[j], &amp;pArr2-&gt;elem[j + <span class="number">1</span>]);</span><br><span class="line">                hasSwap = <span class="literal">true</span>;</span><br><span class="line">                lastSwapIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bubble_sort1</span><span class="params">(ArrPtr pArr2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = pArr2-&gt;length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt; right; i++)</span><br><span class="line">            <span class="keyword">if</span> (pArr2-&gt;elem[i] &gt; pArr2-&gt;elem[i + <span class="number">1</span>])</span><br><span class="line">                <span class="built_in">swap</span>(&amp;pArr2-&gt;elem[i], &amp;pArr2-&gt;elem[i + <span class="number">1</span>]);</span><br><span class="line">        right--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = right; i &gt; left; i--)</span><br><span class="line">            <span class="keyword">if</span> (pArr2-&gt;elem[i] &lt; pArr2-&gt;elem[i - <span class="number">1</span>])</span><br><span class="line">                <span class="built_in">swap</span>(&amp;pArr2-&gt;elem[i], &amp;pArr2-&gt;elem[i - <span class="number">1</span>]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验二-KMP算法"><a href="#实验二-KMP算法" class="headerlink" title="实验二 KMP算法"></a>实验二 KMP算法</h2><p>给定一个字符串 S，以及一个模式串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。<br>模式串 P 在字符串 S 中多次作为子串出现。<br>求出模式串 P 在字符串 S 中所有出现的位置的起始下标。</p><p>输入格式<br>第一行输入整数 N，表示字符串 P 的长度。<br>第二行输入字符串 P（模式串）。<br>第三行输入整数 M，表示字符串 S 的长度。<br>第四行输入字符串 S（主串）。</p><p>输出格式<br>共一行，输出所有出现位置的起始下标（下标从 0 开始计数），整数之间用空格隔开。</p><p>数据范围<br>1≤N≤10^5<br>1≤M≤10^6</p><p>输入样例：<br>3<br>aba<br>5<br>ababa<br>输出样例：<br>0 2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"><span class="type">char</span> s[M], p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 为了便于理解，不使用数组的0下标</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求next数组（递推）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要明确，i表示数组下标，即模式串每个字符的位置；j表示对应数组下标中的值，即公共前后缀的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// next数组的值只与前一个状态有关</span></span><br><span class="line">    <span class="comment">// 若不匹配，一直往前退到 0 或 匹配为止</span></span><br><span class="line">    <span class="comment">// 若匹配，则将之前的结果传递</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每一趟循环都将填好next数组的一个位置，即模式串每个字符所在位置对应的最大公共前后缀的数量，而用于填充的数字（即公共的前后缀数量），是由之前的结果递推来得来的，比如j+1的位置发生了失配,那么用于填充的数字就会回溯到j位置时的大小（失配可能不止一次，所以用于填充的数字会不断的回退到之前的某一种结果当中）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// （求next数组后，数组中对应下标的位置里存放的值才是最大的公共前后缀的数量，这里j是用来求值的，还不是结果）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// next数组从第二个位置开始填入，因为我们用不到第零个位置，第一个位置表示第一个字符，而第一个字符一定没有前缀，不用匹配</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 匹配的位置是i和j+1，所以这里的ne[j]当中的j的意义是说，j+1不匹配，因此j就要回到上一个位置的ne的值，所以等号左边的j是长度的意思，右边的j是指位置。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// i和j+1匹配失败，则j开始回退</span></span><br><span class="line">        <span class="comment">// 当j回退到0时，说明退无可退了，即不存在公共前后缀,对于匹配过程来说就是将模式串的第1个字符和主串中的下一个字符开始比较</span></span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>])</span><br><span class="line">            j = ne[j];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i和j+1匹配成功，则增加前后缀长度，看一下位置是否能继续匹配</span></span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>])</span><br><span class="line">            j++;</span><br><span class="line"></span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匹配过程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要明确，i表示数组下标，即主串每个字符的位置；j表示模式串中和主串匹配的字符长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>])</span><br><span class="line">            j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>])</span><br><span class="line">            j++;</span><br><span class="line">        <span class="comment">// j的长度等于模式串的长度，说明我们已经找到了一个和模板串匹配的位置</span></span><br><span class="line">        <span class="keyword">if</span> (j == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// i为我们匹配结束的位置，不是开始匹配的位置，所以一定要记得减去模式串的长度（i - n + 1）才是我们开始匹配到的位置</span></span><br><span class="line">            <span class="comment">// 注意：题目要求的下标是从0开始的，但这里我们的下标是从1开始的，所以是 长度 - 1（即 i - n + 1 - 1  == i - n）</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i - n);</span><br><span class="line">            <span class="comment">// 匹配成功后，j往后回退一个位置，因为匹配成功之后，j将不能再往后走，这时我们想知道，对于主串的下一个字符，下次再重新匹配时，可以把模式串最少往后移动多少，即回到了最初的问题，寻找模式串当前位置的最大的公共前后缀和的值</span></span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作业18-桶排序"><a href="#作业18-桶排序" class="headerlink" title="作业18 桶排序"></a>作业18 桶排序</h2><p>同作业1</p><h2 id="实验三-搜索算法求解数独问题"><a href="#实验三-搜索算法求解数独问题" class="headerlink" title="实验三 搜索算法求解数独问题"></a>实验三 搜索算法求解数独问题</h2><p>来源：《算法竞赛进阶指南》, POJ3074, kuangbin专题</p><p>数独 是一种传统益智游戏，你需要把一个 9×9 的数独补充完整，使得数独中每行、每列、每个 3×3 的九宫格内数字 1∼9 均恰好出现一次。<br>请编写一个程序填写数独。<br>输入格式<br>输入包含多组测试用例。</p><p>每个测试用例占一行，包含 81 个字符，代表数独的 81 个格内数据（顺序总体由上到下，同行由左到右）。</p><p>每个字符都是一个数字（1−9）或一个 .（表示尚未填充）。</p><p>您可以假设输入中的每个谜题都只有一个解决方案。</p><p>文件结尾处为包含单词 end 的单行，表示输入结束。</p><p>输出格式<br>每个测试用例，输出一行数据，代表填充完全后的数独。</p><p>输入样例：<br>4…..8.5.3……….7……2…..6…..8.4……1…….6.3.7.5..2…..1.4……<br>……52..8.4……3…9…5.1…6..2..7……..3…..6…1……….7.4…….3.<br>end</p><p>输出样例：<br>417369825632158947958724316825437169791586432346912758289643571573291684164875293<br>416837529982465371735129468571298643293746185864351297647913852359682714128574936</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">9</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> table[M], ones[M];</span><br><span class="line"><span class="type">int</span> row[N], col[N], cell[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">char</span> str[<span class="number">81</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        row[i] = col[i] = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">            cell[i][j] = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> row[x] &amp; col[y] &amp; cell[x / <span class="number">3</span>][y / <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!count)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> least_choice = N;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">            <span class="keyword">if</span> (str[i * N + j] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> state = <span class="built_in">get</span>(i, j);</span><br><span class="line">                <span class="keyword">if</span> (ones[state] &lt; least_choice)</span><br><span class="line">                &#123;</span><br><span class="line">                    least_choice = ones[state];</span><br><span class="line">                    x = i, y = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="type">int</span> state = <span class="built_in">get</span>(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = state; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = table[<span class="built_in">lowbit</span>(i)];</span><br><span class="line"></span><br><span class="line">        row[x] -= <span class="number">1</span> &lt;&lt; t;</span><br><span class="line">        col[y] -= <span class="number">1</span> &lt;&lt; t;</span><br><span class="line">        cell[x / <span class="number">3</span>][y / <span class="number">3</span>] -= <span class="number">1</span> &lt;&lt; t;</span><br><span class="line">        str[x * N + y] = <span class="string">&#x27;1&#x27;</span> + t;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(count - <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        row[x] += <span class="number">1</span> &lt;&lt; t;</span><br><span class="line">        col[y] += <span class="number">1</span> &lt;&lt; t;</span><br><span class="line">        cell[x / <span class="number">3</span>][y / <span class="number">3</span>] += <span class="number">1</span> &lt;&lt; t;</span><br><span class="line">        str[x * N + y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        table[<span class="number">1</span> &lt;&lt; i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j; j -= <span class="built_in">lowbit</span>(j))</span><br><span class="line">            count++;</span><br><span class="line">        ones[i] = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; str, str[<span class="number">0</span>] != <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++, k++)</span><br><span class="line">                <span class="keyword">if</span> (str[k] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> t = str[k] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    row[i] -= <span class="number">1</span> &lt;&lt; t;</span><br><span class="line">                    col[j] -= <span class="number">1</span> &lt;&lt; t;</span><br><span class="line">                    cell[i / <span class="number">3</span>][j / <span class="number">3</span>] -= <span class="number">1</span> &lt;&lt; t;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    count++;</span><br><span class="line">        <span class="built_in">dfs</span>(count);</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;算法课题目与代码&quot;&gt;&lt;a href=&quot;#算法课题目与代码&quot; class=&quot;headerlink&quot; title=&quot;算法课题目与代码&quot;&gt;&lt;/a&gt;算法课题目与代码&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这里用来记录算法课所有涉及到的题目的题面以及代码，供大家参考学习。&lt;/p&gt;
&lt;p&gt;所有讲解视频已经上传B站，B站名称：小猪佩奇_教学&lt;/p&gt;
&lt;p&gt;有任何问题请加QQ联系我&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://sixteen-nights.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法课" scheme="https://sixteen-nights.github.io/tags/%E7%AE%97%E6%B3%95%E8%AF%BE/"/>
    
    <category term="代码记录" scheme="https://sixteen-nights.github.io/tags/%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>STL与常用库</title>
    <link href="https://sixteen-nights.github.io/2023/02/24/STL%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%BA%93/"/>
    <id>https://sixteen-nights.github.io/2023/02/24/STL%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%BA%93/</id>
    <published>2023-02-24T14:40:00.000Z</published>
    <updated>2023-02-25T04:55:41.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STL与常用库"><a href="#STL与常用库" class="headerlink" title="STL与常用库"></a>STL与常用库</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类与结构体的区别"><a href="#类与结构体的区别" class="headerlink" title="类与结构体的区别"></a>类与结构体的区别</h3><p>​唯一区别是，对于其中不加修饰符的属性和方法，类默认其是私有的，结构体默认其是公共的；</p><span id="more"></span><h3 id="类的构造函数简写"><a href="#类的构造函数简写" class="headerlink" title="类的构造函数简写"></a>类的构造函数简写</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> age, height;</span><br><span class="line">    <span class="type">double</span> money;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>() &#123;<span class="type">int</span> _age, <span class="type">int</span> _height&#125; : <span class="built_in">age</span>(_age), <span class="built_in">height</span>(_height) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>() &#123;<span class="type">int</span> _age, <span class="type">int</span> _height, <span class="type">double</span> _money&#125; : <span class="built_in">age</span>(_age), <span class="built_in">height</span>(_height), <span class="built_in">money</span>(_money) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p = &#123;<span class="number">18</span>, <span class="number">180</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>​vector是变长数组，支持随机访问，不支持在任意位置O(1)插入。为了保证效率，元素的增删一般应该在末尾进行。</p><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> 头文件</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;相当于一个长度动态变化的<span class="type">int</span>数组</span><br><span class="line">    </span><br><span class="line">vector&lt;<span class="type">int</span>&gt; b[<span class="number">233</span>];相当于第一维长<span class="number">233</span>，第二位长度动态变化的<span class="type">int</span>数组</span><br><span class="line">    </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rec</span>&#123;…&#125;;</span><br><span class="line">vector&lt;rec&gt; c;自定义的结构体类型也可以保存在vector中</span><br></pre></td></tr></table></figure><h4 id="size-x2F-empty"><a href="#size-x2F-empty" class="headerlink" title="size&#x2F;empty"></a>size&#x2F;empty</h4><p>​size函数返回vector的实际长度（包含的元素个数），empty函数返回一个bool类型，表明vector是否为空。二者的时间复杂度都是O(1)。</p><p>​所有的STL容器都支持这两个方法，含义也相同，之后不再重复给出。</p><h4 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h4><p>​clear函数把vector清空。</p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>​迭代器就像STL容器的“指针”，可以用星号“*”操作符解除引用。一个保存int的vector的迭代器声明方法为：</p><p>​<code>vector&lt;int&gt;::iterator it;</code></p><p>​vector的迭代器是“随机访问迭代器”，可以把vector的迭代器与一个整数相加减，其行为和指针的移动类似。可以把vector的两个迭代器相减，其结果也和指针相减类似，得到两个迭代器对应下标之间的距离。</p><h4 id="begin-x2F-end"><a href="#begin-x2F-end" class="headerlink" title="begin&#x2F;end"></a>begin&#x2F;end</h4><p>​begin函数返回指向vector中第一个元素的迭代器。例如a是一个非空的vector，则*a.begin()与a[0]的作用相同。</p><p>​所有的容器都可以视作一个“前闭后开”的结构，end函数返回vector的尾部，即第n个元素再往后的“边界”。*a.end()与a[n]都是越界访问，其中 n&#x3D;a.size()。</p><p>​下面两份代码都遍历了<code>vector&lt;int&gt;a</code>，并输出它的所有元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++) </span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = a.<span class="built_in">begin</span>(); it != a.<span class="built_in">end</span>(); it ++) cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="front-x2F-back"><a href="#front-x2F-back" class="headerlink" title="front&#x2F;back"></a>front&#x2F;back</h4><p>​front函数返回vector的第一个元素，等价于*a.begin() 和 a[0]。</p><p>​back函数返回vector的最后一个元素，等价于*&#x3D;&#x3D;a.end() 和 a[a.size() – 1]。</p><h4 id="push-back-和-pop-back"><a href="#push-back-和-pop-back" class="headerlink" title="push_back() 和 pop_back()"></a>push_back() 和 pop_back()</h4><p>​a.push_back(x) 把元素x插入到vector a的尾部。</p><p>​b.pop_back() 删除vector a的最后一个元素。</p><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>​头文件queue主要包括循环队列queue和优先队列priority_queue两个容器。</p><h4 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rec</span>&#123;…&#125;; </span><br><span class="line">queue&lt;rec&gt; q; <span class="comment">//结构体rec中必须定义小于号</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;<span class="comment">// 大根堆</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; q;<span class="comment">// 小根堆</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;q;</span><br></pre></td></tr></table></figure><h4 id="循环队列-queue"><a href="#循环队列-queue" class="headerlink" title="循环队列 queue"></a>循环队列 queue</h4><p>​push 从队尾插入。</p><p>​pop 从队头弹出。</p><p>​front 返回队头元素。</p><p>​back 返回队尾元素。</p><h4 id="优先队列-priority-queue"><a href="#优先队列-priority-queue" class="headerlink" title="优先队列 priority_queue"></a>优先队列 priority_queue</h4><p>​push 把元素插入堆。</p><p>​pop 删除堆顶元素。</p><p>​top 查询堆顶元素（最大值）。</p><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>​头文件stack包含栈。声明和前面的容器类似。</p><p>​push 向栈顶插入。</p><p>​pop 弹出栈顶元素。</p><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>​双端队列deque是一个支持在两端高效插入或删除元素的连续线性存储空间。它就像是vector和queue的结合。与vector相比，deque在头部增删元素仅需要O(1)的时间；与queue相比，deque像数组一样支持随机访问。</p><p>​[] 随机访问。</p><p>​begin&#x2F;end，返回deque的头&#x2F;尾迭代器</p><p>​front&#x2F;back 队头&#x2F;队尾元素。</p><p>​push_back 从队尾入队。</p><p>​push_front 从队头入队。</p><p>​pop_back 从队尾出队。</p><p>​pop_front 从队头出队。</p><p>​clear 清空队列。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>​头文件set主要包括set和multiset两个容器，分别是“有序集合”和“有序多重集合”，即前者的元素不能重复，而后者可以包含若干个相等的元素。set和multiset的内部实现是一棵红黑树，它们支持的函数基本相同。</p><h4 id="声明-2"><a href="#声明-2" class="headerlink" title="声明"></a>声明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rec</span>&#123;…&#125;;</span><br><span class="line">set&lt;rec&gt; s;<span class="comment">// 结构体rec中必须定义小于号</span></span><br><span class="line"></span><br><span class="line">multiset&lt;<span class="type">double</span>&gt; s;</span><br></pre></td></tr></table></figure><h4 id="size-x2F-empty-x2F-clear"><a href="#size-x2F-empty-x2F-clear" class="headerlink" title="size&#x2F;empty&#x2F;clear"></a>size&#x2F;empty&#x2F;clear</h4><p>​与vector类似。</p><h4 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h4><p>​set和multiset的迭代器称为“双向访问迭代器”，不支持“随机访问”，支持星号(*)解除引用，仅支持”++”和–“两个与算术相关的操作。</p><p>​设it是一个迭代器，例如set<int>::iterator it;</p><p>​若把it++，则it会指向“下一个”元素。这里的“下一个”元素是指在元素从小到大排序的结果中，排在it下一名的元素。同理，若把it–，则it将会指向排在“上一个”的元素。</p><h4 id="begin-x2F-end-1"><a href="#begin-x2F-end-1" class="headerlink" title="begin&#x2F;end"></a>begin&#x2F;end</h4><p>​返回集合的首、尾迭代器，时间复杂度均为O(1)。</p><p>​s.begin() 是指向集合中最小元素的迭代器。</p><p>​s.end() 是指向集合中最大元素的下一个位置的迭代器。换言之，就像vector一样，是一个“前闭后开”的形式。因此–s.end()是指向集合中最大元素的迭代器。</p><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>​s.insert(x)把一个元素x插入到集合s中，时间复杂度为O(logn)。</p><p>​在set中，若元素已存在，则不会重复插入该元素，对集合的状态无影响。</p><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>​s.find(x) 在集合s中查找等于x的元素，并返回指向该元素的迭代器。若不存在，则返回s.end()。时间复杂度为O(logn)。</p><h4 id="lower-bound-x2F-upper-bound"><a href="#lower-bound-x2F-upper-bound" class="headerlink" title="lower_bound&#x2F;upper_bound"></a>lower_bound&#x2F;upper_bound</h4><p>​这两个函数的用法与find类似，但查找的条件略有不同，时间复杂度为 O(logn)。</p><p>​s.lower_bound(x) 查找大于等于x的元素中最小的一个，并返回指向该元素的迭代器。</p><p>​s.upper_bound(x) 查找大于x的元素中最小的一个，并返回指向该元素的迭代器。</p><h4 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h4><p>​设it是一个迭代器，s.erase(it) 从s中删除迭代器it指向的元素，时间复杂度为O(logn)</p><p>​设x是一个元素，s.erase(x) 从s中删除所有等于x的元素，时间复杂度为O(k+logn)，其中k是被删除的元素个数。</p><h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><p>​s.count(x) 返回集合s中等于x的元素个数，时间复杂度为 O(k +logn)，其中k为元素x的个数。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>​map容器是一个键值对key-value的映射，其内部实现是一棵以key为关键码的红黑树。Map的key和value可以是任意类型，其中key必须定义小于号运算符。</p><h4 id="声明-3"><a href="#声明-3" class="headerlink" title="声明"></a>声明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map&lt;key_type, value_type&gt; name;</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">map&lt;<span class="type">long</span>, <span class="type">long</span>, <span class="type">bool</span>&gt; vis;</span><br><span class="line"></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; hash;</span><br><span class="line"></span><br><span class="line">map&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;<span class="type">int</span>&gt;&gt; test;</span><br></pre></td></tr></table></figure><h4 id="size-x2F-empty-x2F-clear-x2F-begin-x2F-end"><a href="#size-x2F-empty-x2F-clear-x2F-begin-x2F-end" class="headerlink" title="size&#x2F;empty&#x2F;clear&#x2F;begin&#x2F;end"></a>size&#x2F;empty&#x2F;clear&#x2F;begin&#x2F;end</h4><p>​均与set类似。</p><h4 id="Insert-x2F-erase"><a href="#Insert-x2F-erase" class="headerlink" title="Insert&#x2F;erase"></a>Insert&#x2F;erase</h4><p>​与set类似，但其参数均是pair&lt;key_type, value_type&gt;。</p><h4 id="find-1"><a href="#find-1" class="headerlink" title="find"></a>find</h4><p>​h.find(x) 在变量名为h的map中查找key为x的二元组。</p><h4 id="操作符"><a href="#操作符" class="headerlink" title="[]操作符"></a>[]操作符</h4><p>​h[key] 返回key映射的value的引用，时间复杂度为O(logn)。</p><p>​[]操作符是map最吸引人的地方。我们可以很方便地通过h[key]来得到key对应的value，还可以对h[key]进行赋值操作，改变key对应的value。</p><h2 id="常用库"><a href="#常用库" class="headerlink" title="常用库"></a>常用库</h2><h3 id="reverse-翻转"><a href="#reverse-翻转" class="headerlink" title="reverse 翻转"></a>reverse 翻转</h3><p>​翻转一个vector：</p><p>​<code>reverse(a.begin(), a.end());</code></p><p>​翻转一个数组，元素存放在下标1~n：</p><p>​<code>reverse(a + 1, a + 1 + n);</code></p><h3 id="unique-去重"><a href="#unique-去重" class="headerlink" title="unique 去重"></a>unique 去重</h3><p>​返回去重之后的尾迭代器（或指针），仍然为前闭后开，即这个迭代器是去重之后末尾元素的下一个位置。该函数常用于离散化，利用迭代器（或指针）的减法，可计算出去重后的元素个数。</p><p>​把一个vector去重：</p><p>​<code>int m = unique(a.begin(), a.end()) – a.begin();</code></p><p>​把一个数组去重，元素存放在下标1~n：</p><p>​<code>int m = unique(a + 1, a + 1 + n) – (a + 1);</code></p><h3 id="random-shuffle-随机打乱"><a href="#random-shuffle-随机打乱" class="headerlink" title="random_shuffle 随机打乱"></a>random_shuffle 随机打乱</h3><p>​用法与reverse相同。</p><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>​对两个迭代器（或指针）指定的部分进行快速排序。可以在第三个参数传入定义大小比较的函数，或者重载“小于号”运算符。</p><p>​把一个int数组（元素存放在下标1~n）从大到小排序，传入比较函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[MAX_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, cmp);</span><br></pre></td></tr></table></figure><p>​把自定义的结构体vector排序，重载“小于号”运算符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rec</span>&#123; <span class="type">int</span> id, x, y; &#125;</span><br><span class="line"></span><br><span class="line">vector&lt;rec&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> rec &amp;a, <span class="type">const</span> rec &amp;b) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a.x &lt; b.x || a.x == b.x &amp;&amp; a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h3 id="lower-bound-x2F-upper-bound-二分"><a href="#lower-bound-x2F-upper-bound-二分" class="headerlink" title="lower_bound&#x2F;upper_bound  二分"></a>lower_bound&#x2F;upper_bound  二分</h3><p>​lower_bound 的第三个参数传入一个元素x，在两个迭代器（指针）指定的部分上执行二分查找，返回指向第一个大于等于x的元素的位置的迭代器（指针）。</p><p>​upper_bound 的用法和lower_bound大致相同，唯一的区别是查找第一个大于x的元素。当然，两个迭代器（指针）指定的部分应该是提前排好序的。</p><p>​在有序int数组（元素存放在下标1~n）中查找大于等于x的最小整数的下标：</p><p>​<code>int I = lower_bound(a + 1, a + 1 + n,. x) – a;</code></p><p>​在有序vector<int> 中查找小于等于x的最大整数（假设一定存在）：</p><p>​<code>int y = *--upper_bound(a.begin(), a.end(), x);</code></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;STL与常用库&quot;&gt;&lt;a href=&quot;#STL与常用库&quot; class=&quot;headerlink&quot; title=&quot;STL与常用库&quot;&gt;&lt;/a&gt;STL与常用库&lt;/h1&gt;&lt;h2 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h2&gt;&lt;h3 id=&quot;类与结构体的区别&quot;&gt;&lt;a href=&quot;#类与结构体的区别&quot; class=&quot;headerlink&quot; title=&quot;类与结构体的区别&quot;&gt;&lt;/a&gt;类与结构体的区别&lt;/h3&gt;&lt;p&gt;​	唯一区别是，对于其中不加修饰符的属性和方法，类默认其是私有的，结构体默认其是公共的；&lt;/p&gt;</summary>
    
    
    
    <category term="c++语法" scheme="https://sixteen-nights.github.io/categories/c-%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="STL" scheme="https://sixteen-nights.github.io/tags/STL/"/>
    
    <category term="常用库" scheme="https://sixteen-nights.github.io/tags/%E5%B8%B8%E7%94%A8%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>C语言数据结构的程序实现</title>
    <link href="https://sixteen-nights.github.io/2022/10/01/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://sixteen-nights.github.io/2022/10/01/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-10-01T07:40:00.000Z</published>
    <updated>2023-03-30T05:49:29.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构的程序实现"><a href="#数据结构的程序实现" class="headerlink" title="数据结构的程序实现"></a>数据结构的程序实现</h1><p>​本文主要为使用c语言对数据结构相关内容进行代码实现。</p><span id="more"></span><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLIST_INIT_SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INC_SIZE 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType *elem;</span><br><span class="line"><span class="type">int</span> capacity;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Menu</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSqList</span><span class="params">(SqList *<span class="built_in">list</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IncSqList</span><span class="params">(SqList *<span class="built_in">list</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Input</span><span class="params">(SqList *<span class="built_in">list</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListInsert</span><span class="params">(SqList *<span class="built_in">list</span>, <span class="type">int</span> i, ElemType e)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListDelete</span><span class="params">(SqList *<span class="built_in">list</span>, <span class="type">int</span> i)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Length</span><span class="params">(SqList *<span class="built_in">list</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">GetElem</span><span class="params">(SqList *<span class="built_in">list</span>, <span class="type">int</span> i)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Display</span><span class="params">(SqList *<span class="built_in">list</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Destroy</span><span class="params">(SqList *<span class="built_in">list</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\n\n\n\n&quot;</span>); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|--------------------------------------------主菜单-------------------------------------------|\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|0. 退出程序                                                                                  |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|1. 顺序表扩容                                                                                |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|2. 顺序表填充                                                                                |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|3. 顺序表插入                                                                                |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|4. 顺序表删除                                                                                |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|5. 顺序表长度                                                                                |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|6. 顺序表取值                                                                                |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|7. 顺序表显示                                                                                |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|8. 顺序表清空                                                                                |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|---------------------------------------------------------------------------------------------|\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t\t请选择(0-8):&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSqList</span><span class="params">(SqList *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>-&gt;elem = (ElemType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType) * SQLIST_INIT_SIZE);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">list</span>-&gt;elem)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;分配内存空间失败\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>-&gt;capacity = SQLIST_INIT_SIZE;</span><br><span class="line"><span class="built_in">list</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IncSqList</span><span class="params">(SqList *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">ElemType *newelem = (ElemType *)<span class="built_in">realloc</span>(<span class="built_in">list</span>-&gt;elem, <span class="keyword">sizeof</span>(ElemType) * (<span class="built_in">list</span>-&gt;capacity + INC_SIZE));</span><br><span class="line"><span class="keyword">if</span> (!newelem)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;分配内存空间失败\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>-&gt;elem = newelem;</span><br><span class="line"><span class="built_in">list</span>-&gt;capacity += INC_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;分配内存空间成功\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Input</span><span class="params">(SqList *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span>-&gt;length &gt;= <span class="built_in">list</span>-&gt;capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序表空间已满，请扩容\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请问是否需要填充顺序表?(y/n):&quot;</span>);</span><br><span class="line"><span class="type">char</span> ch[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ch);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">strcmp</span>(ch, <span class="string">&quot;Y&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(ch, <span class="string">&quot;y&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要填入的数字:\n&quot;</span>);</span><br><span class="line">ElemType e;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;e);</span><br><span class="line"><span class="built_in">list</span>-&gt;elem[<span class="built_in">list</span>-&gt;length++] = e;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d填充成功\n&quot;</span>,e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;是否继续?(y/n):&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListInsert</span><span class="params">(SqList *<span class="built_in">list</span>, <span class="type">int</span> i, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((i &lt; <span class="number">1</span>) || (i &gt; <span class="built_in">list</span>-&gt;length + <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入位置不合法\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span>-&gt;length == <span class="built_in">list</span>-&gt;capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序表空间已满，请扩容\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="built_in">list</span>-&gt;length - <span class="number">1</span>; j &gt;= i<span class="number">-1</span>; j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>-&gt;elem[j + <span class="number">1</span>] = <span class="built_in">list</span>-&gt;elem[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">list</span>-&gt;elem[i - <span class="number">1</span>] = e;</span><br><span class="line"><span class="built_in">list</span>-&gt;length++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入成功！敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListDelete</span><span class="params">(SqList *<span class="built_in">list</span>, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((i &lt; <span class="number">1</span>) || (i &gt; <span class="built_in">list</span>-&gt;length))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除位置不合法\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= <span class="built_in">list</span>-&gt;length - <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>-&gt;elem[j - <span class="number">1</span>] = <span class="built_in">list</span>-&gt;elem[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">list</span>-&gt;length--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除成功！敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Length</span><span class="params">(SqList *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">list</span>-&gt;length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetElem</span><span class="params">(SqList *<span class="built_in">list</span>, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">list</span>-&gt;elem[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Display</span><span class="params">(SqList *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前顺序表为:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,<span class="built_in">list</span>-&gt;elem[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Destroy</span><span class="params">(SqList *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">list</span>-&gt;elem);</span><br><span class="line"><span class="built_in">list</span>-&gt;elem = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">list</span>-&gt;capacity = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">list</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序表已销毁！敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Menu();</span><br><span class="line"></span><br><span class="line">SqList <span class="built_in">list</span>;</span><br><span class="line">InitSqList(&amp;<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">ElemType e;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">while</span> (n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line">IncSqList(&amp;<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: </span><br><span class="line">Input(&amp;<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要插入的数据:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要插入的位置:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i);</span><br><span class="line">ListInsert(&amp;<span class="built_in">list</span>, i, e);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要删除数据的位置:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i);</span><br><span class="line">ListDelete(&amp;<span class="built_in">list</span>, i);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>: </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序表的长度为:%d\n敲击回车返回主菜单&quot;</span>,Length(&amp;<span class="built_in">list</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要取值顺序表的第几项:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i);</span><br><span class="line"><span class="keyword">if</span> ((i &lt; <span class="number">1</span>) || (i &gt; <span class="built_in">list</span>.length))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;取值位置不合法\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序表第%d项的值为:%d\n敲击回车返回主菜单&quot;</span>, i, GetElem(&amp;<span class="built_in">list</span>, i));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>: </span><br><span class="line">Display(&amp;<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>: </span><br><span class="line">Destroy(&amp;<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入错误请重新输入\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">getch();</span><br><span class="line">Menu();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="链表-以图书管理系统为例"><a href="#链表-以图书管理系统为例" class="headerlink" title="链表(以图书管理系统为例)"></a>链表(以图书管理系统为例)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> no[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="type">float</span> price;</span><br><span class="line">&#125;Book;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Book data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Menu</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(LinkList L)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InputList_H</span><span class="params">(LinkList L)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InputList_R</span><span class="params">(LinkList L)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LocateElem</span><span class="params">(LinkList L)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListInsert</span><span class="params">(LinkList L, <span class="type">int</span> i)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListDelete</span><span class="params">(LinkList L, <span class="type">int</span> i)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListDisplay</span><span class="params">(LinkList L)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListDestory</span><span class="params">(LinkList L)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\n\n\n\n&quot;</span>); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|--------------------------------------------主菜单-------------------------------------------|\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|0. 退出程序                                                                                  |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|1. 单链表填充（头插）                                                                        |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|2. 单链表填充（尾插）                                                                        |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|3. 单链表取值                                                                                |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|4. 单链表查找                                                                                |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|5. 单链表插入                                                                                |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|6. 单链表删除                                                                                |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|7. 单链表显示                                                                                |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|8. 单链表销毁                                                                                |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|---------------------------------------------------------------------------------------------|\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t\t请选择(0-8):&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(LinkList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">*L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line"><span class="keyword">if</span> (!(*L))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;初始化定义失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">(*L)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InputList_H</span><span class="params">(LinkList L)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请问是否需要录入图书信息?(y/n):&quot;</span>);</span><br><span class="line"><span class="type">char</span> ch[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ch);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">strcmp</span>(ch, <span class="string">&quot;Y&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(ch, <span class="string">&quot;y&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">LNode *p = <span class="literal">NULL</span>;</span><br><span class="line">p = (<span class="keyword">struct</span> LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;编号(示例：210459267):&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,p-&gt;data.no);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;书名(示例：《高速退学》):&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,p-&gt;data.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;价格(示例：44.4):&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;(p-&gt;data.price));</span><br><span class="line">p-&gt;next = L-&gt;next;</span><br><span class="line">L-&gt;next = p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s 录入成功\n&quot;</span>,p-&gt;data.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;是否继续?(y/n):&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InputList_R</span><span class="params">(LinkList L)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请问是否需要录入图书信息?(y/n):&quot;</span>);</span><br><span class="line"><span class="type">char</span> ch[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ch);</span><br><span class="line">LNode *r = L;</span><br><span class="line"><span class="keyword">while</span> (r-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">r = r-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">strcmp</span>(ch, <span class="string">&quot;Y&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(ch, <span class="string">&quot;y&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">LNode *p = (<span class="keyword">struct</span> LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;编号(示例：210459267):&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,p-&gt;data.no);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;书名(示例：《数据结构》):&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,p-&gt;data.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;价格(示例：35.0):&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;(p-&gt;data.price));</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">r-&gt;next = p;</span><br><span class="line">r = p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s 录入成功\n&quot;</span>,p-&gt;data.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;是否继续?(y/n):&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">LNode *p = L-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; j &lt; i)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!p || j &gt; i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;取值位置不合法\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;第%d本图书的书名是:%s\n&quot;</span>, i, p-&gt;data.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LocateElem</span><span class="params">(LinkList L)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入你想查找的图书名:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">LNode *p = L-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; <span class="built_in">strcmp</span>(p-&gt;data.name, name) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;该图书的编号为:%s\n&quot;</span>, p-&gt;data.no);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;该图书的价格为:%f\n&quot;</span>, p-&gt;data.price);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListInsert</span><span class="params">(LinkList L, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">LNode *p = L;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; (j &lt; i - <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!p || j &gt; i - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入位置不合法\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">LNode *s = (<span class="keyword">struct</span> LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;编号(示例：210459267):&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s-&gt;data.no);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;书名(示例：《数据结构》):&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s-&gt;data.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;价格(示例：35.0):&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;(s-&gt;data.price));</span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = s;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s 录入成功\n&quot;</span>,s-&gt;data.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListDelete</span><span class="params">(LinkList L, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">LNode *p = L;</span><br><span class="line"><span class="keyword">while</span> ((p-&gt;next) &amp;&amp; (j &lt; i - <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;next) || j &gt; i - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除位置不合法\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">LNode *q = p-&gt;next;</span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s 删除成功\n&quot;</span>,q-&gt;data.name);</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">q = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListDisplay</span><span class="params">(LinkList L)</span></span><br><span class="line">&#123;</span><br><span class="line">LNode *p = L-&gt;next;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;编号\t书名\t价格\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\t%s\t%f\n&quot;</span>, p-&gt;data.no, p-&gt;data.name, p-&gt;data.price);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListDestory</span><span class="params">(LinkList L)</span></span><br><span class="line">&#123;</span><br><span class="line">LNode *p = L;</span><br><span class="line">LNode *q = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line">q = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = q;</span><br><span class="line">&#125;</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">q = <span class="literal">NULL</span>;</span><br><span class="line">L = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;链表已销毁\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Menu();</span><br><span class="line">    </span><br><span class="line">LinkList L = <span class="literal">NULL</span>;</span><br><span class="line">InitList(&amp;L);</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> choose;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choose);</span><br><span class="line"><span class="keyword">while</span> (choose)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (choose)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">InputList_H(L);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">InputList_R(L);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要取出表中第几本书的书名:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i);</span><br><span class="line">GetElem(L, i);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">LocateElem(L);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要插入的位置:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i);</span><br><span class="line">ListInsert(L, i);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要删除的位置:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i);</span><br><span class="line">ListDelete(L, i);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">ListDisplay(L);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">ListDestory(L);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入错误请重新输入\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">getch();</span><br><span class="line">Menu();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choose);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆栈和队列"><a href="#堆栈和队列" class="headerlink" title="堆栈和队列"></a>堆栈和队列</h2><h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">SElemType *base;</span><br><span class="line">SElemType *top;</span><br><span class="line"><span class="type">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Menu</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack *S)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(SqStack *S)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Pop</span><span class="params">(SqStack *S)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GetTop</span><span class="params">(SqStack *S)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplayStack</span><span class="params">(SqStack *S)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyStack</span><span class="params">(SqStack *S)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\n\n\n\n&quot;</span>); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|--------------------------------------------主菜单-------------------------------------------|\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|0. 退出程序                                                                                  |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|1. 入栈                                                                                      |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|2. 出栈                                                                                      |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|3. 取栈顶元素                                                                                |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|4. 展示栈内元素(从栈底到栈顶)                                                                |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|5. 销毁栈                                                                                    |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|---------------------------------------------------------------------------------------------|\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t\t请选择(0-5):&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack *S)</span></span><br><span class="line">&#123;</span><br><span class="line">S-&gt;base = (SElemType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SElemType) * MAXSIZE);</span><br><span class="line"><span class="keyword">if</span> (!S-&gt;base)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;分配内存空间失败\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">S-&gt;top = S-&gt;base;</span><br><span class="line">S-&gt;stacksize = MAXSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(SqStack *S)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;top - S-&gt;base == S-&gt;stacksize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前栈已满\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">SElemType e;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要填入的数字:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;e);</span><br><span class="line">*S-&gt;top++ = e;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d已入栈\n&quot;</span>, e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pop</span><span class="params">(SqStack *S)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;top == S-&gt;base)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前栈空\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">SElemType e;</span><br><span class="line">e = *--S-&gt;top;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d已出栈\n&quot;</span>, e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetTop</span><span class="params">(SqStack *S)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;top == S-&gt;base)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前栈空\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">SElemType e;</span><br><span class="line">e = *(S-&gt;top - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前栈顶元素为%d\n&quot;</span>, e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplayStack</span><span class="params">(SqStack *S)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;top == S-&gt;base)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前栈空\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> size = S-&gt;top - S-&gt;base;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前堆栈元素从栈底到栈顶为:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (; size &gt; <span class="number">0</span>; size--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, *(S-&gt;top - size));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyStack</span><span class="params">(SqStack *S)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(S-&gt;base);</span><br><span class="line">S-&gt;base = <span class="literal">NULL</span>;</span><br><span class="line">S-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">S-&gt;stacksize = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;堆栈已销毁！敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Menu();</span><br><span class="line"></span><br><span class="line">SqStack S;</span><br><span class="line">InitStack(&amp;S);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> choose;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choose);</span><br><span class="line"><span class="keyword">while</span> (choose)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (choose)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">Push(&amp;S);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">Pop(&amp;S);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">GetTop(&amp;S);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">DisplayStack(&amp;S);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">DestroyStack(&amp;S);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入错误请重新输入\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">getch();</span><br><span class="line">Menu();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choose);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StacakNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StacakNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode, *LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Menu</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(LinkStack *S)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Pop</span><span class="params">(LinkStack *S)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GetTop</span><span class="params">(LinkStack S)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplayStack</span><span class="params">(LinkStack S)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyStack</span><span class="params">(LinkStack *S)</span>;</span><br><span class="line"></span><br><span class="line">ElemType e;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\n\n\n\n&quot;</span>); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|--------------------------------------------主菜单-------------------------------------------|\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|0. 退出程序                                                                                  |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|1. 入栈                                                                                      |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|2. 出栈                                                                                      |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|3. 取栈顶元素                                                                                |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|4. 展示栈内元素(从栈顶到栈底)                                                                |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|5. 销毁栈                                                                                    |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|---------------------------------------------------------------------------------------------|\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t\t请选择(0-5):&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(LinkStack *S)</span></span><br><span class="line">&#123;</span><br><span class="line">StackNode *p = (StackNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要填入的数字:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;e);</span><br><span class="line">p-&gt;data = e;</span><br><span class="line">p-&gt;next = *S;</span><br><span class="line">*S = p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d已入栈\n&quot;</span>, e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pop</span><span class="params">(LinkStack *S)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!(*S))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前栈空\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">e = (*S)-&gt;data;</span><br><span class="line">StackNode *temp = *S;</span><br><span class="line">*S = (*S)-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">temp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d已出栈\n&quot;</span>, e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetTop</span><span class="params">(LinkStack S)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!S)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前栈空\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前栈顶元素为%d\n&quot;</span>, S-&gt;data);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplayStack</span><span class="params">(LinkStack S)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!S)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前栈空\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">StackNode *p = S;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前堆栈元素从栈顶到栈底为:\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, p-&gt;data);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyStack</span><span class="params">(LinkStack *S)</span></span><br><span class="line">&#123;</span><br><span class="line">StackNode *p = *S;</span><br><span class="line">StackNode *q = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line">q = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = q;</span><br><span class="line">&#125;</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">q = <span class="literal">NULL</span>;</span><br><span class="line">*S = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;链栈已销毁\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Menu();</span><br><span class="line">    </span><br><span class="line">LinkStack S = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> choose;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choose);</span><br><span class="line"><span class="keyword">while</span> (choose)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (choose)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">Push(&amp;S);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">Pop(&amp;S);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">GetTop(S);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">DisplayStack(S);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">DestroyStack(&amp;S);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入错误请重新输入\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">getch();</span><br><span class="line">Menu();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choose);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="队列-少用一个空间"><a href="#队列-少用一个空间" class="headerlink" title="队列(少用一个空间)"></a>队列(少用一个空间)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QElemType *base;</span><br><span class="line"><span class="type">int</span> front;</span><br><span class="line"><span class="type">int</span> rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Menu</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue *Q)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueLength</span><span class="params">(SqQueue *Q)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue *Q)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue *Q)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GetHead</span><span class="params">(SqQueue *Q)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplayQueue</span><span class="params">(SqQueue *Q)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyQueue</span><span class="params">(SqQueue *Q)</span>;</span><br><span class="line"></span><br><span class="line">QElemType e;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\n\n\n\n&quot;</span>); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|--------------------------------------------主菜单-------------------------------------------|\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|0. 退出程序                                                                                  |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|1. 队列长度                                                                                  |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|2. 入队                                                                                      |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|3. 出队                                                                                      |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|4. 取队头元素                                                                                |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|5. 展示队内元素(从队头到队尾)                                                                |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|6. 销毁队列                                                                                  |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|---------------------------------------------------------------------------------------------|\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t\t请选择(0-6):&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;base = (QElemType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QElemType) * MAXSIZE);</span><br><span class="line"><span class="keyword">if</span> (!Q-&gt;base)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;分配内存空间失败\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Q-&gt;front = Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueLength</span><span class="params">(SqQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> length = (Q-&gt;rear - Q-&gt;front + MAXSIZE) % MAXSIZE;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前队列的长度为:%d\n&quot;</span>, length);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>) % MAXSIZE == Q-&gt;front)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前队已满\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要填入的数字:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;e);</span><br><span class="line">Q-&gt;base[Q-&gt;rear] = e;</span><br><span class="line">Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d已入队\n&quot;</span>, e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前队空\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">e = Q-&gt;base[Q-&gt;front];</span><br><span class="line">Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d已出队\n&quot;</span>, e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetHead</span><span class="params">(SqQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前队空\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前队头元素为%d\n&quot;</span>, Q-&gt;base[Q-&gt;front]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplayQueue</span><span class="params">(SqQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前队空\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> length = (Q-&gt;rear - Q-&gt;front + MAXSIZE) % MAXSIZE;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前队列元素从队头到队尾为:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, Q-&gt;base[(Q-&gt;front + i) % MAXSIZE]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyQueue</span><span class="params">(SqQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(Q-&gt;base);</span><br><span class="line">Q-&gt;base = <span class="literal">NULL</span>;</span><br><span class="line">Q-&gt;front = Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;队列已销毁！敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Menu();</span><br><span class="line"></span><br><span class="line">SqQueue Q;</span><br><span class="line">InitQueue(&amp;Q);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> choose;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choose);</span><br><span class="line"><span class="keyword">while</span> (choose)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (choose)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">QueueLength(&amp;Q);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">EnQueue(&amp;Q);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">DeQueue(&amp;Q);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">GetHead(&amp;Q);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">DisplayQueue(&amp;Q);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">DestroyQueue(&amp;Q);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入错误请重新输入\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">getch();</span><br><span class="line">Menu();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choose);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="队列（标志判断）"><a href="#队列（标志判断）" class="headerlink" title="队列（标志判断）"></a>队列（标志判断）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QElemType *base;</span><br><span class="line"><span class="type">int</span> front;</span><br><span class="line"><span class="type">int</span> rear;</span><br><span class="line"><span class="type">int</span> tag;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Menu</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue *Q)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueLength</span><span class="params">(SqQueue *Q)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue *Q)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue *Q)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GetHead</span><span class="params">(SqQueue *Q)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplayQueue</span><span class="params">(SqQueue *Q)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyQueue</span><span class="params">(SqQueue *Q)</span>;</span><br><span class="line"></span><br><span class="line">QElemType e;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\n\n\n\n&quot;</span>); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|--------------------------------------------主菜单-------------------------------------------|\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|0. 退出程序                                                                                  |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|1. 队列长度                                                                                  |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|2. 入队                                                                                      |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|3. 出队                                                                                      |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|4. 取队头元素                                                                                |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|5. 展示队内元素(从队头到队尾)                                                                |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|6. 销毁队列                                                                                  |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|---------------------------------------------------------------------------------------------|\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t\t请选择(0-6):&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;base = (QElemType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QElemType) * MAXSIZE);</span><br><span class="line"><span class="keyword">if</span> (!Q-&gt;base)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;分配内存空间失败\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Q-&gt;front = Q-&gt;rear = Q-&gt;tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueLength</span><span class="params">(SqQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;rear == Q-&gt;front &amp;&amp; Q-&gt;tag == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">length = MAXSIZE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">length = (Q-&gt;rear - Q-&gt;front + MAXSIZE) % MAXSIZE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;rear == Q-&gt;front &amp;&amp; Q-&gt;tag == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前队已满\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要填入的数字:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;e);</span><br><span class="line">Q-&gt;base[Q-&gt;rear] = e;</span><br><span class="line">Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">Q-&gt;tag = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d已入队\n&quot;</span>, e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear &amp;&amp; Q-&gt;tag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前队空\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">e = Q-&gt;base[Q-&gt;front];</span><br><span class="line">Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">Q-&gt;tag = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d已出队\n&quot;</span>, e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetHead</span><span class="params">(SqQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear &amp;&amp; Q-&gt;tag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前队空\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前队头元素为%d\n&quot;</span>, Q-&gt;base[Q-&gt;front]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplayQueue</span><span class="params">(SqQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear &amp;&amp; Q-&gt;tag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前队空\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> length = QueueLength(Q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前队列元素从队头到队尾为:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, Q-&gt;base[(Q-&gt;front + i) % MAXSIZE]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyQueue</span><span class="params">(SqQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(Q-&gt;base);</span><br><span class="line">Q-&gt;base = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;队列已销毁！敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Menu();</span><br><span class="line"></span><br><span class="line">SqQueue Q;</span><br><span class="line">InitQueue(&amp;Q);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> choose;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choose);</span><br><span class="line"><span class="keyword">while</span> (choose)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (choose)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前队列的长度为:%d\n&quot;</span>, QueueLength(&amp;Q));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">EnQueue(&amp;Q);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">DeQueue(&amp;Q);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">GetHead(&amp;Q);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">DisplayQueue(&amp;Q);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">DestroyQueue(&amp;Q);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入错误请重新输入\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">getch();</span><br><span class="line">Menu();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choose);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="链队"><a href="#链队" class="headerlink" title="链队"></a>链队</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span><span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode, *QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QueuePtr front;</span><br><span class="line">QueuePtr rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Menu</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue *Q)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue *Q)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue *Q)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GetHead</span><span class="params">(LinkQueue *Q)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplayQueue</span><span class="params">(LinkQueue *Q)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyQueue</span><span class="params">(LinkQueue *Q)</span>;</span><br><span class="line"></span><br><span class="line">QElemType e;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\n\n\n\n&quot;</span>); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|--------------------------------------------主菜单-------------------------------------------|\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|0. 退出程序                                                                                  |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|1. 入队                                                                                      |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|2. 出队                                                                                      |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|3. 取队头元素                                                                                |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|4. 展示队内元素(从队头到队尾)                                                                |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|5. 销毁队列                                                                                  |\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t|---------------------------------------------------------------------------------------------|\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t\t请选择(0-5):&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;front = Q-&gt;rear = (QNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"><span class="keyword">if</span> (!Q-&gt;front)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;分配内存空间失败\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Q-&gt;front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">QNode *p = (QNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要填入的数字:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;e);</span><br><span class="line">p-&gt;data = e;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">Q-&gt;rear-&gt;next = p;</span><br><span class="line">Q-&gt;rear = p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d已入队\n&quot;</span>, e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前队空\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">QNode *p = Q-&gt;front-&gt;next;</span><br><span class="line">e = p-&gt;data;</span><br><span class="line">Q-&gt;front-&gt;next = p-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;rear == p)</span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;rear = Q-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d已出队\n&quot;</span>, e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetHead</span><span class="params">(LinkQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前队空\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前队头元素为%d\n&quot;</span>, Q-&gt;front-&gt;next-&gt;data);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplayQueue</span><span class="params">(LinkQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前队空\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">QNode *p = Q-&gt;front-&gt;next;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前队列元素从队头到队尾为:\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, p-&gt;data);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyQueue</span><span class="params">(LinkQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">QNode *p = Q-&gt;front;</span><br><span class="line">QNode *q = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line">q = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = q;</span><br><span class="line">&#125;</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">q = <span class="literal">NULL</span>;</span><br><span class="line">Q = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;链队已销毁\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;敲击回车返回主菜单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Menu();</span><br><span class="line">    </span><br><span class="line">LinkQueue Q;</span><br><span class="line">InitQueue(&amp;Q);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> choose;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choose);</span><br><span class="line"><span class="keyword">while</span> (choose)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (choose)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">EnQueue(&amp;Q);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">DeQueue(&amp;Q);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">GetHead(&amp;Q);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">DisplayQueue(&amp;Q);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">DestroyQueue(&amp;Q);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入错误请重新输入\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">getch();</span><br><span class="line">Menu();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choose);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="串、数组和广义表"><a href="#串、数组和广义表" class="headerlink" title="串、数组和广义表"></a>串、数组和广义表</h2><h3 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index_BF</span><span class="params">(SString S, SString T, <span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">1</span> || pos &gt; S.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = pos, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.ch[i] == T.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = i - j + <span class="number">2</span>;</span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; T.length)</span><br><span class="line">        <span class="keyword">return</span> i - T.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(SString S, SString T, <span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pos &lt; <span class="number">1</span> || pos &gt; S.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = pos, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> ||S.ch[i] == T.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//j = next[j];</span></span><br><span class="line">        j = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; T.length)</span><br><span class="line">        <span class="keyword">return</span> i - T.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(SString T, <span class="type">int</span> next[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; T.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T.ch[i] == T.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_nextval</span><span class="params">(SString T, <span class="type">int</span> nextval[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; T.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T.ch[i] == T.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span> (T.ch[i] != T.ch[j])</span><br><span class="line">                nextval[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = nextval[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h2><h3 id="二叉树的建立（以链式存储为例）"><a href="#二叉树的建立（以链式存储为例）" class="headerlink" title="二叉树的建立（以链式存储为例）"></a>二叉树的建立（以链式存储为例）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> TElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">TElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line">BiTree <span class="title function_">CreateBiTree</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">T = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">T = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">if</span> (!T)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;分配存储空间失败！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">T-&gt;data = ch;</span><br><span class="line">T-&gt;lchild = CreateBiTree(T-&gt;lchild);</span><br><span class="line">T-&gt;rchild = CreateBiTree(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">BiTree T;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入二叉树中的元素 # 表示空\n&quot;</span>);</span><br><span class="line">BiTree Tree = CreateBiTree(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> TElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">TElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line">BiTree <span class="title function_">CreateBiTree</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">T = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">T = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">if</span> (!T)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;分配存储空间失败！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">T-&gt;data = ch;</span><br><span class="line">T-&gt;lchild = CreateBiTree(T-&gt;lchild);</span><br><span class="line">T-&gt;rchild = CreateBiTree(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintElement</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>,T-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*先序遍历二叉树*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrderTraverse</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (T)</span><br><span class="line">    &#123;</span><br><span class="line">PrintElement(T);</span><br><span class="line">PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中序遍历二叉树*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (T)</span><br><span class="line">    &#123;</span><br><span class="line">PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">        PrintElement(T);</span><br><span class="line">PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*后序遍历二叉树*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LastOrderTraverse</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (T)</span><br><span class="line">    &#123;</span><br><span class="line">PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">        PrintElement(T);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">BiTree T;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入二叉树中的元素 # 表示空\n&quot;</span>);</span><br><span class="line">BiTree Tree = CreateBiTree(T);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;二叉树为:\n&quot;</span>);</span><br><span class="line"><span class="comment">//PreOrderTraverse(Tree);</span></span><br><span class="line">    <span class="comment">//InOrderTraverse(Tree);</span></span><br><span class="line">    LastOrderTraverse(Tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二叉树的相关操作"><a href="#二叉树的相关操作" class="headerlink" title="二叉树的相关操作"></a>二叉树的相关操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> TElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">TElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line">BiTree <span class="title function_">CreateBiTree</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">T = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">T = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">if</span> (!T)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;分配存储空间失败！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">T-&gt;data = ch;</span><br><span class="line">T-&gt;lchild = CreateBiTree(T-&gt;lchild);</span><br><span class="line">T-&gt;rchild = CreateBiTree(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintElement</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>,T-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrderTraverse</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (T)</span><br><span class="line">    &#123;</span><br><span class="line">PrintElement(T);</span><br><span class="line">PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制二叉树</span></span><br><span class="line">BiTree <span class="title function_">CopyBiTree</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        BiTree newT = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        newT-&gt;data = T-&gt;data;</span><br><span class="line">        newT-&gt;lchild = CopyBiTree(T-&gt;lchild);</span><br><span class="line">        newT-&gt;rchild = CopyBiTree(T-&gt;rchild);</span><br><span class="line"><span class="keyword">return</span> newT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算二叉树深度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">TreeDepth</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ldepth;</span><br><span class="line"><span class="type">int</span> rdepth;</span><br><span class="line"><span class="keyword">if</span> (!T)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">ldepth = TreeDepth(T-&gt;lchild);</span><br><span class="line">rdepth = TreeDepth(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> ldepth &gt; rdepth ? ldepth + <span class="number">1</span> : rdepth + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算二叉树的结点个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">NodeCount</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> NodeCount(T-&gt;lchild) + NodeCount(T-&gt;rchild) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">BiTree T;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入二叉树中的元素 # 表示空\n&quot;</span>);</span><br><span class="line">BiTree Tree = CreateBiTree(T);</span><br><span class="line">BiTree newTree = CopyBiTree(Tree);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;二叉树为:\n&quot;</span>);</span><br><span class="line">PreOrderTraverse(newTree);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;二叉树的深度为:%d\n&quot;</span>, TreeDepth(Tree));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;二叉树的节点个数为:%d\n&quot;</span>, NodeCount(Tree));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> TElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> PointerTag;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">PointerTag</span>&#123;</span>Link, Thread&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">TElemType data;            </span><br><span class="line">BiThrNode *lchild;</span><br><span class="line">    BiThrNode *rchild;</span><br><span class="line">PointerTag LTag,RTag;      </span><br><span class="line">&#125;BiThrNode, *BiThrTree; </span><br><span class="line"></span><br><span class="line">BiThrTree <span class="title function_">CreateBiThrTree</span><span class="params">(BiThrTree BT)</span></span><br><span class="line">&#123;</span><br><span class="line">BT = (BiThrNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiThrNode));</span><br><span class="line"><span class="keyword">if</span> (!BT)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;分配存储空间失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">TElemType ch;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line"><span class="keyword">if</span>(ch ==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">BT = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">BT-&gt;data = ch;</span><br><span class="line">BT-&gt;lchild = CreateBiThrTree(BT-&gt;lchild);</span><br><span class="line">BT-&gt;rchild = CreateBiThrTree(BT-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> BT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历进行线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThreading</span><span class="params">(BiThrTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">BiThrTree preT;</span><br><span class="line">preT = (BiThrNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiThrNode));</span><br><span class="line"><span class="keyword">if</span> (T)</span><br><span class="line">    &#123;</span><br><span class="line">InThreading(T-&gt;lchild);</span><br><span class="line"><span class="keyword">if</span> (!T-&gt;lchild)</span><br><span class="line">        &#123;</span><br><span class="line">T-&gt;LTag = Thread;</span><br><span class="line">T-&gt;lchild = preT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!preT-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">T-&gt;RTag = Thread;</span><br><span class="line">preT-&gt;rchild = T;</span><br><span class="line">&#125;</span><br><span class="line">preT = T;</span><br><span class="line">InThreading(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历二叉树并将其线索化</span></span><br><span class="line">BiThrTree <span class="title function_">InOrderThreading</span><span class="params">(BiThrTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">BiThrTree preT;</span><br><span class="line">preT = (BiThrNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiThrNode));</span><br><span class="line">BiThrTree Thr = (BiThrNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiThrNode));</span><br><span class="line"><span class="keyword">if</span> (!Thr)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;分配存储空间失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;   </span><br><span class="line">Thr-&gt;LTag = Link;</span><br><span class="line">Thr-&gt;RTag = Thread;</span><br><span class="line">Thr-&gt;rchild = Thr;</span><br><span class="line"><span class="keyword">if</span> (!T)</span><br><span class="line">        Thr-&gt;lchild = Thr;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">Thr-&gt;lchild = T;</span><br><span class="line">preT = Thr;</span><br><span class="line">InThreading(T);</span><br><span class="line">preT-&gt;rchild = Thr;</span><br><span class="line">preT-&gt;RTag = Thread;</span><br><span class="line">Thr-&gt;rchild = preT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈夫曼树以及哈夫曼编码"><a href="#哈夫曼树以及哈夫曼编码" class="headerlink" title="哈夫曼树以及哈夫曼编码"></a>哈夫曼树以及哈夫曼编码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> DataType; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HTNode</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DataType weight;</span><br><span class="line"><span class="type">int</span> parent;</span><br><span class="line"><span class="type">int</span> lc, rc;</span><br><span class="line">&#125;*HuffmanTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> **HuffmanCode;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Select</span><span class="params">(HuffmanTree&amp; HT, <span class="type">int</span> n, <span class="type">int</span>&amp; s1, <span class="type">int</span>&amp; s2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> min;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (HT[i].parent == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">min = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = min + <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; HT[i].weight &lt; HT[min].weight)</span><br><span class="line">min = i;</span><br><span class="line">&#125;</span><br><span class="line">s1 = min; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; i != s1)</span><br><span class="line">&#123;</span><br><span class="line">min = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = min + <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; HT[i].weight &lt; HT[min].weight&amp;&amp;i != s1)</span><br><span class="line">min = i;</span><br><span class="line">&#125;</span><br><span class="line">s2 = min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateHuff</span><span class="params">(HuffmanTree&amp; HT, DataType* w, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m = <span class="number">2</span> * n - <span class="number">1</span>;</span><br><span class="line">HT = (HuffmanTree)<span class="built_in">calloc</span>(m + <span class="number">1</span>, <span class="keyword">sizeof</span>(HTNode));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">HT[i].weight = w[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = n + <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> s1, s2;</span><br><span class="line">Select(HT, i - <span class="number">1</span>, s1, s2);</span><br><span class="line">HT[i].weight = HT[s1].weight + HT[s2].weight; </span><br><span class="line">HT[s1].parent = i; </span><br><span class="line">HT[s2].parent = i; </span><br><span class="line">HT[i].lc = s1; </span><br><span class="line">HT[i].rc = s2; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;哈夫曼树为:\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;下标\t权值\t父结点\t左孩子\t右孩子\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-4d%-6.2lf%-6d%-6d%-6d\n&quot;</span>, i, HT[i].weight, HT[i].parent, HT[i].lc, HT[i].rc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HuffCoding</span><span class="params">(HuffmanTree&amp; HT, HuffmanCode&amp; HC, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">HC = (HuffmanCode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>*)*(n + <span class="number">1</span>)); </span><br><span class="line"><span class="type">char</span>* code = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*n);</span><br><span class="line">code[n - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> start = n - <span class="number">1</span>; </span><br><span class="line"><span class="type">int</span> c = i; </span><br><span class="line"><span class="type">int</span> p = HT[c].parent; </span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (HT[p].lc == c) </span><br><span class="line">code[--start] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">code[--start] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">c = p; </span><br><span class="line">p = HT[c].parent; </span><br><span class="line">&#125;</span><br><span class="line">HC[i] = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*(n - start)); </span><br><span class="line"><span class="built_in">strcpy</span>(HC[i], &amp;code[start]); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(code); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数据个数:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">DataType* w = (DataType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DataType)*n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数据:&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;w[i]);</span><br><span class="line">&#125;</span><br><span class="line">HuffmanTree HT;</span><br><span class="line">CreateHuff(HT, w, n);</span><br><span class="line">HuffmanCode HC;</span><br><span class="line">HuffCoding(HT, HC, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;数据%.2lf的编码为:%s\n&quot;</span>, HT[i].weight, HC[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><h5 id="无向无权图"><a href="#无向无权图" class="headerlink" title="无向无权图"></a>无向无权图</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXWEIGHT 99999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVERTEX 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VetexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> MatrixType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">AMGraph</span> &#123;</span></span><br><span class="line"><span class="type">char</span> vertex[MAXVERTEX];</span><br><span class="line">MatrixType edge[MAXVERTEX][MAXVERTEX];</span><br><span class="line"><span class="type">int</span> vertices, edges;</span><br><span class="line">&#125; AMGraph;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Locate_vertex</span><span class="params">(AMGraph *G, VetexType v)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Creat_unAMGraph_unweightd</span><span class="params">(AMGraph *G)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the number of vertices:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %d&quot;</span>, &amp;G-&gt;vertices);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the number of edges:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %d&quot;</span>, &amp;G-&gt;edges);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the name of vertices(just like A B C):&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;G-&gt;vertex[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vertices; ++j)</span><br><span class="line">G-&gt;edge[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> v1, v2;</span><br><span class="line"><span class="type">int</span> index_v1, index_v2;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;edges; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the edge(just like A B):&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c %c&quot;</span>, &amp;v1, &amp;v2);</span><br><span class="line">index_v1 = Locate_vertex(G, v1);</span><br><span class="line">index_v2 = Locate_vertex(G, v2);</span><br><span class="line">G-&gt;edge[index_v1][index_v2] = <span class="number">1</span>;</span><br><span class="line">G-&gt;edge[index_v2][index_v1] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Locate_vertex</span><span class="params">(AMGraph *G, VetexType v)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; i++)</span><br><span class="line"><span class="keyword">if</span>(G-&gt;vertex[i] == v)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_Matrix</span><span class="params">(AMGraph *G)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vertices; ++j)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, G-&gt;edge[i][j]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">AMGraph G;</span><br><span class="line">Creat_unAMGraph_unweightd(&amp;G);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;邻接矩阵为：\n&quot;</span>);</span><br><span class="line">print_Matrix(&amp;G);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="无向带权图"><a href="#无向带权图" class="headerlink" title="无向带权图"></a>无向带权图</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXWEIGHT 99999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVERTEX 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VetexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> MatrixType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">AMGraph</span> &#123;</span></span><br><span class="line"><span class="type">char</span> vertex[MAXVERTEX];</span><br><span class="line">MatrixType edge[MAXVERTEX][MAXVERTEX];</span><br><span class="line"><span class="type">int</span> vertices, edges;</span><br><span class="line">&#125; AMGraph;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Locate_vertex</span><span class="params">(AMGraph *G, VetexType v)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Creat_unAMGraph_weightd</span><span class="params">(AMGraph *G)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the number of vertices:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %d&quot;</span>, &amp;G-&gt;vertices);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the number of edges:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %d&quot;</span>, &amp;G-&gt;edges);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the name of vertices(just like A B C):&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;G-&gt;vertex[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i= <span class="number">0</span>; i &lt; G-&gt;vertices; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vertices; ++j)</span><br><span class="line">G-&gt;edge[i][j] = MAXWEIGHT;</span><br><span class="line"><span class="type">char</span> v1, v2;</span><br><span class="line"><span class="type">int</span> index_v1, index_v2;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;edges; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the edge(just like A B 1):&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c %c %d&quot;</span>, &amp;v1, &amp;v2, &amp;weight);</span><br><span class="line">index_v1 = Locate_vertex(G, v1);</span><br><span class="line">index_v2 = Locate_vertex(G, v2);</span><br><span class="line">G-&gt;edge[index_v1][index_v2] = weight;</span><br><span class="line">G-&gt;edge[index_v2][index_v1] = weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Locate_vertex</span><span class="params">(AMGraph *G, VetexType v)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; i++)</span><br><span class="line"><span class="keyword">if</span>(G-&gt;vertex[i] == v)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_Matrix</span><span class="params">(AMGraph *G)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vertices; ++j)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, G-&gt;edge[i][j]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">AMGraph G;</span><br><span class="line">Creat_unAMGraph_weightd(&amp;G);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;邻接矩阵为：\n&quot;</span>);</span><br><span class="line">print_Matrix(&amp;G);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="有向无权图"><a href="#有向无权图" class="headerlink" title="有向无权图"></a>有向无权图</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXWEIGHT 99999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVERTEX 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VetexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> MatrixType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">AMGraph</span> &#123;</span></span><br><span class="line"><span class="type">char</span> vertex[MAXVERTEX];</span><br><span class="line">MatrixType edge[MAXVERTEX][MAXVERTEX];</span><br><span class="line"><span class="type">int</span> vertices, edges;</span><br><span class="line">&#125; AMGraph;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Locate_vertex</span><span class="params">(AMGraph *G, VetexType v)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Creat_AMGraph_unweightd</span><span class="params">(AMGraph *G)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the number of vertices:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %d&quot;</span>, &amp;G-&gt;vertices);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the number of edges:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %d&quot;</span>, &amp;G-&gt;edges);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the name of vertices(just like A B C):&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;G-&gt;vertex[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vertices; ++j)</span><br><span class="line">G-&gt;edge[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> v1, v2; </span><br><span class="line"><span class="type">int</span> index_v1, index_v2;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;edges; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the edge(just like A B):&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c %c&quot;</span>, &amp;v1, &amp;v2);</span><br><span class="line">index_v1 = Locate_vertex(G, v1);</span><br><span class="line">index_v2 = Locate_vertex(G, v2);</span><br><span class="line">G-&gt;edge[index_v1][index_v2] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Locate_vertex</span><span class="params">(AMGraph *G, VetexType v)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; i++)</span><br><span class="line"><span class="keyword">if</span>(G-&gt;vertex[i] == v)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_Matrix</span><span class="params">(AMGraph *G)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vertices; ++j)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, G-&gt;edge[i][j]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">AMGraph G;</span><br><span class="line">Creat_AMGraph_unweightd(&amp;G);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;邻接矩阵为：\n&quot;</span>);</span><br><span class="line">print_Matrix(&amp;G);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="有向带权图"><a href="#有向带权图" class="headerlink" title="有向带权图"></a>有向带权图</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXWEIGHT 99999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVERTEX 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VetexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> MatrixType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">AMGraph</span> &#123;</span></span><br><span class="line"><span class="type">char</span> vertex[MAXVERTEX];</span><br><span class="line">MatrixType edge[MAXVERTEX][MAXVERTEX];</span><br><span class="line"><span class="type">int</span> vertices, edges;</span><br><span class="line">&#125; AMGraph;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Locate_vertex</span><span class="params">(AMGraph *G, VetexType v)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Creat_AMGraph_weightd</span><span class="params">(AMGraph *G)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the number of vertices:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %d&quot;</span>, &amp;G-&gt;vertices);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the number of edges:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %d&quot;</span>, &amp;G-&gt;edges);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the name of vertices(just like A B C):&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;G-&gt;vertex[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vertices; ++j)</span><br><span class="line">G-&gt;edge[i][j] = MAXWEIGHT;</span><br><span class="line"><span class="type">char</span> v1, v2;</span><br><span class="line"><span class="type">int</span> index_v1, index_v2;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;edges; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the edge(just like A B 1):&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c %c %d&quot;</span>, &amp;v1, &amp;v2, &amp;weight);</span><br><span class="line">index_v1 = Locate_vertex(G, v1);</span><br><span class="line">index_v2 = Locate_vertex(G, v2);</span><br><span class="line">G-&gt;edge[index_v1][index_v2] = weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Locate_vertex</span><span class="params">(AMGraph *G, VetexType v)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; i++)</span><br><span class="line"><span class="keyword">if</span>(G-&gt;vertex[i] == v)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_Matrix</span><span class="params">(AMGraph *G)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vertices; ++j)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, G-&gt;edge[i][j]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">AMGraph G;</span><br><span class="line">Creat_AMGraph_weightd(&amp;G);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;邻接矩阵为：\n&quot;</span>);</span><br><span class="line">print_Matrix(&amp;G);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接表（只以无向无权为例）"><a href="#邻接表（只以无向无权为例）" class="headerlink" title="邻接表（只以无向无权为例）"></a>邻接表（只以无向无权为例）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVERTEX 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> MatrixType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> &#123;</span></span><br><span class="line"><span class="type">int</span> adjvertex;</span><br><span class="line">EdgeNode *next;</span><br><span class="line">&#125;EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ALGNode</span> &#123;</span></span><br><span class="line">VertexType name;</span><br><span class="line">EdgeNode *first;</span><br><span class="line">&#125;ALGNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ALGraph</span> &#123;</span></span><br><span class="line">ALGNode vertex[MAXVERTEX];</span><br><span class="line"><span class="type">int</span> edges, vertices;</span><br><span class="line">&#125;ALGraph;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Locate_vertex</span><span class="params">(ALGraph *G, VertexType v)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Creat_unALGraph_unweighted</span><span class="params">(ALGraph *G)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the number of vertices:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %d&quot;</span>, &amp;G-&gt;vertices);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the number of edges:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %d&quot;</span>, &amp;G-&gt;edges);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the name of vertices(just like A B C):&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;G-&gt;vertex[i].name);</span><br><span class="line">G-&gt;vertex[i].first = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> v1, v2;</span><br><span class="line"><span class="type">int</span> index_v1, index_v2;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;edges; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the edge(just like A B):&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c %c&quot;</span>, &amp;v1, &amp;v2);</span><br><span class="line">index_v1 = Locate_vertex(G, v1);</span><br><span class="line">index_v2 = Locate_vertex(G, v2);</span><br><span class="line">EdgeNode *pnew1 = (EdgeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));</span><br><span class="line">pnew1-&gt;adjvertex = index_v2;</span><br><span class="line">pnew1-&gt;next = G-&gt;vertex[index_v1].first;</span><br><span class="line">G-&gt;vertex[index_v1].first = pnew1;</span><br><span class="line">EdgeNode *pnew2 = (EdgeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));</span><br><span class="line">pnew2-&gt;adjvertex = index_v1;</span><br><span class="line">pnew2-&gt;next = G-&gt;vertex[index_v2].first;</span><br><span class="line">G-&gt;vertex[index_v2].first = pnew2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Locate_vertex</span><span class="params">(ALGraph *G, VertexType v)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i)</span><br><span class="line"><span class="keyword">if</span>(G-&gt;vertex[i].name == v)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_ALG_unweighted</span><span class="params">(ALGraph *G)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c:&quot;</span>, G-&gt;vertex[i].name);</span><br><span class="line">EdgeNode *p = G-&gt;vertex[i].first;</span><br><span class="line"><span class="keyword">if</span> (p) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, p-&gt;adjvertex);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">ALGraph G;</span><br><span class="line">Creat_unALGraph_unweighted(&amp;G);</span><br><span class="line">print_ALG_unweighted(&amp;G);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><h5 id="遍历矩阵"><a href="#遍历矩阵" class="headerlink" title="遍历矩阵"></a>遍历矩阵</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DFS_AM</span><span class="params">(AMGraph *G, <span class="type">int</span> v, <span class="type">bool</span> *visit)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, G-&gt;vertex[v]);</span><br><span class="line">visit[v] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G-&gt;vertices; ++k) &#123;</span><br><span class="line"><span class="keyword">if</span> (G-&gt;edge[v][k] &amp;&amp; !visit[k]) </span><br><span class="line">DFS_AM(G, k, visit);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS_AMGraph</span><span class="params">(AMGraph *G, VertexType v)</span> &#123; </span><br><span class="line">    <span class="type">bool</span> *visit = (<span class="type">bool</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>) * G-&gt;vertices); </span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="literal">false</span>, <span class="keyword">sizeof</span>(<span class="type">bool</span>) * G-&gt;vertices); </span><br><span class="line">    <span class="type">int</span> index = Locate_vertex(G, v); </span><br><span class="line">    DFS_AM(G, index, visit);</span><br><span class="line">    <span class="built_in">free</span>(visit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遍历邻接表"><a href="#遍历邻接表" class="headerlink" title="遍历邻接表"></a>遍历邻接表</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DFS_AL</span><span class="params">(ALGraph *G, <span class="type">int</span> v, <span class="type">bool</span> *visit)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, G-&gt;vertex[v].name);</span><br><span class="line">visit[v] = <span class="literal">true</span>;</span><br><span class="line">EdgeNode *p = G-&gt;vertex[v].first;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="type">int</span> adj = p-&gt;adjvertex;</span><br><span class="line"><span class="keyword">if</span> (!visit[adj]) </span><br><span class="line">    DFS_AL(G, adj, visit);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS_ALGraph</span><span class="params">(ALGraph *G, VertexType v)</span> &#123; </span><br><span class="line">    <span class="type">bool</span> *visit = (<span class="type">bool</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>) * G-&gt;vertices);</span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="literal">false</span>, <span class="keyword">sizeof</span>(<span class="type">bool</span>) * G-&gt;vertices);</span><br><span class="line">    <span class="type">int</span> index = Locate_vertex(G, v);</span><br><span class="line">    DFS_AL(G, index, visit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><h5 id="遍历矩阵-1"><a href="#遍历矩阵-1" class="headerlink" title="遍历矩阵"></a>遍历矩阵</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BFS_AM</span><span class="params">(AMGraph *G, <span class="type">int</span> v, <span class="type">bool</span> *visit)</span> &#123;</span><br><span class="line">    SqQueue Q;</span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line">    EntryQ(&amp;Q, v);</span><br><span class="line">    visit[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> pop;</span><br><span class="line">    <span class="keyword">while</span> (!IsEmpty(&amp;Q)) &#123;</span><br><span class="line">        OutQ(&amp;Q, &amp;pop);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, G-&gt;vertex[pop]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G-&gt;vertices; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (G-&gt;edge[pop][k] &amp;&amp; !visit[k]) &#123;</span><br><span class="line">                EntryQ(&amp;Q, k);</span><br><span class="line">                visit[k] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS_AMGraph</span><span class="params">(AMGraph *G, VertexType v)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> *visit = (<span class="type">bool</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>) * G-&gt;vertices); </span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="literal">false</span>, <span class="keyword">sizeof</span>(<span class="type">bool</span>) * G-&gt;vertices);</span><br><span class="line">    <span class="type">int</span> index = Locate_vertex(G, v); </span><br><span class="line">    BFS_AM(G, index, visit);</span><br><span class="line">    <span class="built_in">free</span>(visit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遍历邻接表-1"><a href="#遍历邻接表-1" class="headerlink" title="遍历邻接表"></a>遍历邻接表</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BFS_AL</span><span class="params">(ALGraph *G, <span class="type">int</span> v, <span class="type">bool</span> *visit)</span> &#123;</span><br><span class="line">    SqQueue Q;</span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line">    EdgeNode *p;</span><br><span class="line">    EntryQ(&amp;Q, v);</span><br><span class="line">    visit[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> pop;</span><br><span class="line">    <span class="keyword">while</span> (!IsEmpty(&amp;Q)) &#123;</span><br><span class="line">    OutQ(&amp;Q, &amp;pop);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, G-&gt;vertex[pop].name);</span><br><span class="line">    p = G-&gt;vertex[pop].first;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!visit[p-&gt;adjvertex]) &#123; </span><br><span class="line">    EntryQ(&amp;Q, p-&gt;adjvertex);</span><br><span class="line">    visit[p-&gt;adjvertex] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS_ALGraph</span><span class="params">(ALGraph *G, VertexType v)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> *visit = (<span class="type">bool</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>) * G-&gt;vertices); </span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="literal">false</span>, <span class="keyword">sizeof</span>(<span class="type">bool</span>) * G-&gt;vertices);</span><br><span class="line">    <span class="type">int</span> index = Locate_vertex(G, v); </span><br><span class="line">    BFS_AL(G, index, visit); </span><br><span class="line"><span class="built_in">free</span>(visit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><h4 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h4><h5 id="邻接矩阵-1"><a href="#邻接矩阵-1" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Uset</span> &#123;</span></span><br><span class="line"><span class="type">int</span> adjvertex;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Min_Uset</span><span class="params">(Uset *U, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="type">int</span> min = INT_MAX;</span><br><span class="line"><span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (U[i].weight != <span class="number">0</span> &amp;&amp; U[i].weight &lt; min) &#123;</span><br><span class="line">min = U[i].weight;</span><br><span class="line">pos = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MST_Prim</span><span class="params">(AMGraph *G, VertexType v)</span> &#123;</span><br><span class="line"><span class="type">int</span> u = Locate_vertex(G, v);</span><br><span class="line">Uset *U = (Uset *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Uset) * G-&gt;vertices);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i) &#123;</span><br><span class="line">U[i].adjvertex = u;</span><br><span class="line">U[i].weight = G-&gt;edge[u][i];</span><br><span class="line">&#125;</span><br><span class="line">U[u].weight = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; G-&gt;vertices; ++i) &#123; </span><br><span class="line"><span class="type">int</span> min = Min_Uset(U, G-&gt;vertices); </span><br><span class="line"><span class="type">int</span> u_0 = U[min].adjvertex; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c-&gt;%c &quot;</span>, G-&gt;vertex[u_0], G-&gt;vertex[min]); </span><br><span class="line">U[min].weight = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vertices; ++j) &#123; </span><br><span class="line"><span class="keyword">if</span> (G-&gt;edge[min][j] &lt; U[j].weight) &#123;</span><br><span class="line">U[j].weight = G-&gt;edge[min][j];</span><br><span class="line">U[j].adjvertex = min;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(U);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Uset</span> &#123;</span></span><br><span class="line"><span class="type">int</span> adjvertex;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Min_Uset</span><span class="params">(Uset *U, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="type">int</span> min = INT_MAX;</span><br><span class="line"><span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (U[i].weight != <span class="number">0</span> &amp;&amp; U[i].weight &lt; min) &#123;</span><br><span class="line">min = U[i].weight;</span><br><span class="line">pos = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MST_Prime</span><span class="params">(ALGraph *G, VertexType v)</span> &#123;</span><br><span class="line"><span class="type">int</span> u = Locate_vertex(G, v);</span><br><span class="line">Uset *U = (Uset *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Uset) * G-&gt;vertices);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i) &#123;</span><br><span class="line">U[i].weight = MAXWEIGHT;</span><br><span class="line">U[i].adjvertex = u;</span><br><span class="line">&#125;</span><br><span class="line">U[u].weight = <span class="number">0</span>;</span><br><span class="line">EdgeNode *p = G-&gt;vertex[u].first;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line">U[p-&gt;adjvertex].weight = p-&gt;weight;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; G-&gt;vertices; ++i) &#123;</span><br><span class="line"><span class="type">int</span> min = Min_Uset(U, G-&gt;vertices);</span><br><span class="line"><span class="type">int</span> u_0 = U[min].adjvertex;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c-&gt;%c &quot;</span>, G-&gt;vertex[u_0].name, G-&gt;vertex[min].name);</span><br><span class="line">U[min].weight = <span class="number">0</span>;</span><br><span class="line">EdgeNode *p_min = G-&gt;vertex[min].first;</span><br><span class="line"><span class="keyword">while</span> (p_min) &#123;</span><br><span class="line"><span class="keyword">if</span> (p_min-&gt;weight &lt; U[p_min-&gt;adjvertex].weight) &#123;</span><br><span class="line">U[p_min-&gt;adjvertex].adjvertex = min;</span><br><span class="line">U[p_min-&gt;adjvertex].weight = p_min-&gt;weight;</span><br><span class="line">&#125;</span><br><span class="line">p_min = p_min-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(U);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h4><h5 id="邻接矩阵-2"><a href="#邻接矩阵-2" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Eset</span> &#123;</span></span><br><span class="line"><span class="type">int</span> start;</span><br><span class="line"><span class="type">int</span> end;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort_Eset</span><span class="params">(Eset *E, <span class="type">int</span> length)</span> &#123;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span> &amp;&amp; flag; ++i) &#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (E[j].weight &gt; E[j + <span class="number">1</span>].weight) &#123;</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line">Eset temp = E[j];</span><br><span class="line">E[j] = E[j + <span class="number">1</span>];</span><br><span class="line">E[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitEset</span><span class="params">(Eset *E, AMGraph *G)</span> &#123;</span><br><span class="line">Eset *p = E;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; G-&gt;vertices; ++k) &#123; </span><br><span class="line"><span class="keyword">if</span> (G-&gt;edge[i][k] &lt; MAXWEIGHT) &#123; </span><br><span class="line">(p)-&gt;start = i;</span><br><span class="line">(p)-&gt;end = k;</span><br><span class="line">(p)-&gt;weight = G-&gt;edge[i][k];</span><br><span class="line">++p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MST_Krusal</span><span class="params">(AMGraph *G)</span> &#123;</span><br><span class="line">Eset *E = (Eset *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Eset) * G-&gt;edges);</span><br><span class="line">InitEset(E, G);</span><br><span class="line">Sort_Eset(E, G-&gt;edges);</span><br><span class="line"><span class="type">int</span> V[G-&gt;vertices];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i)</span><br><span class="line">V[i] = i; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;edges; ++j) &#123;</span><br><span class="line"><span class="type">int</span> v_1 = E[j].start; </span><br><span class="line"><span class="type">int</span> v_2 = E[j].end;</span><br><span class="line"><span class="type">int</span> component_v_1 = V[v_1];</span><br><span class="line"><span class="type">int</span> component_v_2 = V[v_2];</span><br><span class="line"><span class="keyword">if</span> (component_v_1 != component_v_2) &#123; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c-&gt;%c &quot;</span>, G-&gt;vertex[v_1], G-&gt;vertex[v_2]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G-&gt;vertices; ++k) &#123;</span><br><span class="line"><span class="keyword">if</span> (V[k] == component_v_2)</span><br><span class="line">V[k] = component_v_1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(E);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="邻接表-1"><a href="#邻接表-1" class="headerlink" title="邻接表"></a>邻接表</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Eset</span> &#123;</span></span><br><span class="line"><span class="type">int</span> start;</span><br><span class="line"><span class="type">int</span> end;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort_Eset</span><span class="params">(Eset *E, <span class="type">int</span> length)</span> &#123;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span> &amp;&amp; flag; ++i) &#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (E[j].weight &gt; E[j + <span class="number">1</span>].weight) &#123;</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line">Eset temp = E[j];</span><br><span class="line">E[j] = E[j + <span class="number">1</span>];</span><br><span class="line">E[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitEset</span><span class="params">(Eset *E, ALGraph *G)</span> &#123;</span><br><span class="line">Eset *p_E = E;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i) &#123;</span><br><span class="line">EdgeNode *p = G-&gt;vertex[i].first;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line">p_E-&gt;start = i;</span><br><span class="line">p_E-&gt;end = p-&gt;adjvertex;</span><br><span class="line">p_E-&gt;weight = p-&gt;weight;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">++p_E;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p_E = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MST_Krusal</span><span class="params">(ALGraph *G)</span> &#123;</span><br><span class="line">Eset *E = (Eset *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Eset) * G-&gt;edges);</span><br><span class="line">InitEset(E, G);</span><br><span class="line">Sort_Eset(E, G-&gt;edges);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>; w &lt; G-&gt;edges; ++w) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(%d)start=%d, end=%d,weight=%d\n&quot;</span>, w, E[w].start, E[w].end,</span><br><span class="line">E[w].weight);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> V[G-&gt;vertices];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i)</span><br><span class="line">V[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;edges; ++j) &#123;</span><br><span class="line"><span class="type">int</span> v_1 = E[j].start;</span><br><span class="line"><span class="type">int</span> v_2 = E[j].end;</span><br><span class="line"><span class="type">int</span> component_v_1 = V[v_1];</span><br><span class="line"><span class="type">int</span> component_v_2 = V[v_2];</span><br><span class="line"><span class="keyword">if</span> (component_v_1 != component_v_2) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c-&gt;%c &quot;</span>, G-&gt;vertex[v_1].name, G-&gt;vertex[v_2].name);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G-&gt;vertices; ++k) &#123;</span><br><span class="line"><span class="keyword">if</span> (component_v_2 == V[k])</span><br><span class="line">V[k] = component_v_1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(E);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h4><h5 id="邻接矩阵-3"><a href="#邻接矩阵-3" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShortestPath</span><span class="params">(AMGraph *G, <span class="type">int</span> v, <span class="type">int</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> D[G-&gt;vertices];</span><br><span class="line">    <span class="type">bool</span> S[G-&gt;vertices];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        D[i] = G-&gt;edge[v][i];</span><br><span class="line">        S[i] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (D[i] &lt; MAXWEIGHT)</span><br><span class="line">            path[i] = v;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            path[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    S[v] = <span class="literal">true</span>;</span><br><span class="line">    D[v] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; G-&gt;vertices; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> min_index;</span><br><span class="line">        <span class="type">int</span> min = MAXWEIGHT;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vertices; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!S[j] &amp;&amp; D[j] &lt; min)</span><br><span class="line">            &#123;</span><br><span class="line">                min_index = j;</span><br><span class="line">                min = D[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        S[min_index] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G-&gt;vertices; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!S[k] &amp;&amp; (G-&gt;edge[min_index][k] + D[min_index] &lt; D[k]))</span><br><span class="line">            &#123;</span><br><span class="line">                D[k] = G-&gt;edge[min_index][k] + D[min_index];</span><br><span class="line">                path[k] = min_index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShortestPath_Dijkstra</span><span class="params">(AMGraph *G, VertexType v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v_index = Locate_vertex(G, v);</span><br><span class="line">    <span class="type">int</span> *path = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * G-&gt;vertices);</span><br><span class="line">    ShortestPath(G, v_index, path);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != v_index)</span><br><span class="line">        &#123;</span><br><span class="line">            print_path(G, path, v_index, i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_path</span><span class="params">(AMGraph *G, <span class="type">int</span> *path, <span class="type">int</span> start, <span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    InitStack(&amp;S);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c-&gt;&quot;</span>, G-&gt;vertex[start]);</span><br><span class="line">    Push(&amp;S, end);</span><br><span class="line">    <span class="type">int</span> flag = end;</span><br><span class="line">    end = path[end];</span><br><span class="line">    <span class="keyword">while</span> (end != start)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(&amp;S, end);</span><br><span class="line">        end = path[end];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> head = start;</span><br><span class="line">    <span class="type">int</span> pop;</span><br><span class="line">    <span class="keyword">while</span> (!IsEmpty(&amp;S))</span><br><span class="line">    &#123;</span><br><span class="line">        Pop(&amp;S, &amp;pop);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c(%d)&quot;</span>, G-&gt;vertex[pop], G-&gt;edge[head][pop]);</span><br><span class="line">        <span class="keyword">if</span> (pop != flag)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        head = pop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h4><h5 id="邻接矩阵-4"><a href="#邻接矩阵-4" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> **<span class="title function_">Path_Matrix</span><span class="params">(AMGraph *G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = G-&gt;vertices;</span><br><span class="line">    <span class="type">int</span> **path = (<span class="type">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span> *) * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i)</span><br><span class="line">        path[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">    <span class="type">int</span> D[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            D[i][j] = G-&gt;edge[i][j];</span><br><span class="line">            <span class="keyword">if</span> (D[i][j] &lt; MAXWEIGHT)</span><br><span class="line">                path[i][j] = i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                path[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (D[i][k] + D[k][j] &lt; D[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    D[i][j] = D[i][k] + D[k][j];</span><br><span class="line">                    path[i][j] = path[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShortestPath_Floyd</span><span class="params">(AMGraph *G, VertexType v1, VertexType v2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> start = Locate_vertex(G, v1);</span><br><span class="line">    <span class="type">int</span> end = Locate_vertex(G, v2);</span><br><span class="line">    <span class="type">int</span> **path = Path_Matrix(G);</span><br><span class="line">    SqStack S;</span><br><span class="line">    InitStack(&amp;S);</span><br><span class="line">    Push(&amp;S, end);</span><br><span class="line">    <span class="type">int</span> prior = path[start][end];</span><br><span class="line">    <span class="keyword">while</span> (prior != start)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(&amp;S, prior);</span><br><span class="line">        prior = path[start][prior];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> head = start;</span><br><span class="line">    <span class="type">int</span> pop;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c-&gt;&quot;</span>, G-&gt;vertex[start]);</span><br><span class="line">    <span class="keyword">while</span> (!IsEmpty(&amp;S))</span><br><span class="line">    &#123;</span><br><span class="line">        Pop(&amp;S, &amp;pop);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c(%d)&quot;</span>, G-&gt;vertex[pop], G-&gt;edge[head][pop]);</span><br><span class="line">        <span class="keyword">if</span> (pop != end)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        head = pop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i)</span><br><span class="line">        <span class="built_in">free</span>(path[i]);</span><br><span class="line">    <span class="built_in">free</span>(path);</span><br><span class="line">    path = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><h4 id="邻接表-2"><a href="#邻接表-2" class="headerlink" title="邻接表"></a>邻接表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InDegree</span><span class="params">(ALGraph *G, <span class="type">int</span> *a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        EdgeNode *p = G-&gt;vertex[i].first;</span><br><span class="line">        <span class="keyword">while</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            ++a[p-&gt;adjvertex];</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">Get_Topo</span><span class="params">(ALGraph *G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *indegree = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * G-&gt;vertices);</span><br><span class="line">    <span class="built_in">memset</span>(indegree, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * G-&gt;vertices); </span><br><span class="line">    <span class="type">int</span> *topo = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * G-&gt;vertices);</span><br><span class="line">    <span class="built_in">memset</span>(topo, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * G-&gt;vertices);</span><br><span class="line">    InDegree(G, indegree); </span><br><span class="line">    SqStack S;</span><br><span class="line">    InitStack(&amp;S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!indegree[i]) </span><br><span class="line">            Push(&amp;S, i);</span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pop; </span><br><span class="line">    <span class="keyword">while</span> (!IsEmpty(&amp;S))</span><br><span class="line">    &#123;</span><br><span class="line">        Pop(&amp;S, &amp;pop);  </span><br><span class="line">        topo[m++] = pop; </span><br><span class="line">        EdgeNode *p = G-&gt;vertex[pop].first;</span><br><span class="line">        <span class="keyword">while</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            --indegree[p-&gt;adjvertex];</span><br><span class="line">            <span class="keyword">if</span> (!indegree[p-&gt;adjvertex]) </span><br><span class="line">                Push(&amp;S, p-&gt;adjvertex);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; G-&gt;vertices)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(indegree);</span><br><span class="line">        <span class="built_in">free</span>(topo);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(indegree);</span><br><span class="line">        <span class="keyword">return</span> topo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TopoSort</span><span class="params">(ALGraph *G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *topo = Get_Topo(G);</span><br><span class="line">    <span class="keyword">if</span> (!topo)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The Graph is not AVO!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertices; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, G-&gt;vertex[topo[i]].name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(topo);</span><br><span class="line">    topo = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><h4 id="邻接表-3"><a href="#邻接表-3" class="headerlink" title="邻接表"></a>邻接表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CriticalPath</span><span class="params">(ALGraph *G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *topo = Get_Topo(G);</span><br><span class="line">    <span class="keyword">if</span> (!topo)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The Graph is not AVO&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n = G-&gt;vertices;</span><br><span class="line">    <span class="type">int</span> ve[n], vl[n];               </span><br><span class="line">    <span class="built_in">memset</span>(ve, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * n); </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = topo[i];</span><br><span class="line">        EdgeNode *p = G-&gt;vertex[k].first;</span><br><span class="line">        <span class="keyword">while</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ve[p-&gt;adjvertex] &lt; ve[k] + p-&gt;weight) </span><br><span class="line">                ve[p-&gt;adjvertex] = ve[k] + p-&gt;weight;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        vl[i] = ve[topo[n - <span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = topo[i];</span><br><span class="line">        EdgeNode *p = G-&gt;vertex[k].first;</span><br><span class="line">        <span class="keyword">while</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (vl[k] &gt; vl[p-&gt;adjvertex] - p-&gt;weight)</span><br><span class="line">                vl[k] = vl[p-&gt;adjvertex] - p-&gt;weight; </span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        EdgeNode *p = G-&gt;vertex[i].first;</span><br><span class="line">        <span class="keyword">while</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = p-&gt;adjvertex;</span><br><span class="line">            <span class="type">int</span> e = ve[i]; </span><br><span class="line">            <span class="type">int</span> l = vl[j] - p-&gt;weight;</span><br><span class="line">            <span class="keyword">if</span> (e == l) </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c-&gt;%c &quot;</span>, G-&gt;vertex[i].name, G-&gt;vertex[j].name);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(topo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="线性表-1"><a href="#线性表-1" class="headerlink" title="线性表"></a>线性表</h3><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SSTable_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SSTable_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXBLOCK 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *OtherInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KeyType key;</span><br><span class="line">    OtherInfo other;</span><br><span class="line">&#125; SSTElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SSTElemType *base;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125; SSTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KeyType MaxKey;</span><br><span class="line">    <span class="type">int</span> start, end;</span><br><span class="line">&#125; IndexElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">IndexTbale</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    IndexElemType index[MAXBLOCK];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125; IndexTable;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sequential_search.cpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Binary _search.cpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Blocked_Search.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Search_SS</span><span class="params">(SSTable ST, KeyType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    ST.base[<span class="number">0</span>].key = key;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = ST.length; ST.base[i].key != key; i--)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Search_BS</span><span class="params">(SSTable ST, KeyType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = ST.length;</span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == ST.base[mid].key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; ST.base[mid].key)</span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SSTable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">IndexTable INDEXTABLE;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BlockSearch</span><span class="params">(KeyType *a, KeyType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = INDEXTABLE.length;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &lt;=</span><br><span class="line">            INDEXTABLE.index[mid].MaxKey)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (key &gt;</span><br><span class="line">                INDEXTABLE.index[mid - <span class="number">1</span>].MaxKey)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = INDEXTABLE.index[mid].start;</span><br><span class="line">                     i &lt;= INDEXTABLE.index[mid].end; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (key == a[i])</span><br><span class="line">                        <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    KeyType a[<span class="number">19</span>] = &#123;<span class="number">0</span>, <span class="number">22</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">33</span>, <span class="number">42</span>, <span class="number">44</span>,</span><br><span class="line">                     <span class="number">38</span>, <span class="number">24</span>, <span class="number">48</span>, <span class="number">60</span>, <span class="number">58</span>, <span class="number">74</span>, <span class="number">49</span>, <span class="number">86</span>, <span class="number">53</span>&#125;;</span><br><span class="line">    INDEXTABLE.length = <span class="number">3</span>;</span><br><span class="line">    INDEXTABLE.index[<span class="number">1</span>].start = <span class="number">1</span>, INDEXTABLE.index[<span class="number">1</span>].end = <span class="number">6</span>,</span><br><span class="line">    INDEXTABLE.index[<span class="number">1</span>].MaxKey = <span class="number">22</span>;</span><br><span class="line">    INDEXTABLE.index[<span class="number">2</span>].start = <span class="number">7</span>, INDEXTABLE.index[<span class="number">2</span>].end = <span class="number">12</span>,</span><br><span class="line">    INDEXTABLE.index[<span class="number">2</span>].MaxKey = <span class="number">48</span>;</span><br><span class="line">    INDEXTABLE.index[<span class="number">3</span>].start = <span class="number">13</span>, INDEXTABLE.index[<span class="number">3</span>].end = <span class="number">18</span>,</span><br><span class="line">    INDEXTABLE.index[<span class="number">3</span>].MaxKey = <span class="number">86</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, BlockSearch(a, <span class="number">86</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树表"><a href="#树表" class="headerlink" title="树表"></a>树表</h3><h4 id="头文件-1"><a href="#头文件-1" class="headerlink" title="头文件"></a>头文件</h4><h5 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _BSTree_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BSTree_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENDFLAG 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> BSTKeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *BSTOtherInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">BSTElemType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    BSTKeyType key;</span><br><span class="line">    BSTOtherInfo other;</span><br><span class="line">&#125; BSTElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">BSTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    BSTElemType data;</span><br><span class="line">    __BSTNode *lchild, *rchild;</span><br><span class="line">&#125; BSTNode, *BSTree;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Binary_Sort_Tree.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h5 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _AVLTree_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _AVLTree_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LH 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EH 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RH -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> AVLElemtype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">AVLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AVLElemtype key;</span><br><span class="line">    <span class="type">int</span> bf;</span><br><span class="line">    __AVLNode *lchild, *rchild;</span><br><span class="line">&#125; AVLNode, *AVLTree;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Balance_Binary_Tree.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="二叉排序树-1"><a href="#二叉排序树-1" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">BSTree <span class="title function_">Search_BST</span><span class="params">(BSTree T, BSTKeyType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(T) || key == T-&gt;data.key)</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;data.key)</span><br><span class="line">        <span class="keyword">return</span> Search_BST(T-&gt;lchild, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Search_BST(T-&gt;rchild, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert_BST</span><span class="params">(BSTree *T, BSTKeyType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == *T)</span><br><span class="line">    &#123;</span><br><span class="line">        *T = (BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">        (*T)-&gt;data.key = e;</span><br><span class="line">        (*T)-&gt;lchild = (*T)-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e &lt; (*T)-&gt;data.key)</span><br><span class="line">    &#123;</span><br><span class="line">        Insert_BST(&amp;((*T)-&gt;lchild), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e &gt; (*T)-&gt;data.key)</span><br><span class="line">    &#123;</span><br><span class="line">        Insert_BST(&amp;((*T)-&gt;rchild), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Creat_BST</span><span class="params">(BSTree *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    *T = <span class="literal">NULL</span>;</span><br><span class="line">    BSTKeyType key;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot; %d&quot;</span>, &amp;key);</span><br><span class="line">    <span class="keyword">while</span> (key != ENDFLAG)</span><br><span class="line">    &#123;</span><br><span class="line">        Insert_BST(T, key);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot; %d&quot;</span>, &amp;key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delete_BST</span><span class="params">(BSTree *T, BSTKeyType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    BSTree p = *T;</span><br><span class="line">    BSTree parent = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data.key == key)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; p-&gt;data.key)</span><br><span class="line">        &#123;</span><br><span class="line">            parent = p;</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            parent = p;</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BSTree pfree;</span><br><span class="line">    BSTree node;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;lchild &amp;&amp; p-&gt;rchild)</span><br><span class="line">    &#123;</span><br><span class="line">        BSTree prior = p-&gt;lchild;</span><br><span class="line">        BSTree parent_prior = p;</span><br><span class="line">        <span class="keyword">while</span> (prior-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            parent_prior = prior;</span><br><span class="line">            prior = prior-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data.key = prior-&gt;data.key;</span><br><span class="line">        <span class="keyword">if</span> (parent_prior != p)</span><br><span class="line">        &#123;</span><br><span class="line">            parent_prior-&gt;rchild = prior-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            parent_prior-&gt;lchild = prior-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(prior);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!p-&gt;lchild)</span><br><span class="line">    &#123;</span><br><span class="line">        pfree = p;</span><br><span class="line">        node = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!p-&gt;rchild)</span><br><span class="line">    &#123;</span><br><span class="line">        pfree = p;</span><br><span class="line">        node = p-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!parent)</span><br><span class="line">    &#123;</span><br><span class="line">        *T = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;rchild == p)</span><br><span class="line">    &#123;</span><br><span class="line">        parent-&gt;rchild = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        parent-&gt;lchild = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pfree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="平衡二叉树-1"><a href="#平衡二叉树-1" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LeftRotate</span><span class="params">(AVLTree *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    AVLTree Rchild = (*T)-&gt;rchild;</span><br><span class="line">    (*T)-&gt;rchild = Rchild-&gt;lchild;</span><br><span class="line">    Rchild-&gt;lchild = *T;</span><br><span class="line">    *T = Rchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RightRotate</span><span class="params">(AVLTree *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    AVLTree Lchild = (*T)-&gt;lchild;</span><br><span class="line">    (*T)-&gt;lchild = Lchild-&gt;rchild;</span><br><span class="line">    Lchild-&gt;rchild = *T;</span><br><span class="line">    *T = Lchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LeftBalance</span><span class="params">(AVLTree *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    AVLTree L = (*T)-&gt;lchild;</span><br><span class="line">    AVLTree Lr;</span><br><span class="line">    <span class="keyword">switch</span> (L-&gt;bf)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> LH:</span><br><span class="line">        (*T)-&gt;bf = L-&gt;bf = EH;</span><br><span class="line">        RightRotate(T);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RH:</span><br><span class="line">        Lr = L-&gt;rchild;</span><br><span class="line">        <span class="keyword">switch</span> (Lr-&gt;bf)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> LH:</span><br><span class="line">            (*T)-&gt;bf = RH;</span><br><span class="line">            L-&gt;bf = EH;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EH:</span><br><span class="line">            (*T)-&gt;bf = L-&gt;bf = EH;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RH:</span><br><span class="line">            (*T)-&gt;bf = EH;</span><br><span class="line">            L-&gt;bf = LH;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Lr-&gt;bf = EH;</span><br><span class="line">        LeftRotate(&amp;(*T)-&gt;lchild);</span><br><span class="line">        RightRotate(T);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RightBalance</span><span class="params">(AVLTree *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    AVLTree R = (*T)-&gt;rchild;</span><br><span class="line">    AVLTree Rl;</span><br><span class="line">    <span class="keyword">switch</span> (R-&gt;bf)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> RH:</span><br><span class="line">        (*T)-&gt;bf = R-&gt;bf = EH;</span><br><span class="line">        LeftRotate(T);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LH:</span><br><span class="line">    &#123;</span><br><span class="line">        Rl = R-&gt;lchild;</span><br><span class="line">        <span class="keyword">switch</span> (Rl-&gt;bf)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> LH:</span><br><span class="line">            (*T)-&gt;bf = EH;</span><br><span class="line">            R-&gt;bf = RH;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EH:</span><br><span class="line">            (*T)-&gt;bf = R-&gt;bf = EH;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RH:</span><br><span class="line">            (*T)-&gt;bf = LH;</span><br><span class="line">            R-&gt;bf = EH;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Rl-&gt;bf = EH;</span><br><span class="line">        RightRotate(&amp;(*T)-&gt;rchild);</span><br><span class="line">        LeftRotate(T);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> __taller = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert_AVL</span><span class="params">(AVLTree *T, AVLElemtype key, <span class="type">bool</span> *taller)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(*T))</span><br><span class="line">    &#123;</span><br><span class="line">        *T = (AVLTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AVLNode));</span><br><span class="line">        (*T)-&gt;lchild = (*T)-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        (*T)-&gt;bf = EH;</span><br><span class="line">        (*T)-&gt;key = key;</span><br><span class="line">        *taller = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; (*T)-&gt;key)</span><br><span class="line">    &#123;</span><br><span class="line">        Insert_AVL(&amp;(*T)-&gt;lchild, key, taller);</span><br><span class="line">        <span class="keyword">if</span> (*taller)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> ((*T)-&gt;bf)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> LH:</span><br><span class="line">                LeftBalance(T);</span><br><span class="line">                *taller = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EH:</span><br><span class="line">                (*T)-&gt;bf = LH;</span><br><span class="line">                *taller = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RH:</span><br><span class="line">                (*T)-&gt;bf = EH;</span><br><span class="line">                *taller = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Insert_AVL(&amp;(*T)-&gt;rchild, key, taller);</span><br><span class="line">        <span class="keyword">if</span> (*taller)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> ((*T)-&gt;bf)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> LH:</span><br><span class="line">                (*T)-&gt;bf = EH;</span><br><span class="line">                *taller = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EH:</span><br><span class="line">                (*T)-&gt;bf = RH;</span><br><span class="line">                *taller = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RH:</span><br><span class="line">                RightBalance(T);</span><br><span class="line">                *taller = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="头文件-2"><a href="#头文件-2" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _Hash_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Hash_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __m 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __n 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULLKEY 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> HashElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> HashOther;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">HashTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    HashElemType key;</span><br><span class="line">    HashOther other;</span><br><span class="line">&#125; HashTable[__m];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Hash_Table.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="除留余数法-开放地址法"><a href="#除留余数法-开放地址法" class="headerlink" title="除留余数法+开放地址法"></a>除留余数法+开放地址法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Hash</span><span class="params">(<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> key % __n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitHashTable</span><span class="params">(HashTable hash)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input %d integer(s):&quot;</span>, __n);</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="built_in">memset</span>(hash, <span class="number">0</span>, <span class="keyword">sizeof</span>(HashTable));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; __n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;key);</span><br><span class="line">        <span class="type">int</span> m_i = Hash(key);</span><br><span class="line">        <span class="keyword">if</span> (hash[m_i].key == NULLKEY)</span><br><span class="line">        &#123;</span><br><span class="line">            hash[m_i].key = key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; __m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> m_j = Hash(key + j);</span><br><span class="line">                <span class="keyword">if</span> (hash[m_j].key == NULLKEY)</span><br><span class="line">                &#123;</span><br><span class="line">                    hash[m_j].key = key;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Hash_Search</span><span class="params">(HashTable hash, HashElemType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_i = Hash(key);</span><br><span class="line">    <span class="keyword">if</span> (hash[m_i].key == NULLKEY)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (hash[m_i].key == key)</span><br><span class="line">        <span class="keyword">return</span> m_i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; __m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> m_j = Hash(key + i);</span><br><span class="line">            <span class="keyword">if</span> (hash[m_j].key == NULLKEY)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (hash[m_j].key == key)</span><br><span class="line">                <span class="keyword">return</span> m_j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> *elem;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;Arr, *ArrPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> num; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;KeyNode;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RightMethod</span><span class="params">(ArrPtr pArr1)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *_a, <span class="type">const</span> <span class="type">void</span> *_b)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(ArrPtr pArr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Generate_Random_Array</span><span class="params">(ArrPtr pArr1, <span class="type">int</span> maxSize, <span class="type">int</span> maxVal)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Copy_Array</span><span class="params">(ArrPtr pArr1, ArrPtr pArr2)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Compare</span><span class="params">(ArrPtr pArr1, ArrPtr pArr2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insertion_sort</span><span class="params">(ArrPtr pArr2)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BInsert_sort</span><span class="params">(ArrPtr pArr2)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellInsert_sort</span><span class="params">(ArrPtr pArr2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Bubble_sort</span><span class="params">(ArrPtr pArr2)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Quick_sort</span><span class="params">(ArrPtr pArr2, <span class="type">int</span> low, <span class="type">int</span> high)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(ArrPtr pArr2, <span class="type">int</span> low, <span class="type">int</span> high)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Randomized_Partition</span><span class="params">(ArrPtr pArr2, <span class="type">int</span> low, <span class="type">int</span> high)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Randomized_Quick_sort</span><span class="params">(ArrPtr pArr2, <span class="type">int</span> low, <span class="type">int</span> high)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Simple_Selection_sort</span><span class="params">(ArrPtr pArr2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Create_Heap</span><span class="params">(ArrPtr pArr2)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Heapify</span><span class="params">(ArrPtr pArr2, <span class="type">int</span> length, <span class="type">int</span> k)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Heap_sort</span><span class="params">(ArrPtr pArr2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> *SR, <span class="type">int</span> *TR, <span class="type">int</span> i, <span class="type">int</span> mid, <span class="type">int</span> j)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Msort</span><span class="params">(<span class="type">int</span> *SR, <span class="type">int</span> *TR1, <span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge_sort</span><span class="params">(ArrPtr pArr2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge_Pass</span><span class="params">(<span class="type">int</span> *SR, <span class="type">int</span> *TR, <span class="type">int</span> i, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge_non_recursive_sort</span><span class="params">(ArrPtr pArr2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Counting_sort</span><span class="params">(ArrPtr pArr2)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Radix_sort</span><span class="params">(ArrPtr pArr2)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Bucket_sort</span><span class="params">(ArrPtr pArr2, <span class="type">int</span> bucket_size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Arr Arr1, Arr2;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> maxSize = <span class="number">500</span>;</span><br><span class="line"><span class="type">int</span> maxVal = <span class="number">500</span>;</span><br><span class="line"><span class="type">int</span> testtimes = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> succeed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; testtimes; i++)</span><br><span class="line">&#123;</span><br><span class="line">Generate_Random_Array(&amp;Arr1, maxSize, maxVal);</span><br><span class="line">Copy_Array(&amp;Arr1, &amp;Arr2);</span><br><span class="line"></span><br><span class="line">RightMethod(&amp;Arr1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Insertion_sort(&amp;Arr2);</span></span><br><span class="line"><span class="comment">//BInsert_sort(&amp;Arr2);</span></span><br><span class="line"><span class="comment">//ShellInsert_sort(&amp;Arr2);</span></span><br><span class="line"><span class="comment">//Bubble_sort(&amp;Arr2);</span></span><br><span class="line"><span class="comment">//Quick_sort(&amp;Arr2, 0, Arr2.length - 1);</span></span><br><span class="line"><span class="comment">//Randomized_Quick_sort(&amp;Arr2, 0, Arr2.length - 1);</span></span><br><span class="line"><span class="comment">//Simple_Selection_sort(&amp;Arr2);</span></span><br><span class="line"><span class="comment">//Heap_sort(&amp;Arr2);</span></span><br><span class="line"><span class="comment">//Merge_sort(&amp;Arr2);</span></span><br><span class="line"><span class="comment">//Merge_non_recursive_sort(&amp;Arr2);</span></span><br><span class="line"><span class="comment">//Counting_sort(&amp;Arr2);</span></span><br><span class="line"><span class="comment">//Radix_sort(&amp;Arr2);</span></span><br><span class="line">Bucket_sort(&amp;Arr2, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!Compare(&amp;Arr1, &amp;Arr2))</span><br><span class="line">&#123;</span><br><span class="line">succeed = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(Arr1.elem);</span><br><span class="line"><span class="built_in">free</span>(Arr2.elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(succeed ? <span class="string">&quot;Nice!\n&quot;</span> : <span class="string">&quot;Fucking fucked!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">traverse(&amp;Arr1);</span><br><span class="line">traverse(&amp;Arr2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RightMethod</span><span class="params">(ArrPtr pArr1)</span></span><br><span class="line">&#123;</span><br><span class="line">qsort(pArr1-&gt;elem, pArr1-&gt;length, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *_a, <span class="type">const</span> <span class="type">void</span> *_b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *(<span class="type">int</span>*)_a - *(<span class="type">int</span>*)_b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">arr[i] = arr[i] ^ arr[j];</span><br><span class="line">arr[j] = arr[i] ^ arr[j];</span><br><span class="line">arr[i] = arr[i] ^ arr[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = *a;</span><br><span class="line">*a = *b;</span><br><span class="line">*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(ArrPtr pArr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pArr-&gt;elem == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr-&gt;length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, pArr-&gt;elem[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Generate_Random_Array</span><span class="params">(ArrPtr pArr1, <span class="type">int</span> maxSize, <span class="type">int</span> maxVal)</span></span><br><span class="line">&#123;</span><br><span class="line">srand((<span class="type">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">pArr1-&gt;length = rand() % (maxSize + <span class="number">1</span>);</span><br><span class="line">pArr1-&gt;elem = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * pArr1-&gt;length);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr1-&gt;length; i++)</span><br><span class="line">&#123;</span><br><span class="line">pArr1-&gt;elem[i] = rand() % (maxVal + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Copy_Array</span><span class="params">(ArrPtr pArr1, ArrPtr pArr2)</span></span><br><span class="line">&#123;</span><br><span class="line">pArr2-&gt;length = pArr1-&gt;length;</span><br><span class="line">pArr2-&gt;elem = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * pArr2-&gt;length);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr2-&gt;length; i++)</span><br><span class="line">&#123;</span><br><span class="line">pArr2-&gt;elem[i] = pArr1-&gt;elem[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Compare</span><span class="params">(ArrPtr pArr1, ArrPtr pArr2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">bool</span> result = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr1-&gt;length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pArr1-&gt;elem[i] != pArr2-&gt;elem[i])</span><br><span class="line">&#123;</span><br><span class="line">result = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insertion_sort</span><span class="params">(ArrPtr pArr2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pArr2-&gt;elem == <span class="literal">NULL</span> || pArr2-&gt;length &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; pArr2-&gt;length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; pArr2-&gt;elem[j] &gt; pArr2-&gt;elem[j + <span class="number">1</span>]; j--)</span><br><span class="line">&#123;</span><br><span class="line">swap(pArr2-&gt;elem, j, j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BInsert_sort</span><span class="params">(ArrPtr pArr2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pArr2-&gt;elem == <span class="literal">NULL</span> || pArr2-&gt;length &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; pArr2-&gt;length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> high = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (pArr2-&gt;elem[i] &lt;= pArr2-&gt;elem[mid])</span><br><span class="line">&#123;</span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> temp = pArr2-&gt;elem[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt; low; j--)</span><br><span class="line">&#123;</span><br><span class="line">pArr2-&gt;elem[j] = pArr2-&gt;elem[j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">pArr2-&gt;elem[low] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellInsert_sort</span><span class="params">(ArrPtr pArr2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pArr2-&gt;elem == <span class="literal">NULL</span> || pArr2-&gt;length &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> gap = pArr2-&gt;length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; gap; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + gap; j &lt; pArr2-&gt;length; j += gap)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = pArr2-&gt;elem[j];</span><br><span class="line"><span class="type">int</span> k = j - gap;</span><br><span class="line"><span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; pArr2-&gt;elem[k] &gt; temp)</span><br><span class="line">&#123;</span><br><span class="line">pArr2-&gt;elem[k + gap] = pArr2-&gt;elem[k];</span><br><span class="line">k -= gap;</span><br><span class="line">&#125;</span><br><span class="line">pArr2-&gt;elem[k + gap] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Bubble_sort</span><span class="params">(ArrPtr pArr2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pArr2-&gt;elem == <span class="literal">NULL</span> || pArr2-&gt;length &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr2-&gt;length - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">bool</span> isSorted = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; pArr2-&gt;length - <span class="number">1</span> - i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pArr2-&gt;elem[j] &gt; pArr2-&gt;elem[j + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">isSorted = <span class="literal">false</span>;</span><br><span class="line">swap(pArr2-&gt;elem, j, j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isSorted)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Quick_sort</span><span class="params">(ArrPtr pArr2, <span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (low &gt;= high)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="type">int</span> i = low;</span><br><span class="line">    <span class="type">int</span> j = high;</span><br><span class="line">    <span class="type">int</span> key = pArr2-&gt;elem[i];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; pArr2-&gt;elem[j] &gt; key)</span><br><span class="line">        &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">pArr2-&gt;elem[i++] = pArr2-&gt;elem[j];</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; pArr2-&gt;elem[i] &lt; key)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">pArr2-&gt;elem[j--] = pArr2-&gt;elem[i];</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pArr2-&gt;elem[i] = key;</span><br><span class="line">    Quick_sort(pArr2, low, i - <span class="number">1</span>);</span><br><span class="line">    Quick_sort(pArr2, i + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(ArrPtr pArr2, <span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = low - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> j = low;</span><br><span class="line"><span class="keyword">for</span> (; j &lt; high; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pArr2-&gt;elem[j] &lt;= pArr2-&gt;elem[high])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">Swap(&amp;pArr2-&gt;elem[i], &amp;pArr2-&gt;elem[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Swap(&amp;pArr2-&gt;elem[i + <span class="number">1</span>], &amp;pArr2-&gt;elem[high]);</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Randomized_Partition</span><span class="params">(ArrPtr pArr2, <span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">srand((<span class="type">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">i = rand() % (high - low + <span class="number">1</span>) + low;</span><br><span class="line">Swap(&amp;pArr2-&gt;elem[high], &amp;pArr2-&gt;elem[i]);</span><br><span class="line"><span class="keyword">return</span> Partition(pArr2, low, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Randomized_Quick_sort</span><span class="params">(ArrPtr pArr2, <span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (low &gt;= high)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = Randomized_Partition(pArr2, low, high);</span><br><span class="line">Randomized_Quick_sort(pArr2, low, mid - <span class="number">1</span>);</span><br><span class="line">Randomized_Quick_sort(pArr2, mid + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Simple_Selection_sort</span><span class="params">(ArrPtr pArr2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pArr2-&gt;elem == <span class="literal">NULL</span> || pArr2-&gt;length &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr2-&gt;length - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> k = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; pArr2-&gt;length; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pArr2-&gt;elem[j] &lt; pArr2-&gt;elem[k])</span><br><span class="line">&#123;</span><br><span class="line">k = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k != i)</span><br><span class="line">&#123;</span><br><span class="line">swap(pArr2-&gt;elem, i, k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Create_Heap</span><span class="params">(ArrPtr pArr2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> last_parent = pArr2-&gt;length - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> parent = (last_parent - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = parent; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">Heapify(pArr2, pArr2-&gt;length, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Heapify</span><span class="params">(ArrPtr pArr2, <span class="type">int</span> length, <span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (k &lt; length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> root = k;</span><br><span class="line"><span class="type">int</span> left_child = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> right_child = <span class="number">2</span> * k + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (left_child &lt; length &amp;&amp; pArr2-&gt;elem[root] &lt; pArr2-&gt;elem[left_child])</span><br><span class="line">&#123;</span><br><span class="line">root = left_child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (right_child &lt; length &amp;&amp; pArr2-&gt;elem[root] &lt; pArr2-&gt;elem[right_child])</span><br><span class="line">&#123;</span><br><span class="line">root = right_child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (root != k)</span><br><span class="line">&#123;</span><br><span class="line">swap(pArr2-&gt;elem, root, k);</span><br><span class="line">Heapify(pArr2, length, root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Heap_sort</span><span class="params">(ArrPtr pArr2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pArr2-&gt;elem == <span class="literal">NULL</span> || pArr2-&gt;length &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Create_Heap(pArr2);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = pArr2-&gt;length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">swap(pArr2-&gt;elem, i, <span class="number">0</span>);</span><br><span class="line">Heapify(pArr2, i, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> *SR, <span class="type">int</span> *TR, <span class="type">int</span> i, <span class="type">int</span> mid, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m = i;</span><br><span class="line"><span class="type">int</span> n = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> t = i; m &lt;= mid &amp;&amp; n &lt;= j; t++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (SR[m] &lt; SR[n])</span><br><span class="line">&#123;</span><br><span class="line">TR[t] = SR[m++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">TR[t] = SR[n++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (m &lt;= mid)</span><br><span class="line">&#123;</span><br><span class="line">TR[t++] = SR[m++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (n &lt;= j)</span><br><span class="line">&#123;</span><br><span class="line">TR[t++] = SR[n++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Msort</span><span class="params">(<span class="type">int</span> *SR, <span class="type">int</span> *TR1, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> *TR2 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * j + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (i == j)</span><br><span class="line">&#123;</span><br><span class="line">TR1[i] = SR[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">Msort(SR, TR2, i, mid);</span><br><span class="line">Msort(SR, TR2, mid + <span class="number">1</span>, j);</span><br><span class="line">Merge(TR2, TR1, i, mid, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge_sort</span><span class="params">(ArrPtr pArr2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pArr2-&gt;elem == <span class="literal">NULL</span> || pArr2-&gt;length &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Msort(pArr2-&gt;elem, pArr2-&gt;elem, <span class="number">0</span>, pArr2-&gt;length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge_Pass</span><span class="params">(<span class="type">int</span> *SR, <span class="type">int</span> *TR, <span class="type">int</span> i, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (j + <span class="number">2</span> * i - <span class="number">1</span> &lt;= n)</span><br><span class="line">&#123;</span><br><span class="line">Merge(SR, TR, j, j + i - <span class="number">1</span>, j + <span class="number">2</span> * i - <span class="number">1</span>);</span><br><span class="line">j += <span class="number">2</span> * i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j + i - <span class="number">1</span> &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">Merge(SR, TR, j, j + i - <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= n)</span><br><span class="line">&#123;</span><br><span class="line">TR[j] = SR[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge_non_recursive_sort</span><span class="params">(ArrPtr pArr2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pArr2-&gt;elem == <span class="literal">NULL</span> || pArr2-&gt;length &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> *TR = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * pArr2-&gt;length);</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; pArr2-&gt;length)</span><br><span class="line">&#123;</span><br><span class="line">Merge_Pass(pArr2-&gt;elem, TR, i, pArr2-&gt;length - <span class="number">1</span>);</span><br><span class="line">i *= <span class="number">2</span>;</span><br><span class="line">Merge_Pass(TR, pArr2-&gt;elem, i, pArr2-&gt;length - <span class="number">1</span>);</span><br><span class="line">i *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Counting_sort</span><span class="params">(ArrPtr pArr2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pArr2-&gt;elem == <span class="literal">NULL</span> || pArr2-&gt;length &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> max = pArr2-&gt;elem[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> min = pArr2-&gt;elem[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr2-&gt;length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pArr2-&gt;elem[i] &gt; max)</span><br><span class="line">&#123;</span><br><span class="line">max = pArr2-&gt;elem[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pArr2-&gt;elem[i] &lt; min)</span><br><span class="line">&#123;</span><br><span class="line">min = pArr2-&gt;elem[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *temp = (<span class="type">int</span>*)<span class="built_in">calloc</span>(range, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pArr2-&gt;length; i++)</span><br><span class="line">&#123;</span><br><span class="line">temp[pArr2-&gt;elem[i] - min] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; range; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (temp[i]--)</span><br><span class="line">&#123;</span><br><span class="line">pArr2-&gt;elem[count++] = i + min;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Radix_sort</span><span class="params">(ArrPtr pArr2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> *temp = (<span class="type">int</span>*)<span class="built_in">calloc</span>(pArr2-&gt;length, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span> <span class="built_in">exp</span> = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> maxval = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr2-&gt;length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pArr2-&gt;elem[i] &gt; maxval)</span><br><span class="line">&#123;</span><br><span class="line">maxval = pArr2-&gt;elem[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (maxval &gt;= <span class="built_in">exp</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> *cnt = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr2-&gt;length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> digit = (pArr2-&gt;elem[i] / <span class="built_in">exp</span>) % <span class="number">10</span>;</span><br><span class="line">cnt[digit]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = pArr2-&gt;length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> digit = (pArr2-&gt;elem[i] / <span class="built_in">exp</span>) % <span class="number">10</span>;</span><br><span class="line">temp[--cnt[digit]] = pArr2-&gt;elem[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(pArr2-&gt;elem, temp, <span class="keyword">sizeof</span>(<span class="type">int</span>) * pArr2-&gt;length);</span><br><span class="line"><span class="built_in">exp</span> *= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Bucket_sort</span><span class="params">(ArrPtr pArr2, <span class="type">int</span> bucket_size)</span></span><br><span class="line">&#123;</span><br><span class="line">KeyNode **bucket_num = (KeyNode **)<span class="built_in">malloc</span>(bucket_size * <span class="keyword">sizeof</span>(KeyNode*));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucket_size; i++) </span><br><span class="line">&#123;</span><br><span class="line">bucket_num[i] = (KeyNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(KeyNode)); </span><br><span class="line">bucket_num[i]-&gt;num = <span class="number">0</span>;   </span><br><span class="line">bucket_num[i]-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; pArr2-&gt;length; j++)</span><br><span class="line">&#123;</span><br><span class="line">KeyNode *node = (KeyNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(KeyNode)); </span><br><span class="line">node-&gt;num = pArr2-&gt;elem[j];</span><br><span class="line">node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> index = pArr2-&gt;elem[j] / <span class="number">100</span>;</span><br><span class="line">KeyNode *p = bucket_num[index];</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span> &amp;&amp; p-&gt;next-&gt;num &lt;= node-&gt;num)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">node-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = node;</span><br><span class="line">(bucket_num[index]-&gt;num)++;</span><br><span class="line">&#125;</span><br><span class="line">KeyNode *k = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; bucket_size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        k = bucket_num[i]-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> m = <span class="number">0</span>; m &lt; bucket_num[i]-&gt;num; m++)</span><br><span class="line">        &#123;</span><br><span class="line">            pArr2-&gt;elem[m] = k-&gt;num;</span><br><span class="line">            k=k-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据结构的程序实现&quot;&gt;&lt;a href=&quot;#数据结构的程序实现&quot; class=&quot;headerlink&quot; title=&quot;数据结构的程序实现&quot;&gt;&lt;/a&gt;数据结构的程序实现&lt;/h1&gt;&lt;p&gt;​	本文主要为使用c语言对数据结构相关内容进行代码实现。&lt;/p&gt;</summary>
    
    
    
    <category term="c数据结构" scheme="https://sixteen-nights.github.io/categories/c%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="c" scheme="https://sixteen-nights.github.io/tags/c/"/>
    
    <category term="数据结构" scheme="https://sixteen-nights.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>C语言扩展总结</title>
    <link href="https://sixteen-nights.github.io/2022/07/30/C%E8%AF%AD%E8%A8%80%E6%89%A9%E5%B1%95%E6%80%BB%E7%BB%93/"/>
    <id>https://sixteen-nights.github.io/2022/07/30/C%E8%AF%AD%E8%A8%80%E6%89%A9%E5%B1%95%E6%80%BB%E7%BB%93/</id>
    <published>2022-07-29T17:20:00.000Z</published>
    <updated>2023-03-30T05:49:48.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言扩展总结"><a href="#C语言扩展总结" class="headerlink" title="C语言扩展总结"></a>C语言扩展总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​本文内容大部分粘贴自原文章，对重要内容进行加粗标注，其中<strong>指针章节为专门章节</strong>，跟原文无关，我自身用vc6.0对前面的案例代码进行了测试，并将其中不适配的地方以及原文说的不细致的地方进行了说明和补充。从内存管理开始更换了编译器，使用VS Code进行代码测试，对于VC6.0不支持的标准将不再提示。</p><p>原文链接：<a href="https://wangdoc.com/clang/intro">https://wangdoc.com/clang/intro</a></p><span id="more"></span><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>​编译时，<strong>注释会被代替成一个空格</strong>，因此<code>a/**/b</code>的编译结果是<code>a b</code>而不是<code>ab</code>。</p><h3 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h3><p><img src="C:\Users\葛忠洋\Pictures\笔记资料图\QQ图片20221031161526.png"></p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><ol><li><p>总是显示正负号<br>默认情况下，<code>printf()</code>不对正数显示<code>+</code>号，只对负数显示<code>-</code>号。如果想让正数也输出<code>+</code>号，可以在占位符的<code>%</code>后面加一个<code>+</code>；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%+d\n&quot;</span>, <span class="number">12</span>); <span class="comment">// 输出 +12</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%+d\n&quot;</span>, <span class="number">-12</span>); <span class="comment">// 输出 -12</span></span><br></pre></td></tr></table></figure></li><li><p>位数限定的代替</p><p>​最小宽度和小数位数这两个限定值，都可以用<code>*</code>代替，通过<code>printf()</code>的参数传入；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%*.*f\n&quot;</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">0.5</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%6.2f\n&quot;</span>, <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure></li><li><p>输出部分字符串</p><p>​<code>%s</code>占位符用来输出字符串，默认是全部输出。<strong>如果只想输出开头的部分，可以用<code>%.[m]s</code>指定输出的长度</strong>，其中<code>[m]</code>代表一个数字，表示所要输出的长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出 hello</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.5s\n&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>​<strong>C语言中把标识符分为三类：关键字，预定义标识符，用户自定义标识符。</strong> </p><p>​关键字是编程语言里事先定义的，有特别意义的标识符，它还包含一些编程语言里暂时还没有定义，但是保留下来的标识符，这类标识符称为保留字。</p><p>​预定义标识符是C语言中系统预先定义的标识符，如系统类库名、系统常量名、系统函数名。</p><p>​用户自定义标识符，包括变量名、常量名、对象名、函数名、类型名等等。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h3><ol><li>变量名的长度不能超过63个字符；(C89规定)</li><li>关键字与保留字不可以用作变量名；</li><li>两个下划线开头的变量名，以及一个下划线 + 大写英文字母开头的变量名，都是系统保留的，自己不应该起这样的变量名。</li></ol><h3 id="变量的赋值"><a href="#变量的赋值" class="headerlink" title="变量的赋值"></a>变量的赋值</h3><p>​<strong>赋值表达式有返回值，等于等号右边的值</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line">y = (x = <span class="number">2</span> * x); <span class="comment">// y = 2</span></span><br></pre></td></tr></table></figure><p>​由于赋值表达式有返回值，所以 C 语言可以写出多重赋值表达式；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x, y, z, m, n;</span><br><span class="line"></span><br><span class="line">x = y = z = m = n = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>​上面的代码是合法代码，<strong>一次为多个变量赋值，赋值运算符是从右到左执行</strong>，所以先为<code>n</code>赋值，然后依次为<code>m</code>、<code>z</code>、<code>y</code>和<code>x</code>赋值。</p><p>​C 语言有左值（left value）和右值（right value）的概念。<strong>左值是可以放在赋值运算符左边的值，一般是变量；右值是可以放在赋值运算符右边的值，一般是一个具体的值。这是为了强调有些值不能放在赋值运算符的左边</strong>，比如<code>x = 1</code>是合法的表达式，但是<code>1 = x</code>就会报错。</p><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>​作用域（scope）指的是变量生效的范围。C 语言的变量作用域主要有两种：文件作用域（file scope）和块作用域（block scope）；</p><p>​文件作用域（file scope）指的是，在源码文件顶层声明的变量，从声明的位置到文件结束都有效。（类似于全局变量）；</p><p>​块作用域（block scope）指的是由大括号（<code>&#123;&#125;</code>）组成的代码块，它形成一个单独的作用域。凡是在块作用域里面声明的变量，只在当前代码块有效，代码块外部不可见。（类似于局部变量）；</p><p>​代码块可以嵌套，即代码块内部还有代码块，这时就形成了多层的块作用域。它的规则是：<strong>内层代码块可以使用外层声明的变量，但外层不可以使用内层声明的变量。如果内层的变量与外层同名，那么会在当前作用域覆盖外层变量</strong>；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> i = <span class="number">20</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);  <span class="comment">// 20</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);  <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​**最常见的块作用域就是函数，函数内部声明的变量，对于函数外部是不可见的。<code>for</code>循环也是一个块作用域，循环变量只对循环体内部可见，外部是不可见的。(注意：在vc6.0里for循环不是一个块作用域)**。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><p>​所谓一元运算符，指的是只需要一个运算数就可以执行。（例如：<code>+</code>和<code>-</code>）<br>​一元运算符<code>-</code>用来改变一个值的正负号，<strong>一元运算符<code>+</code>对正负值没有影响</strong>，是一个完全可以省略的运算符，但是写了也不会报错。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">-12</span>;</span><br><span class="line"><span class="type">int</span> y = +x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, y); <span class="comment">// -12</span></span><br></pre></td></tr></table></figure><h3 id="除法运算与求余运算"><a href="#除法运算与求余运算" class="headerlink" title="除法运算与求余运算"></a>除法运算与求余运算</h3><ol><li><p>除法运算</p><p>​运算符<code>/</code>用来完成除法。注意，两个整数相除，得到还是一个整数，<strong>这与接收结果的变量的数据类型无关</strong>，原因就在于 C 语言里面的整数除法是整除，只会返回整数部分，丢弃小数部分。</p><p>​如果希望得到浮点数的结果，两个运算数必须至少有一个浮点数，这时 C 语言就会进行浮点数除法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> x = <span class="number">6</span> / <span class="number">4</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x); <span class="comment">// 1.000000</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">6.0</span> / <span class="number">4</span>; <span class="comment">//或写成 6 / 4.0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x); <span class="comment">// 1.500000</span></span><br></pre></td></tr></table></figure></li><li><p>求余运算</p><p>​运算符<code>%</code>表示求模运算，即返回两个整数相除的余值。<strong>这个运算符只能用于整数，不能用于浮点数。</strong></p><p>​<strong>负数求模的规则是，结果的正负号由第一个运算数的正负号决定</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span> % <span class="number">-5</span> <span class="comment">// 1</span></span><br><span class="line"><span class="number">-11</span> % <span class="number">-5</span> <span class="comment">// -1</span></span><br><span class="line"><span class="number">-11</span> % <span class="number">5</span> <span class="comment">// -1</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>​<strong>关系表达式通常返回<code>0</code>或<code>1</code>，表示真伪。C 语言中，<code>0</code>表示伪，所有非零值表示真。</strong>比如，<code>20 &gt; 12</code>返回<code>1</code>，<code>12 &gt; 20</code>返回<code>0</code>。</p><p>​注意，<strong>相等运算符<code>==</code>与赋值运算符<code>=</code>是两个不一样的运算符</strong>，不要混淆。有时候，可能会不小心写出下面的代码，它可以运行，但很容易出现意料之外的结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x = <span class="number">3</span>) ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，原意是<code>x == 3</code>，但是不小心写成<code>x = 3</code>。这个式子表示对变量<code>x</code>赋值<code>3</code>，<strong>它的返回值为<code>3</code>，所以<code>if</code>判断总是为真</strong>。</p><p>​为了防止出现这种错误，有的程序员喜欢<strong>将变量写在等号的右边</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 正确运行 */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">3</span> == x) ...</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 报错 */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">3</span> = x) ...</span><br></pre></td></tr></table></figure><p>​另一个需要避免的错误是，<strong>多个关系运算符不宜连用</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i &lt; j &lt; k</span><br></pre></td></tr></table></figure><p>​上面示例中，连续使用两个小于运算符。这是合法表达式，不会报错，但是通常达不到想要的结果，即不是保证变量<code>j</code>的值在<code>i</code>和<code>k</code>之间。因为关系运算符是从左到右计算，所以实际执行的是下面的表达式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(i &lt; j) &lt; k</span><br></pre></td></tr></table></figure><p>​<strong>上面式子中，<code>i &lt; j</code>返回<code>0</code>或<code>1</code>，所以最终是<code>0</code>或<code>1</code>与变量<code>k</code>进行比较</strong>。</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>​<strong>对于逻辑运算符来说，任何非零值都表示真，零值表示伪</strong>。比如，<code>5 || 0</code>会返回<code>1</code>，<code>5 &amp;&amp; 0</code>会返回<code>0</code>。</p><p>​<strong>逻辑运算符还有一个特点，它总是先对左侧的表达式求值，再对右边的表达式求值，这个顺序是保证的。如果左边的表达式满足逻辑运算符的条件，就不再对右边的表达式求值。这种情况称为“短路”。因此<code>&amp;&amp;</code> <code>||</code>分别称为短路与和短路或，<code>&amp;</code> <code>|</code>才是逻辑与和逻辑或。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (number != <span class="number">0</span> &amp;&amp; <span class="number">12</span>/number == <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>​上面示例中，如果<code>&amp;&amp;</code>左侧的表达式（<code>number != 0</code>）为伪，即<code>number</code>等于<code>0</code>时，右侧的表达式（<code>12/number == 2</code>）是不会执行的。因为这时左侧表达式返回<code>0</code>，整个<code>&amp;&amp;</code>表达式肯定为伪，就直接返回<code>0</code>，不再执行右侧的表达式了。</p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><ol><li><p>取反运算符<code>~</code><br>取反运算符<code>～</code>是一个一元运算符，用来将每一个二进制位变成相反值，即<code>0</code>变成<code>1</code>，<code>1</code>变成<code>0</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 01101100</span></span><br><span class="line">~ <span class="number">10010011</span></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>~</code>对每个二进制位取反，就得到了一个新的值。</p><p>​<strong>注意，<code>~</code>运算符不会改变变量的值，只是返回一个新的值。</strong></p></li><li><p>与运算符<code>&amp;</code></p><p>​与运算符<code>&amp;</code>将两个值的每一个二进制位进行比较，返回一个新的值。当两个二进制位都为<code>1</code>，就返回<code>1</code>，否则返回<code>0</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 00010001</span></span><br><span class="line"><span class="number">10010011</span> &amp; <span class="number">00111101</span></span><br></pre></td></tr></table></figure><p>​上面示例中，两个八位二进制数进行逐位比较，返回一个新的值。</p><p>​与运算符<code>&amp;</code>可以与赋值运算符<code>=</code>结合，简写成<code>&amp;=</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">3</span>;</span><br><span class="line">val = val &amp; <span class="number">0377</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写成</span></span><br><span class="line">val &amp;= <span class="number">0377</span>;</span><br></pre></td></tr></table></figure></li><li><p>或运算符<code>|</code></p><p>​或运算符<code>|</code>将两个值的每一个二进制位进行比较，返回一个新的值。两个二进制位只要有一个为<code>1</code>（包含两个都为<code>1</code>的情况），就返回<code>1</code>，否则返回<code>0</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 10111111</span></span><br><span class="line"><span class="number">10010011</span> | <span class="number">00111101</span></span><br></pre></td></tr></table></figure><p>​或运算符<code>|</code>可以与赋值运算符<code>=</code>结合，简写成<code>|=</code>。</p></li><li><p>异或运算符<code>^</code></p><p>​异或运算符<code>^</code>将两个值的每一个二进制位进行比较，返回一个新的值。两个二进制位有且仅有一个为<code>1</code>，就返回<code>1</code>，否则返回<code>0</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 10101110</span></span><br><span class="line"><span class="number">10010011</span> ^ <span class="number">00111101</span></span><br></pre></td></tr></table></figure><p>​异或运算符<code>^</code>可以与赋值运算符<code>=</code>结合，简写成<code>^=</code>。</p></li><li><p>左移运算符<code>&lt;&lt;</code></p><p>​<strong>左移运算符<code>&lt;&lt;</code>将左侧运算数的每一位，向左移动指定的位数，尾部空出来的位置使用<code>0</code>填充。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1000101000</span></span><br><span class="line"><span class="number">10001010</span> &lt;&lt; <span class="number">2</span></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>10001010</code>的每一个二进制位，都向左侧移动了两位。</p><p>​<strong>左移运算符相当于将运算数乘以2的指定次方，比如左移2位相当于乘以4（2的2次方）。</strong></p><p>​左移运算符<code>&lt;&lt;</code>可以与赋值运算符<code>=</code>结合，简写成<code>&lt;&lt;=</code>。</p></li><li><p>右移运算符<code>&gt;&gt;</code></p><p>​<strong>右移运算符<code>&gt;&gt;</code>将左侧运算数的每一位，向右移动指定的位数，尾部无法容纳的值将丢弃，头部空出来的位置使用<code>0</code>填充。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 00100010</span></span><br><span class="line"><span class="number">10001010</span> &gt;&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>10001010</code>的每一个二进制位，都向右移动两位。最低的两位<code>10</code>被丢弃，头部多出来的两位补<code>0</code>，所以最后得到<code>00100010</code>。</p><p>​<strong>注意，右移运算符最好只用于无符号整数，不要用于负数。因为不同系统对于右移后如何处理负数的符号位，有不同的做法，可能会得到不一样的结果。</strong></p><p>​<strong>右移运算符相当于将运算数除以2的指定次方，比如右移2位就相当于除以4（2的2次方）。</strong></p><p>​右移运算符<code>&gt;&gt;</code>可以与赋值运算符<code>=</code>结合，简写成<code>&gt;&gt;=</code>。</p></li></ol><p><strong>注意：在C语言中，对于移位操作执行的是逻辑左移和算术右移，不过对于无符号类型，所有的移位操作都是逻辑的。所以要相对一个有符号数执行逻辑右移，那么可以先将它强制类型转换为无符号类型。</strong></p><h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><p>​逗号运算符用于将多个表达式写在一起，从左到右依次运行每个表达式。<strong>逗号运算符返回最后一个表达式的值，作为整个语句的值。注意，逗号的优先级低于赋值运算符，所以先执行赋值运算，再执行逗号运算。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span>, <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">x = (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="运算优先级"><a href="#运算优先级" class="headerlink" title="运算优先级"></a>运算优先级</h3><p>​优先级指的是，如果一个表达式包含多个运算符，哪个运算符应该优先执行。各种运算符的优先级是不一样的。</p><p>​<strong>如果两个运算符优先级相同，则根据运算符是左结合，还是右结合，决定执行顺序。</strong>大部分运算符是左结合（从左到右执行），少数运算符是右结合（从右到左执行），比如赋值运算符（<code>=</code>）。</p><p>​运算符的优先级顺序很复杂。下面是部分运算符的优先级顺序（按照优先级从高到低排列）。由于圆括号的优先级最高，可以使用它改变其他运算符的优先级。</p><p><img src="C:\Users\葛忠洋\Pictures\笔记资料图\QQ图片20221101151802.png"></p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p>​如果有多个<code>if</code>和<code>else</code>，可以记住这样一条规则，**<code>else</code>总是跟最接近的<code>if</code>匹配。**</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (number &gt; <span class="number">6</span>)</span><br><span class="line"><span class="keyword">if</span> (number &lt; <span class="number">12</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The number is more than 6, less than 12.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;It is wrong number.\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>else</code>部分匹配最近的<code>if</code>（即<code>number &lt; 12</code>），所以如果<code>number</code>等于6，就不会执行<code>else</code>的部分。</p><p>​这样很容易出错，为了提供代码的可读性，建议使用大括号，明确<code>else</code>匹配哪一个<code>if</code>。</p><h3 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h3><p>​<strong>注意，<code>break</code>命令只能跳出循环体和<code>switch</code>结构，不能跳出<code>if</code>结构。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">2</span>) <span class="keyword">break</span>; <span class="comment">// 无效</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>break</code>语句是无效的，因为它不能跳出外层的<code>if</code>结构。</p><h3 id="goto-语句"><a href="#goto-语句" class="headerlink" title="goto 语句"></a>goto 语句</h3><p>​<strong>goto语句也称为无条件转移语句</strong>，其一般格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> 语句标号;</span><br></pre></td></tr></table></figure><p>​<strong>其中语句标号是按标识符规定书写的符号，放在某一语句行的前面，标号后加半角冒号”:“。语句标号起标识语句的作用，与goto句配合使用。</strong></p><p>​C语言不限制程序中使用标号的次数，但各标号不得重名。<strong>goto 语句的语义是改变程序流向， 转去执行语句标号所标识的语句。</strong>但是，在结构化程序设计中一般不主张使用 goto 语句， 以免造成程序流程的混乱，使理解和调试程序都产生困难。</p><p>​<strong>goto 语句用于跳到指定的标签名。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">top: ch = getchar();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">    <span class="keyword">goto</span> top;</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>top</code>是一个标签名，可以放在正常语句的前面，相当于为这行语句做了一个标记。程序执行到<code>goto</code>语句，就会跳转到它指定的标签名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">infinite_loop:</span><br><span class="line">    print(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> infinite_loop;</span><br></pre></td></tr></table></figure><p>​上面的代码会产生无限循环。</p><p>​<strong>goto 的一个主要用法是跳出多层循环。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(...) &#123;</span><br><span class="line">    <span class="keyword">for</span> (...) &#123;</span><br><span class="line">        <span class="keyword">while</span> (...) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (some_error_condition)</span><br><span class="line">            <span class="keyword">goto</span> bail;    </span><br><span class="line">        &#125; <span class="keyword">while</span>(...);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">bail:</span><br><span class="line"><span class="comment">// ... ...</span></span><br></pre></td></tr></table></figure><p>​上面代码有很复杂的嵌套循环，不使用 goto 的话，想要完全跳出所有循环，写起来很麻烦。</p><p>​<strong>goto 的另一个用途是提早结束多重判断。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (do_something() == ERR)</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line"><span class="keyword">if</span> (do_something2() == ERR)</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line"><span class="keyword">if</span> (do_something3() == ERR)</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line"><span class="keyword">if</span> (do_something4() == ERR)</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br></pre></td></tr></table></figure><p>​上面示例有四个判断，只要有一个发现错误，就使用 goto 跳过后面的判断。</p><p><strong>注意，goto 只能在同一个函数之中跳转，并不能跳转到其他函数。</strong></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><p>​由于单引号本身也是一个字符，如果要表示这个字符常量，必须使用反斜杠转义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> t = <span class="string">&#x27;\&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>​这种转义的写法，主要用来表示 ASCII 码定义的一些无法打印的控制字符，它们也属于字符类型的值。</p><ul><li><p><code>\a</code>：警报，这会使得终端发出警报声或出现闪烁，或者两者同时发生。</p></li><li><p><code>\b</code>：退格键，光标回退一个字符，但不删除字符。</p></li><li><p><code>\f</code>：换页符，光标移到下一页。在现代系统上，这已经反映不出来了，行为改成类似于<code>\v</code>。</p></li><li><p><code>\n</code>：换行符。</p></li><li><p><code>\r</code>：回车符，光标移到同一行的开头。</p></li><li><p><code>\t</code>：制表符，光标移到下一个水平制表位，通常是下一个8的倍数。</p></li><li><p><code>\v</code>：垂直分隔符，光标移到下一个垂直制表位，通常是下一行的同一列。</p></li><li><p><code>\0</code>：null 字符，代表没有内容。注意，这个值不等于数字0。</p><p><strong>转义写法还能使用八进制和十六进制表示一个字符。</strong></p></li><li><p><code>\nn</code>：字符的八进制写法，<code>nn</code>为八进制值。</p></li><li><p><code>\xnn</code>：字符的十六进制写法，<code>nn</code>为十六进制值。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> x = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"><span class="type">char</span> x = <span class="number">66</span>;</span><br><span class="line"><span class="type">char</span> x = <span class="string">&#x27;\102&#x27;</span>; <span class="comment">// 八进制</span></span><br><span class="line"><span class="type">char</span> x = <span class="string">&#x27;\x42&#x27;</span>; <span class="comment">// 十六进制</span></span><br></pre></td></tr></table></figure><p>​上面示例的四种写法都是等价的。</p><h3 id="整形类型"><a href="#整形类型" class="headerlink" title="整形类型"></a>整形类型</h3><h4 id="整形大小"><a href="#整形大小" class="headerlink" title="整形大小"></a>整形大小</h4><p>​整数类型用来表示较大的整数，类型声明使用<code>int</code>关键字。</p><p>​不同计算机的<code>int</code>类型的大小是不一样的。比较常见的是使用4个字节（32位）存储一个<code>int</code>类型的值，但是2个字节（16位）或8个字节（64位）也有可能使用。它们可以表示的整数范围如下。</p><ul><li>16位：-32,768 到 32,767。</li><li>32位：-2,147,483,648 到 2,147,483,647。</li><li>64位：-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807。</li></ul><h4 id="signed和unsigned"><a href="#signed和unsigned" class="headerlink" title="signed和unsigned"></a>signed和unsigned</h4><p>​<strong>C 语言使用<code>signed</code>关键字，表示一个类型带有正负号，包含负值；使用<code>unsigned</code>关键字，表示该类型不带有正负号，只能表示零和正整数。</strong></p><p>​对于<code>int</code>类型，默认是带有正负号的，也就是说<code>int</code>等同于<code>signed int</code>。由于这是默认情况，关键字<code>signed</code>一般都省略不写，但是写了也不算错。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">int</span> a;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">int</span> a;</span><br></pre></td></tr></table></figure><p>​<code>int</code>类型也可以不带正负号，只表示非负整数。这时就必须使用关键字<code>unsigned</code>声明变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a;</span><br></pre></td></tr></table></figure><p>​<strong>整数变量声明为<code>unsigned</code>的好处是，同样长度的内存能够表示的最大整数值，增大了一倍</strong>。比如，16位的<code>signed int</code>最大值为32,767，而<code>unsigned int</code>的最大值增大到了65,535。</p><p>​<strong><code>unsigned int</code>里面的<code>int</code>可以省略</strong>，所以上面的变量声明也可以写成下面这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> a;</span><br></pre></td></tr></table></figure><p>​<strong>字符类型<code>char</code>也可以设置<code>signed</code>和<code>unsigned</code>。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">char</span> c; <span class="comment">// 范围为 -128 到 127</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c; <span class="comment">// 范围为 0 到 255</span></span><br></pre></td></tr></table></figure><p>​<strong>注意，C 语言规定<code>char</code>类型默认是否带有正负号，由当前系统决定。这就是说，<code>char</code>不等同于<code>signed char</code>，它有可能是<code>signed char</code>，也有可能是<code>unsigned char</code>。这一点与<code>int</code>不同，<code>int</code>就是等同于<code>signed int</code>。</strong></p><h4 id="整形的子类型"><a href="#整形的子类型" class="headerlink" title="整形的子类型"></a>整形的子类型</h4><p>​如果<code>int</code>类型使用4个或8个字节表示一个整数，对于小整数，这样做很浪费空间。另一方面，某些场合需要更大的整数，8个字节还不够。为了解决这些问题，C 语言在<code>int</code>类型之外，又提供了三个整数的子类型。这样有利于更精细地限定整数变量的范围，也有利于更好地表达代码的意图。</p><ul><li><code>short int</code>（简写为<code>short</code>）：占用空间不多于<code>int</code>，一般占用2个字节（整数范围为-32768～32767)。</li><li><code>long int</code>（简写为<code>long</code>）：占用空间不少于<code>int</code>，至少为4个字节。</li><li><code>long long int</code>（简写为<code>long long</code>）：占用空间多于<code>long</code>，至少为8个字节。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">long</span> <span class="type">int</span> b;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> c;</span><br></pre></td></tr></table></figure><p>​<strong>默认情况下，<code>short</code>、<code>long</code>、<code>long long</code>都是带符号的（signed），即<code>signed</code>关键字省略了。</strong>它们也可以声明为不带符号（unsigned），使得能够表示的最大值扩大一倍。</p><p>​**C 语言允许省略<code>int</code>**，所以变量声明语句也可以写成下面这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> a;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> a;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> b;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> b;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> c;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> c;</span><br></pre></td></tr></table></figure><p>​不同的计算机，数据类型的字节长度是不一样的。确实需要32位整数时，应使用<code>long</code>类型而不是<code>int</code>类型，可以确保不少于4个字节；确实需要64位的整数时，应该使用<code>long long</code>类型，可以确保不少于8个字节。另一方面，为了节省空间，只需要16位整数时，应使用<code>short</code>类型；需要8位整数时，应该使用<code>char</code>类型。</p><p><strong>注意，vc6.0并不支持long long，long long是C99标准中新引进的数据类型，为了表示64位整数，vc6.0里采用的是微软自己搞出来的一个数据类型,叫做__int64。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__int64 a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%I64d&quot;</span>, &amp;a); <span class="comment">// 必须是大写I</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%I64d&quot;</span>, a);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="整数类型的极限值"><a href="#整数类型的极限值" class="headerlink" title="整数类型的极限值"></a>整数类型的极限值</h4><p>​<strong>有时候需要查看，当前系统不同整数类型的最大值和最小值，C 语言的头文件<code>limits.h</code>提供了相应的常量，</strong>比如<code>SCHAR_MIN</code>代表 signed char 类型的最小值<code>-128</code>，<code>SCHAR_MAX</code>代表 signed char 类型的最大值<code>127</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, SCHAR_MIN); <span class="comment">// -128</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u&quot;</span>, UINT_MAX); <span class="comment">// 4294967295</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​为了代码的可移植性，需要知道某种整数类型的极限值时，应该尽量使用这些常量。</p><ul><li><code>SCHAR_MIN</code>，<code>SCHAR_MAX</code>：signed char 的最小值和最大值。</li><li><code>SHRT_MIN</code>，<code>SHRT_MAX</code>：short 的最小值和最大值。</li><li><code>INT_MIN</code>，<code>INT_MAX</code>：int 的最小值和最大值。</li><li><code>LONG_MIN</code>，<code>LONG_MAX</code>：long 的最小值和最大值。</li><li><code>LLONG_MIN</code>，<code>LLONG_MAX</code>：long long 的最小值和最大值。</li><li><code>UCHAR_MAX</code>：unsigned char 的最大值。</li><li><code>USHRT_MAX</code>：unsigned short 的最大值。</li><li><code>UINT_MAX</code>：unsigned int 的最大值。</li><li><code>ULONG_MAX</code>：unsigned long 的最大值。</li><li><code>ULLONG_MAX</code>：unsigned long long 的最大值。</li></ul><h4 id="整数的进制"><a href="#整数的进制" class="headerlink" title="整数的进制"></a>整数的进制</h4><p>​C 语言的整数默认都是十进制数，如果要表示八进制数和十六进制数，必须使用专门的表示法。</p><p>​八进制使用<code>0</code>作为前缀，十六进制使用<code>0x</code>或<code>0X</code>作为前缀，有些编译器使用<code>0b</code>前缀，表示二进制数，但不是标准。</p><p><strong>注意，不同的进制只是整数的书写方法，不会对整数的实际存储方式产生影响。所有整数都是二进制形式存储，跟书写方式无关。不同进制可以混合使用，比如<code>10 + 015 + 0x20</code>是一个合法的表达式。</strong></p><p>​<code>printf()</code>的进制相关占位符如下。</p><ul><li><code>%d</code>：十进制整数。</li><li><code>%o</code>：八进制整数。</li><li><code>%x</code>：十六进制整数。</li><li><code>%#o</code>：显示前缀<code>0</code>的八进制整数。</li><li><code>%#x</code>：显示前缀<code>0x</code>的十六进制整数。</li><li><code>%#X</code>：显示前缀<code>0X</code>的十六进制整数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;dec = %d\n&quot;</span>, x); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;octal = %o\n&quot;</span>, x); <span class="comment">// 144</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hex = %x\n&quot;</span>, x); <span class="comment">// 64</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;octal = %#o\n&quot;</span>, x); <span class="comment">// 0144</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hex = %#x\n&quot;</span>, x); <span class="comment">// 0x64</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hex = %#X\n&quot;</span>, x); <span class="comment">// 0X64</span></span><br></pre></td></tr></table></figure><h3 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h3><p>​任何有小数点的数值，都会被编译器解释为浮点数。<strong>所谓“浮点数”就是使用 m * b ^ e 的形式，存储一个数值，<code>m</code>是小数部分，<code>b</code>是基数（通常是<code>2</code>），<code>e</code>是指数部分。</strong>这种形式是精度和数值范围的一种结合，可以表示非常大或者非常小的数。</p><p>​浮点数的类型声明使用<code>float</code>关键字，可以用来声明浮点数变量。**<code>float</code>类型占用4个字节（32位），其中8位存放指数的值和符号，剩下24位存放小数的值和符号。<code>float</code>类型至少能够提供（十进制的）6位有效数字，指数部分的范围为（十进制的）<code>-37</code>到<code>37</code>，即数值范围为<code>10 ^ -37</code>到<code>10 ^ 37</code>。**</p><p>这里解释一下上面这段话：</p><p>​<strong>首先<code>float</code>范围是3.4E-38 ——3.4E+38，可提供7位有效数字，上述这两个量都是近似值，各个编译器不太一样的。</strong></p><p>​浮点数在机内用指数型式表示，分解为：<strong>数符，尾数，指数符，指数</strong>四部分。</p><p>​数符占 1 位二进制，表示数的正负。</p><p>​指数符占 1 位二进制，表示指数的正负。</p><p>​尾数表示浮点数有效数字，0.xxxxxxx, 但不存开头的 0 和点。</p><p>​指数存指数的有效数字。</p><p>​指数占多少位，尾数占多少位，由计算机系统决定。</p><p><img src="C:\Users\葛忠洋\Pictures\笔记资料图\20191204085148226.png"></p><p>​<em>float—第31位(占1bit)—第30-23位(占8bit)—-第22-0位(占23bit)</em> </p><p><strong>取值范围主要看指数部分：</strong></p><p>​<code>float</code>的指数部分有8bit(2^8)，由于是有符号型，所以得到对应的指数范围-128~128。</p><p>​由于<code>float</code>的指数部分对应的指数范围为-128~128，所以取值范围为： </p><p>​-2^128到2^128，约等于-3.4E38 — +3.4E38 </p><p><img src="C:\Users\葛忠洋\Pictures\笔记资料图\QQ图片20221101220843.png"></p><p><strong>精度（有效数字）主要看尾数部分：</strong></p><p>​<code>float</code>的尾数位是23bit，对应7~8位十进制数，所以有效数字有的编译器是7位，也有的是8位。</p><p>​这也是<code>float</code>型变量的值，总显示小数点后六位的原因。</p><p><img src="C:\Users\葛忠洋\Pictures\笔记资料图\QQ图片20221101220924.png"></p><p>​有时候，32位浮点数提供的精度或者数值范围还不够，C 语言又提供了另外两种更大的浮点数类型。</p><ul><li><code>double</code>：占用8个字节（64位），至少提供13位有效数字。</li><li><code>long double</code>：通常占用16个字节。</li></ul><p><strong>注意，由于存在精度限制，浮点数只是一个近似值，它的计算是不精确的，比如 C 语言里面<code>0.1 + 0.2</code>并不等于<code>0.3</code>，而是有一个很小的误差。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>​<strong>C 语言允许使用科学计数法表示浮点数，使用字母<code>e</code>来分隔小数部分和指数部分。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x = <span class="number">123.456e+3</span>; <span class="comment">// 123.456 x 10^3</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">double</span> x = <span class="number">123.456e3</span>;</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>e</code>后面如果是加号<code>+</code>，加号可以省略。</p><p><strong>注意，科学计数法里面<code>e</code>的前后，不能存在空格。</strong></p><p>​另外，科学计数法的小数部分如果是<code>0.x</code>或<code>x.0</code>的形式，那么<code>0</code>可以省略。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.3E6</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="number">.3E6</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.0E6</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="number">3.E6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意，科学计数法不区分<code>e</code>和<code>E</code>，只有输出时有<code>%e</code>和<code>%E</code>有所区别。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x = <span class="number">0.3e6</span>;</span><br><span class="line"><span class="type">double</span> y = <span class="number">.3E6</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%E\n&quot;</span>, x); <span class="comment">// 3.000000E+005</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%e\n&quot;</span>, y); <span class="comment">// 3.000000e+005</span></span><br></pre></td></tr></table></figure><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>​C 语言原来并没有为布尔值单独设置一个类型，而是<strong>使用整数<code>0</code>表示伪，所有非零值表示真</strong>。</p><p>​C99 标准添加了类型<code>_Bool</code>，表示布尔值。但是，这个类型其实只是整数类型的别名，还是使用<code>0</code>表示伪，<code>1</code>表示真。</p><p>​头文件<code>stdbool.h</code>定义了另一个类型别名<code>bool</code>，并且定义了<code>true</code>代表<code>1</code>、<code>false</code>代表<code>0</code>。只要加载这个头文件，就可以使用这几个关键字。</p><p><strong>注意，部分版本的vc6.0只要加载<code>stdio.h</code>这个头文件，便可以直接使用<code>bool</code>，<code>true</code>和<code>false</code>这几个关键字，但vc6.0不可以使用<code>_Bool</code>，以及找不到头文件<code>stdbool.h</code>。</strong></p><h3 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h3><p>​字面量（literal）指的是代码里面直接出现的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>​上面代码中，<code>x</code>是变量，<code>123</code>就是字面量。</p><p>​字面量的目的是为了让变量的值简单明了。例如<code>int a=-1</code>，这里<code>a</code>是变量,<code>-1</code>是字面量，对于人类而言，<code>-1</code>这个值很好理解，而<code>-1</code>在计算机中存储的值是<code>0xffffffff</code>，对于C语言来说<code>int a=-1</code> 和 <code>int a=0xffffffff </code>是等价的，但是<code>0xffffffff</code>对于人类而言不是很好理解。</p><p>​编译时，字面量也会写入内存，因此编译器必须为字面量指定数据类型，就像必须为变量指定数据类型一样。</p><p>​一般情况下，十进制整数字面量（比如<code>123</code>）会被编译器指定为<code>int</code>类型。如果一个数值比较大，超出了<code>int</code>能够表示的范围，编译器会将其指定为<code>long int</code>。如果数值超过了<code>long int</code>，会被指定为<code>unsigned long</code>。如果还不够大，就指定为<code>long long</code>或<code>unsigned long long</code>。小数（比如<code>3.14</code>）会被指定为<code>double</code>类型。</p><p>​有时候，程序员希望为字面量指定一个不同的类型。比如，编译器将一个整数字面量指定为<code>int</code>类型，但是程序员希望将其指定为<code>long</code>类型，这时可以为该字面量加上后缀<code>l</code>或<code>L</code>，编译器就知道要把这个字面量的类型指定为<code>long</code>。</p><p>​总结一下，常用的字面量后缀有下面这些。</p><ul><li><code>f</code>和<code>F</code>：<code>float</code>类型。</li><li><code>l</code>和<code>L</code>：对于整数是<code>long int</code>类型，对于小数是<code>long double</code>类型。</li><li><code>ll</code>和<code>LL</code>：Long Long 类型，比如<code>3LL</code>。</li><li><code>u</code>和<code>U</code>：表示<code>unsigned int</code>，比如<code>15U</code>、<code>0377U</code>。</li><li><code>h</code>和<code>H</code>：表示16进制</li><li><code>b</code>和<code>B</code>：表示2进制</li></ul><h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><p>​每一种数据类型都有数值范围，如果存放的数值超出了这个范围（小于最小值或大于最大值），需要更多的二进制位存储，就会发生溢出。大于最大值，叫做向上溢出（overflow）；小于最小值，叫做向下溢出（underflow）。</p><p>​<strong>一般来说，编译器不会对溢出报错，会正常执行代码，但是会忽略多出来的二进制位，只保留剩下的位，这样往往会得到意想不到的结果。</strong>所以，应该避免溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> x = <span class="number">255</span>;</span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>​上面示例中，变量<code>x</code>加<code>1</code>，得到的结果不是<code>256</code>，而是<code>0</code>。因为<code>x</code>是<code>unsign char</code>类型，最大值是<code>255</code>（二进制<code>11111111</code>），加<code>1</code>后就发生了溢出，<code>256</code>（二进制<code>100000000</code>）的最高位<code>1</code>被丢弃，剩下的值就是<code>0</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ui = UINT_MAX;  <span class="comment">// 4,294,967,295</span></span><br><span class="line"></span><br><span class="line">ui++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ui = %u\n&quot;</span>, ui); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">ui--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ui = %u\n&quot;</span>, ui); <span class="comment">// 4,294,967,295</span></span><br></pre></td></tr></table></figure><p>​上面示例中，常量<code>UINT_MAX</code>是 unsigned int 类型的最大值。如果加<code>1</code>，对于该类型就会溢出，从而得到<code>0</code>；而<code>0</code>是该类型的最小值，再减<code>1</code>，又会得到<code>UINT_MAX</code>。(测试需要加上头文件<code>limits.h</code>)</p><p>​<strong>溢出很容易被忽视，编译器又不会报错，所以必须非常小心。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = n; i &gt;= <span class="number">0</span>; --i) <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>​上面代码表面看似乎没有问题，但是循环变量<code>i</code>的类型是 unsigned int，这个类型的最小值是<code>0</code>，不可能得到小于<code>0</code>的结果。当<code>i</code>等于<code>0</code>，再减去<code>1</code>的时候，并不会返回<code>-1</code>，而是返回 unsigned int 的类型最大值，这个值总是大于等于<code>0</code>，导致无限循环。</p><p>​<strong>为了避免溢出，最好方法就是将运算结果与类型的极限值进行比较。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ui;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">if</span> (sum + ui &gt; UINT_MAX) too_big();</span><br><span class="line"><span class="keyword">else</span> sum = sum + ui;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">if</span> (ui &gt; UINT_MAX - sum) too_big();</span><br><span class="line"><span class="keyword">else</span> sum = sum + ui;</span><br></pre></td></tr></table></figure><p>​上面示例中，变量<code>sum</code>和<code>ui</code>都是 unsigned int 类型，它们相加的和还是 unsigned int 类型，这就有可能发生溢出。</p><p>​但是，不能通过相加的和是否超出了最大值<code>UINT_MAX</code>，来判断是否发生了溢出，因为<code>sum + ui</code>总是返回溢出后的结果，不可能大于<code>UINT_MAX</code>。正确的比较方法是，判断<code>UINT_MAX - sum</code>与<code>ui</code>之间的大小关系。</p><p>​下面是另一种错误的写法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i - j &lt; <span class="number">0</span>) <span class="comment">// 错误</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;negative\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;positive\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>​上面示例的运算结果，会输出<code>positive</code>。原因是变量<code>i</code>和<code>j</code>都是 unsigned int 类型，<code>i - j</code>的结果也是这个类型，最小值为<code>0</code>，不可能得到小于<code>0</code>的结果。正确的写法是写成下面这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (j &gt; i) <span class="comment">// ....</span></span><br></pre></td></tr></table></figure><h3 id="sizeof-运算符"><a href="#sizeof-运算符" class="headerlink" title="sizeof 运算符"></a>sizeof 运算符</h3><p>​<code>sizeof</code>是 C 语言提供的一个运算符，返回某种数据类型或某个值占用的字节数量。这里主要讨论其返回值问题。</p><p>​<strong><code>sizeof</code>运算符的返回值，C 语言只规定是无符号整数，并没有规定具体的类型，而是留给系统自己去决定，<code>sizeof</code>到底返回什么类型。</strong>不同的系统中，返回值的类型有可能是<code>unsigned int</code>，也有可能是<code>unsigned long</code>，甚至是<code>unsigned long long</code>，对应的<code>printf()</code>占位符分别是<code>%u</code>、<code>%lu</code>和<code>%llu</code>。这样不利于程序的可移植性。</p><p>​C 语言提供了一个解决方法，创造了一个类型别名<code>size_t</code>，用来统一表示<code>sizeof</code>的返回值类型。该别名定义在<code>stddef.h</code>头文件（引入<code>stdio.h</code>时会自动引入）里面，对应当前系统的<code>sizeof</code>的返回值类型，可能是<code>unsigned int</code>，也可能是<code>unsigned long</code>。</p><p>​C 语言还提供了一个常量<code>SIZE_MAX</code>，表示<code>size_t</code>可以表示的最大整数。所以，<code>size_t</code>能够表示的整数范围为<code>[0, SIZE_MAX]</code>。</p><p>​<code>printf()</code>有专门的占位符<code>%zd</code>或<code>%zu</code>，用来处理<code>size_t</code>类型的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><p>​上面代码中，不管<code>sizeof</code>返回值的类型是什么，<code>%zd</code>占位符（或<code>%zu</code>）都可以正确输出。</p><p>​如果当前系统不支持<code>%zd</code>或<code>%zu</code>，可使用<code>%u</code>（unsigned int）或<code>%lu</code>（unsigned long int）代替。</p><p>​<strong>注意，vc6.0里不支持上述操作。</strong></p><h2 id="类型的转换"><a href="#类型的转换" class="headerlink" title="类型的转换"></a>类型的转换</h2><h3 id="类型的自动转换"><a href="#类型的自动转换" class="headerlink" title="类型的自动转换"></a>类型的自动转换</h3><h3 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h3><p>​<strong>赋值运算符会自动将右边的值，转成左边变量的类型。</strong></p><ol><li><p>浮点数赋值给整数变量<br>浮点数赋予整数变量时，C 语言直接丢弃小数部分，而不是四舍五入。</p></li><li><p>整数赋值给浮点数变量<br>整数赋值给浮点数变量时，会自动转为浮点数。</p></li><li><p>窄类型赋值给宽类型<br>字节宽度较小的整数类型，赋值给字节宽度较大的整数变量时，会发生类型提升，即窄类型自动转为宽类型。</p></li><li><p>宽类型赋值给窄类型<br>字节宽度较大的类型，赋值给字节宽度较小的变量时，会发生类型降级，自动转为后者的类型。<strong>这时可能会发生截值（truncation），系统会自动截去多余的二进制位，导致难以预料的结果。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">321</span>;</span><br><span class="line"><span class="type">char</span> ch = i; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ch); <span class="comment">// ch 的值是 65 （321 - 256）</span></span><br></pre></td></tr></table></figure><p>上面例子中，变量<code>ch</code>是<code>char</code>类型，宽度是8个二进制位。变量<code>i</code>是<code>int</code>类型，将<code>i</code>赋值给<code>ch</code>，后者只能容纳<code>i</code>（二进制形式为<code>101000001</code>，共9位）的后八位，前面多出来的二进制位被丢弃，保留后八位就变成了<code>01000001</code>（十进制的65，相当于字符<code>A</code>）。</p><p>浮点数赋值给整数类型的值，也会发生截值，浮点数的小数部分会被截去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">int</span> i = pi;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i); <span class="comment">// i 的值为 3</span></span><br></pre></td></tr></table></figure><p>上面示例中，<code>i</code>等于<code>3</code>，<code>pi</code>的小数部分被截去了。</p></li></ol><h3 id="混合类型运算"><a href="#混合类型运算" class="headerlink" title="混合类型运算"></a>混合类型运算</h3><ol><li><p>整数与浮点数混合运算时，整数转为浮点数类型，与另一个运算数类型相同。</p></li><li><p>整数与浮点数混合运算时，整数转为浮点数类型，与另一个运算数类型相同。</p></li><li><p><strong>不同的整数类型混合运算时，宽度较小的类型会提升为宽度较大的类型。</strong></p><p>下面例子的执行结果，可能会出人意料。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">-5</span>;</span><br><span class="line"><span class="keyword">if</span> (a &lt; <span class="keyword">sizeof</span>(<span class="type">int</span>))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure><p>​上面示例中，变量<code>a</code>是带符号整数，<code>sizeof(int)</code>是<code>size_t</code>类型，这是一个无符号整数。按照规则，signed int 自动转为 unsigned int，所以<code>a</code>会自动转成无符号整数<code>4294967291</code>（转换规则是<code>-5</code>加上无符号整数的最大值，再加1），导致比较失败，<code>printf(&quot;1&quot;);</code>不会执行。</p><p>​<strong>所以，最好避免无符号整数与有符号整数的混合运算。因为这时 C 语言会自动将<code>signed int</code>转为<code>unsigned int</code>，可能不会得到预期的结果。</strong></p><h3 id="整数类型的运算"><a href="#整数类型的运算" class="headerlink" title="整数类型的运算"></a>整数类型的运算</h3><p>​<strong>两个相同类型的整数运算时，或者单个整数的运算，一般来说，运算结果也属于同一类型。但是有一个例外，宽度小于<code>int</code>的类型，运算结果会自动提升为<code>int</code>。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">66</span>;</span><br><span class="line"><span class="keyword">if</span> ((-a) &lt; <span class="number">0</span>) </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;negative\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;positive\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>​上面示例中，变量<code>a</code>是 unsigned char 类型，这个类型不可能小于<code>0</code>，但是<code>-a</code>不是 unsigned char 类型，会自动转为 int 类型，导致上面的代码输出 <code>negative</code>。</p><p>​再看下面的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> b = <span class="number">255</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((a - <span class="number">5</span>) &lt; <span class="number">0</span>) </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ((b + c) &gt; <span class="number">300</span>) </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>​上面示例中，表达式<code>a - 5</code>和<code>b + c</code>都会自动转为 int 类型，所以函数<code>printf(&quot;1\n&quot;)</code>会执行两次。</p><h3 id="函数中的自动转换"><a href="#函数中的自动转换" class="headerlink" title="函数中的自动转换"></a>函数中的自动转换</h3><p>​<strong>函数的参数和返回值，会自动转成函数定义里指定的类型。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dostuff</span><span class="params">(<span class="type">int</span>, <span class="type">unsigned</span> <span class="type">char</span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> m = <span class="number">42</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> n = <span class="number">43</span>;</span><br><span class="line"><span class="type">long</span> c = dostuff(m, n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, c); <span class="comment">// 2147483647</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型的显示转换"><a href="#类型的显示转换" class="headerlink" title="类型的显示转换"></a>类型的显示转换</h3><p>​原则上，应该避免类型的自动转换，防止出现意料之外的结果。C 语言提供了类型的显式转换，允许手动转换类型。</p><p>​<strong>只要在一个值或变量的前面，使用圆括号指定类型<code>(type)</code>，就可以将这个值或变量转为指定的类型，这叫做“类型指定”（casting）。</strong></p><p>​<strong>一般而言赋值运算不需要进行显示转换，但是动态内存分配后，赋值给指针变量时必需进行显示转换。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> y = (<span class="type">long</span> <span class="type">int</span>) <span class="number">10</span> + <span class="number">12</span>; <span class="comment">// right</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">int</span> y = <span class="number">10</span> + <span class="number">12</span>; <span class="comment">// right</span></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>(long int)</code>将<code>10</code>显式转为<code>long int</code>类型。这里的显示转换其实是不必要的，因为赋值运算符会自动将右边的值，转为左边变量的类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *a = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *a = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// right</span></span><br></pre></td></tr></table></figure><h3 id="可移植类型"><a href="#可移植类型" class="headerlink" title="可移植类型"></a>可移植类型</h3><p>​C 语言的整数类型（short、int、long）在不同计算机上，占用的字节宽度可能是不一样的，无法提前知道它们到底占用多少个字节。</p><p>​程序员有时控制准确的字节宽度，这样的话，代码可以有更好的可移植性，头文件<code>stdint.h</code>创造了一些新的类型别名。</p><p>​注意，vc6.0不包含头文件<code>stdint.h</code>，故一下不给出测试样例，只做简单介绍。</p><ol><li>精确宽度类型(exact-width integer type)，保证某个整数类型的宽度是确定的。</li></ol><ul><li><code>int8_t</code>：8位有符号整数。</li><li><code>int16_t</code>：16位有符号整数。</li><li><code>int32_t</code>：32位有符号整数。</li><li><code>int64_t</code>：64位有符号整数。</li><li><code>uint8_t</code>：8位无符号整数。</li><li><code>uint16_t</code>：16位无符号整数。</li><li><code>uint32_t</code>：32位无符号整数。</li><li><code>uint64_t</code>：64位无符号整数。</li></ul><p>​上面这些都是类型别名，编译器会指定它们指向的底层类型。比如，某个系统中，如果<code>int</code>类型为32位，<code>int32_t</code>就会指向<code>int</code>；如果<code>long</code>类型为32位，<code>int32_t</code>则会指向<code>long</code>。</p><ol start="2"><li>最小宽度类型（minimum width type），保证某个整数类型的最小长度。</li></ol><ul><li>int_least8_t</li><li>int_least16_t</li><li>int_least32_t</li><li>int_least64_t</li><li>uint_least8_t</li><li>uint_least16_t</li><li>uint_least32_t</li><li>uint_least64_t</li></ul><p>​上面这些类型，可以保证占据的字节不少于指定宽度。比如，<code>int_least8_t</code>表示可以容纳8位有符号整数的最小宽度的类型。</p><ol start="3"><li>最快的最小宽度类型（fast minimum width type），可以使整数计算达到最快的类型。</li></ol><ul><li>int_fast8_t</li><li>int_fast16_t</li><li>int_fast32_t</li><li>int_fast64_t</li><li>uint_fast8_t</li><li>uint_fast16_t</li><li>uint_fast32_t</li><li>uint_fast64_t</li></ul><p>​上面这些类型是保证字节宽度的同时，追求最快的运算速度，比如<code>int_fast8_t</code>表示对于8位有符号整数，运算速度最快的类型。这是因为某些机器对于特定宽度的数据，运算速度最快，举例来说，32位计算机对于32位数据的运算速度，会快于16位数据。</p><ol start="4"><li>可以保存指针的整数类型。</li></ol><ul><li><code>intptr_t</code>：可以存储指针（内存地址）的有符号整数类型。</li><li><code>uintptr_t</code>：可以存储指针的无符号整数类型。</li></ul><ol start="5"><li>最大宽度整数类型，用于存放最大的整数。</li></ol><ul><li><code>intmax_t</code>：可以存储任何有效的有符号整数的类型。</li><li><code>uintmax_t</code>：可以存放任何有效的无符号整数的类型。</li></ul><p>​上面的这两个类型的宽度比<code>long long</code>和<code>unsigned long</code>更大。</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="内存四区"><a href="#内存四区" class="headerlink" title="内存四区"></a>内存四区</h3><p>​内存被分为四个区，分别是代码区，静态&#x2F;全局区，栈区和堆区。</p><h4 id="四区介绍"><a href="#四区介绍" class="headerlink" title="四区介绍"></a>四区介绍</h4><ul><li><strong>堆区（heap）</strong>：一般<strong>由程序员手动分配释放</strong>（动态内存申请与释放），若程序员不释放，程序结束时由操作系统回收。</li><li><strong>栈区（stack）</strong>：由<strong>编译器自动分配释放</strong>，<strong>存放函数的形参、局部变量等</strong>。当<strong>函数执行完毕时自动释放</strong>。</li><li><strong>全局区（global &#x2F; stack）</strong>：用于存<strong>放全局变量和静态变量</strong>，也就是不再函数中声明的变量，它们的<strong>生命周期贯穿整个应用程序</strong>，里面细分有一个常量区，一些常量存放在此。该区域是在程序结束后由操作系统释放。</li><li><strong>代码区（code &#x2F; text）</strong>：用于<strong>存放程序代码</strong>，<strong>字符串常量也存放于此</strong>。</li></ul><p><img src="C:\Users\葛忠洋\Pictures\笔记资料图\QQ图片20221022192039.png" alt="QQ图片20221022192039"></p><p>​（上图为代码段，应用程序的代码段，就是<strong>用来存放从可执行文件拷贝过来（到内存代码段）的机器码或指令</strong>的。）</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol><li><strong>在整个程序运行期间，代码区，静态&#x2F;全局区，栈区的大小是不会增长的。</strong></li><li><strong>程序会为每个函数创造属于这个函数的栈帧。</strong></li><li><strong>在程序未执行结束时，<code>main()</code>函数里分配的空间均可以被其他自定义函数访问。</strong></li><li><strong>自定义函数若在堆区（malloc动态分配内存等）或全局区（常量等）分配的内存，即便此函数结束，这些内存空间也不会被系统回收，内存中的内容可以被其他自定义函数和<code>main()</code>函数使用。</strong></li><li><strong>内存中的栈基本是由数据结构中的栈实现的，而内存中的堆和数据结构中的堆毫无关系。堆可以简单理解为一块大的、可供自由分配释放的内存空间。</strong></li></ol><h3 id="指针所占的内存空间"><a href="#指针所占的内存空间" class="headerlink" title="指针所占的内存空间"></a>指针所占的内存空间</h3><p>​<strong>指针作为一种变量也需要占据一定的内存空间</strong>。</p><p>​由于指<strong>针的值是一个内存地址</strong>，所以指针所占据的内存空间的大小与其指向的数据类型无关，而与<strong>当前机器类型所能寻址的位数</strong>有关。</p><p>​具体来说，在32位的机器上，一个指针（<strong>指向任意类型</strong>）的大小为4个字节，在64位的机器上则为8个字节。</p><h3 id="指针的类型需要明确"><a href="#指针的类型需要明确" class="headerlink" title="指针的类型需要明确"></a>指针的类型需要明确</h3><p>​<strong>指针是强类型的</strong>（即我们需要特定类型的指针来指向特定类型的变量的存放地址。如<code>int*</code>、<code>char*</code>等或者指向自定义结构体和类的指针）。</p><p>​只用来存放地址的指针需要明确其指向的数据类型的原因在于：</p><ul><li>指针不仅可以用来存储内存地址，同时也可以用来<strong>解引用内存地址的内容</strong>。</li><li>不同的数据类型在<strong>所占的内存大小是不一样的</strong>。</li><li>不同的数据类型在<strong>存储信息的方式上也是不同的</strong>（如整型和浮点型）。</li><li><strong>指针存在通用类型<code>void*</code></strong><ol><li>它不针对某个特定的指针类型，在使用时将其<strong>赋值为指向某种特定的数据类型</strong>的指针时<strong>不需要做强制类型转换</strong>。</li><li>由于不知道它指向的类型，因此**不能直接对其进行解引用<code>*p</code><strong>，</strong>也不能对其进行算数运算<code>p+1</code>**。</li></ol></li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>代码展示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1025</span>;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p = &amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of int is %d bytes\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p\t Address = %d, Value=%d\n&quot;</span>, p, *p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p+1\t Address = %d, Value=%d\n&quot;</span>, p+<span class="number">1</span>, *(p+<span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>*p0;</span><br><span class="line">    p0 = (<span class="type">char</span>*)p;  <span class="comment">//  强制类型转换</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of char is %d bytes\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p0\t Address = %d, Value=%d\n&quot;</span>, p0, *p0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p0+1\t Address = %d, Value=%d\n&quot;</span>, p0+<span class="number">1</span>, *(p0+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果展示：</p><p><img src="C:\Users\葛忠洋\AppData\Roaming\Typora\typora-user-images\1666439650902.png" alt="1666439650902"></p><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>​指针的唯一算术运算就是<strong>以整数值大小增加或减少指针值</strong>，如<code>p+1</code>、<code>p-2</code>等。</p><p>​<strong>指针做加1运算，结果取决于其指向的变量类型</strong>，例如一个整型变量在内存中占4个字节， 对 <code>p</code> 执行加1，应该得到的是下一个整型数据的地址，即在地址的数值上面应该加4。而一个字符型变量在内存中占1个字节， 对 <code>p</code> 执行加1，应该得到的是下一个字符型数据的地址，即在地址的数值上面应该加1。</p><p>​根据一字节为八比特，在64位机中，1025的二进制表示为：</p><p>​1025 &#x3D; 00000000  00000000  00000100  00000001</p><p>​如果是整形型指针<code>p</code>，那么系统将会完整的读出整形变量<code>a</code>在这四个字节中的值1025，并且在<code>p+1</code>时读出其四个字节后未被赋值的内存空间里的垃圾值；</p><p>​如果是字符型指针<code>p0</code>，那么系统将会读出整形变量<code>a</code>在其第一个字节中的值1（即00000001），并且在<code>p+1</code>时读出其一个字节后整形变量<code>a</code>在其第二个字节中的值4（即00000100）。</p><h3 id="数组作为函数参数中的指针问题"><a href="#数组作为函数参数中的指针问题" class="headerlink" title="数组作为函数参数中的指针问题"></a>数组作为函数参数中的指针问题</h3><p>​数组与指针重要联系：<strong>数组名就是指向数组首元素的指针</strong>，数组的首元素的地址，也被称为数组的基地址。</p><p>​数组作为函数参数传递的实参就是数组名，这是址传递（即传引用）。</p><p>​<strong>数组名和指针变量的唯一区别是，不能改变数组名指向的地址，即数组名可视为一个指向数组首元素地址的指针常量（下文会解释指针常量）</strong>。</p><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p>​现需设计一个<code>SumOfElements()</code>函数，用来计算传入的数组的元素求和，该函数还需要传入参数<code>size</code>作为数组的元素个数。在<code>main()</code>函数中新建一个数组，并通过<code>sizeof</code>来求得该数组的元素个数，调用该函数求和。</p><p>正确代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">SumOfElements</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">&#123;</span><br><span class="line">        sum += A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> A[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(A[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> total = SumOfElements(A, size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum of elements = %d\n&quot;</span>, total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确结果：</p><p><img src="C:\Users\葛忠洋\AppData\Roaming\Typora\typora-user-images\1666442492016.png" alt="1666442492016"></p><p>错误代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">SumOfElements</span><span class="params">(<span class="type">int</span> A[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(A[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">&#123;</span><br><span class="line">        sum += A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> A[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> total = SumOfElements(A);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum of elements = %d\n&quot;</span>, total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误结果：</p><p><img src="C:\Users\葛忠洋\AppData\Roaming\Typora\typora-user-images\1666442642412.png" alt="1666442642412"></p><h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h4><p>​由之前指针所占的内存大小可以得知，在32位机中，一个指针大小为4字节，而数组作为函数参数传递过去的便是其首地址，即<strong>错误代码中<code>SumOfElements()</code>函数里的<code>A</code>是一个内存大小为4字节的指针</strong>，且数组<code>A</code>是一个整形数组，数组中每个整形变量的大小为4字节，因此<code>size</code>的值求得为1：<code>int size = 4 / 4</code>，循环只执行了1次导致结果为<code>A[0]</code>的值1。</p><p>内存图：</p><p><img src="C:\Users\葛忠洋\Pictures\笔记资料图\d4432abb20cf4bdea36e0dc727187a90.png" alt="d4432abb20cf4bdea36e0dc727187a90"></p><h3 id="字符数组中的指针问题"><a href="#字符数组中的指针问题" class="headerlink" title="字符数组中的指针问题"></a>字符数组中的指针问题</h3><p>​C语言中，字符串和字符数组是一个意思。这里不讨论字符数组里关于’\0’问题的细节，只针对<strong>字符串常量</strong>以引出<strong>常量指针</strong>。</p><p><code>char[]</code> 和 <code>char*</code>的不同之处：</p><h4 id="char"><a href="#char" class="headerlink" title="char[]"></a>char[]</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> C[<span class="number">10</span>] = <span class="string">&quot;葛忠洋&quot;</span>;</span><br></pre></td></tr></table></figure><p>​如果通过字符数组进行初始化，<strong>字符串就会储存在分配给这个数组的内存空间中</strong>，这种情形下<strong>它会被分配在栈区上</strong>。</p><h4 id="char-1"><a href="#char-1" class="headerlink" title="char*"></a>char*</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *C = <span class="string">&quot;葛忠洋&quot;</span>;</span><br></pre></td></tr></table></figure><p>​如果通过字符型指针来声明一个字符串，那么它会是一个<strong>字符串常量</strong>，<strong>通常会被存放在代码区</strong>。</p><p>​作为常量，<strong>它的值不能被更改</strong>，即<code>*C[0]=&#39;A&#39;</code> 是非法的操作。</p><h3 id="指针常量与常量指针"><a href="#指针常量与常量指针" class="headerlink" title="指针常量与常量指针"></a>指针常量与常量指针</h3><h4 id="指针常量——指针类型的常量"><a href="#指针常量——指针类型的常量" class="headerlink" title="指针常量——指针类型的常量"></a>指针常量——指针类型的常量</h4><p>​<code>int *const p</code><br>​本质上一个常量，指针用来说明常量的类型，表示该常量是一个指针类型的常量。<strong>在指针常量中，指针自身的值是一个常量，不可改变，始终指向同一个地址。在定义的同时必须初始化。</strong><br>用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p = &amp;a;</span><br><span class="line">*p = <span class="number">30</span>; <span class="comment">// p指向的地址是一定的，但其内容可以修改</span></span><br></pre></td></tr></table></figure><h4 id="常量指针——指向常量的指针"><a href="#常量指针——指向常量的指针" class="headerlink" title="常量指针——指向常量的指针"></a>常量指针——指向常量的指针</h4><p>​<code>int const *p</code> or <code>const int *p</code></p><p>​本质上是一个指针，常量表示指针指向的内容，说明该指针指向一个“常量”。<strong>在常量指针中，指针指向的内容是不可改变的，指针看起来好像指向了一个常量。</strong><br>用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">// 指针可以指向其他地址，但是内容不可以改变</span></span><br></pre></td></tr></table></figure><h3 id="多维数组作为函数参数中的指针问题"><a href="#多维数组作为函数参数中的指针问题" class="headerlink" title="多维数组作为函数参数中的指针问题"></a>多维数组作为函数参数中的指针问题</h3><p>​<strong>多维数组的本质其实就是数组的数组</strong>，这里不讨论多维数组里指针的取地址<code>&amp;</code>与解引用<code>*</code>等相关操作，只说明多维数组作为函数参数的注意事项。</p><p>​多维数组做函数参数时，<strong>数组的第一个维度可以省略，但是其他维度必须指定</strong>。</p><p>​对一个需要接收二维数组的参数，将函数签名声明为<code>void func(int **A)</code> 是不可行的，因为这样没有指定任何数组维度。</p><p>​<strong>在调用时要正确地传递参数数组的类型</strong>，即实参要与形参数据类型相同且<strong>各维的大小相同</strong>。</p><p>以二维数组做参数为例，有以下两种形参写法：</p><ul><li><code>void text(int (*A)[3])</code></li><li><code>void text(int A[][3])</code></li></ul><h3 id="动态内存分配中的指针问题"><a href="#动态内存分配中的指针问题" class="headerlink" title="动态内存分配中的指针问题"></a>动态内存分配中的指针问题</h3><p>​<strong>C语言提供了四个函数用于动态内存分配</strong>，分别是：</p><p>​<code>malloc()</code>，<code>calloc()</code>，<code>realloc()</code>，<code>free()</code>。</p><h4 id="动态内存分配函数与内存（以malloc函数为例）"><a href="#动态内存分配函数与内存（以malloc函数为例）" class="headerlink" title="动态内存分配函数与内存（以malloc函数为例）"></a>动态内存分配函数与内存（以<code>malloc</code>函数为例）</h4><p>​<code>malloc</code>函数从<strong>堆上</strong>找到一块给定大小的空闲的内存，并<strong>将指向起始地址的<code>void *</code>指针返回给程序</strong>，程序员应当根据需要做适当的指针数据类型的转换。</p><p>​<strong>向堆上写值的唯一方法就是使用解引用</strong>，因为<code>malloc</code>返回的总是一个指针。<strong>如果<code>malloc</code>无法在堆区上找到足够大小的空闲内存，则会返回<code>NULL</code>。</strong></p><p>​<strong>程序员用<code>malloc</code>在堆上申请的内存空间不会被程序自动释放</strong>，因此程序员在堆上申请内存后，一定要记得自己手动<code>free</code>释放。</p><p>​<code>free</code>接收一个<strong>指向堆区某地址的指针作为参数</strong>，并将对应的堆区的内存空间释放。</p><h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><ul><li>**函数签名：<code>void* malloc(size_t size)</code>*<em>。函数接收一个参数size，返回的void</em>指针指向了分配给我们的内存块中的第一个字节的地址。</li><li><strong>void*类型的指针只能指明地址值，但是无法用于解引用</strong>，所以通常我们需要对返回的指针做强制类型转换，转换成我们需要的指针类型。</li><li>通常我们不显式地给出参数size的值，而是通过sizeof，再乘上我们需要的元素个数，计算出我们需要的内存空间的大小。</li></ul><h4 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h4><ul><li>**函数签名：<code>void *calloc(size_t num, size_t size)</code>**。函数接收两个参数<code>num</code>，<code>size</code>，分别表示特定类型的元素的数量，和类型的大小。同样返回一个<code>void*</code>类型的指针。</li><li><code>calloc</code>与<code>malloc</code>的另一个区别是：**<code>malloc</code>分配完内存后不会对其进行初始化，<code>calloc</code>分配完内存后会将值初始化位0**。</li></ul><h4 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h4><ul><li><strong>函数签名：<code>void* realloc(void* ptr, size_t size)</code><strong>。函数接收两个参数，</strong>第一个是指向已经分配的内存的起始地址的指针</strong>，第二个是要新分配的内存大小。返回<code>void*</code>指针。<strong>可能扩展原来的内存块，也可能另找一块大内存拷贝过去，如果是缩小的话，就会是原地缩小</strong>。</li><li><strong><code>realloc</code>的两种特殊用法</strong><ol><li>充当<code>malloc</code><br><code>int* B = (int*)realloc(NULL, sizeof(int));</code></li><li>充当<code>free</code><br><code>int* B = (int*)realloc(A, 0);</code></li></ol></li></ul><h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><ul><li>**函数签名：<code>*void free(void *ptr)</code>**。<code>ptr</code>指针指向一个要释放内存的内存块，该内存块之前是通过调用 malloc、calloc 或 realloc 进行分配内存的。如果传递的参数是一个空指针，则不会执行任何动作。</li><li><strong>已经没有用的堆区内存如果不使用<code>free</code>进行手动释放会造成内存泄漏</strong>。</li></ul><h3 id="堆区与栈区的不同以及内存泄漏"><a href="#堆区与栈区的不同以及内存泄漏" class="headerlink" title="堆区与栈区的不同以及内存泄漏"></a>堆区与栈区的不同以及内存泄漏</h3><h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">allocate_stack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Arr[<span class="number">10000</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">allocate_heap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* Arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10000</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&#x27;0&#x27; to break, &#x27;1&#x27; to continue\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c);</span><br><span class="line">        <span class="keyword">if</span> (!c) </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">            allocate_heap();</span><br><span class="line">allocate_stack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>​在主函数上调用<code>allocate_stack</code>或者<code>allocate_heap</code>，两者的区别是<strong>一个在栈上开辟一个数组并直接返回</strong>，<strong>另一个在堆区开辟一个数组并且不释放返回</strong>。</p><p>​在主函数中死循环询问是否继续开辟数组，得到继续开辟数组的命令后开辟100个数组。通过<code>top</code>指令可以发现<code>allocate_stack</code>的内存占用在<strong>每次开辟数组后骤增，然后掉下去</strong>，而<code>allocate_heap</code>的内存占用<strong>每次骤增后也不掉下去，直到内存占用过大被操作系统kill掉。</strong></p><h4 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a>解释</h4><p>内存图：</p><p><code>allocate_stack</code></p><p><img src="C:\Users\葛忠洋\Pictures\笔记资料图\4fbc6727b8ec4537af14b38de4818368.png" alt="4fbc6727b8ec4537af14b38de4818368"></p><p>​对于调用<code>allocate_stack</code>的程序，在<code>allocate_stack</code>函数调用时，每次将数组创建在栈区，这样在<strong>函数返回之后，程序自动将其栈帧释放，数组也被释放掉，不会占用内存</strong>。</p><p><code>allocate_heap</code></p><p><img src="C:\Users\葛忠洋\Pictures\笔记资料图\36560aa234e4423f84fda1c489401ac5.png" alt="36560aa234e4423f84fda1c489401ac5"></p><p>​对于调用<code>allocate_heap</code>的程序，每次调用<code>allocate_heap</code>在堆区开辟一个数组<code>Arr</code>，在栈上只创建了一个指针<code>p</code>来指向这个堆区数组，这样在<strong>函数返回之后，堆区数组并<code>Arr</code>没有被释放，但是函数栈帧上的指针<code>p</code>被程序释放掉了，导致没有办法再去释放堆区的数组<code>Arr</code>。</strong></p><p>​这样随着函数调用次数越来越多，<strong>这些堆区的数组都处于已分配但无法引用也无法使用的状态</strong>。<strong>而堆区大小又是不固定的，可以一直向操作系统申请</strong>，终有一天，会超过内存上限，被系统kill掉，这就是内存泄漏。</p><h3 id="指针函数与栈区"><a href="#指针函数与栈区" class="headerlink" title="指针函数与栈区"></a>指针函数与栈区</h3><h4 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">Add</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c = (*a) + (*b);</span><br><span class="line">    <span class="keyword">return</span> &amp;c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printHello</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">2</span>, y = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span>* ptr = Add(&amp;x, &amp;y);</span><br><span class="line">  <span class="comment">// printHello();</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum = %d\n&quot;</span>, *ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在主函数里调用函数<code>Add</code>来求得<code>x</code>和<code>y</code>的合，函数的返回值是一个指针，如果正常运行那么最终结果<strong>在编译不报错的情况下</strong>是6，但是<strong>如果在打印结果之前再多调用一个函数<code>printHello</code>，则必定会导致输出错误</strong>。</p><h4 id="解释-3"><a href="#解释-3" class="headerlink" title="解释"></a>解释</h4><p>内存图：（程序不涉及堆区，故不作出）</p><p><img src="C:\Users\葛忠洋\Pictures\笔记资料图\d315c4442b2b4828ad5f71d2d4c6af47.png" alt="d315c4442b2b4828ad5f71d2d4c6af47"></p><p>​首先，<code>main</code>函数在调用函数<code>Add</code>时，有函数<code>Add</code>自己的栈帧，其中存放两个传入的指向整型的指针<code>a</code>，<code>b</code>，指向<code>main</code>函数栈帧中的加和对象，即两个整型变量<code>x</code>，<code>y</code>，函数<code>Add</code>的栈帧中还有一个整型变量<code>c</code>，是加和的结果，<code>Add</code>函数返回一个整型指针指向变量<code>c</code>，即<code>main</code>中的<code>ptr</code>。</p><p>​与此同时，问题也会出现，<strong>在<code>Add</code>函数返回之后，它在栈区上的栈帧也被程序自动释放了，这个时候，原来存放整型变量<code>c</code>的150这个内存地址中的值就已经是未知的了，访问未知的内存是极其危险的，甚至是不被允许的（编译报错）</strong>。</p><p>​<strong>如果在<code>Add</code>函数返回之后，没有调用其他任何函数，直接对150这个内存地址解引用，有可能能够打印出正确的结果，因为编译器没有对释放的栈帧进行其他处理。但是如果调用了其他函数，如<code>printHello</code>，即使该函数中没有任何看得到的参数，但也需要保存一些返回地址、寄存器现场等参数，因此也会在栈区占用一块作为自己的栈帧。这时，内存位置150几乎是肯定被重写了，这样<code>Add</code>函数即使通过编译也将无法得到预期的结果</strong>。</p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ul><li><p>无论如何，<strong>访问未知内存地址的行为是一定要杜绝的</strong>，即使可以通过编译，也不能寄希望于偶然的正确结果。</p></li><li><p><strong>返回被调函数在栈区的局部变量的指针是危险的</strong>。通常，我们可以安全地返回<strong>堆区或者全局区</strong>的内存指针，因为它们不会被程序自动地释放。</p></li><li><p>在上述案例中，，<code>main</code>函数也通过传引用的形式将地址传递给了<code>Add</code>函数，但这是没问题的，<strong>因为<code>Add</code>函数调用时，<code>main</code>函数的栈帧还是在原来的内存位置</strong>，这是已知的，可以进行访问。</p></li><li><p><strong>在栈区中，栈底向上传参数是可以的，从栈底向上传一个局部变量或者一个局部变量的地址是可以的。但是栈顶向下传参数是不可以的，从栈顶向下传一个局部变量或者一个局部变量的地址也是不可以的</strong>。</p></li><li><p><strong>C&#x2F;C++中的<code>main</code>函数是可以自由地向被调函数传引用的，因为<code>main</code>函数始终处于栈区的栈底</strong>。</p></li><li><p>上述代码如果改写成在堆区分配内存，就可以安全稳定的完成目的<br><strong>于此同时，这也是为什么LeetCode等在线做题平台，对于答案是多个结果时，需要分配内存空间来建立数组存放答案并返回的原因。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">Add</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* c = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *c = (*a) + (*b);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\葛忠洋\Pictures\笔记资料图\deb92ec55edf46ce9d6eae271ec4aa73.png" alt="deb92ec55edf46ce9d6eae271ec4aa73"></p></li></ul><h3 id="函数指针与代码区"><a href="#函数指针与代码区" class="headerlink" title="函数指针与代码区"></a>函数指针与代码区</h3><h4 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h4><p><img src="C:\Users\葛忠洋\Pictures\笔记资料图\425c8092812e4a5ca37ceefebed41071.png" alt="425c8092812e4a5ca37ceefebed41071"></p><p>​如上图所示，假设一条指令占4个字节，在内存中，<strong>一个函数就是一块连续的内存</strong>（其中存放的不是数据，而是指令）。</p><p>​<strong>指令通常都是顺序执行的，直到发生跳转</strong>（如函数调用，函数返回），会根据指令调到指定的地址执行。假设图中蓝色区域（指令02 - 指令 05，地址208 - 220）是一个函数，指令00是一条跳转指令，调用了蓝色区域的函数，程序就会从200跳转到208执行。</p><p>​函数的<strong>起始地址</strong>（比如208），被称为函数的<strong>入口点</strong>，它是<strong>函数的第一条指令的地址</strong>。</p><h4 id="函数指针的注意事项"><a href="#函数指针的注意事项" class="headerlink" title="函数指针的注意事项"></a>函数指针的注意事项</h4><p>案例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">    p = &amp;Add;</span><br><span class="line">    c = (*p)(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>声明函数指针的语法是：<code>int (*p)(int, int)</code>，这条语句声明了一个接收两个整型变量作为参数，并且返回一个整型变量的函数指针。<strong>注意函数指针可以指向一类函数，即可以说，指针p指向的类型是输入两整型，输出一整型的这一类函数，即所有满足这个签名的函数，都可以赋值给p这个函数指针</strong>。</p></li><li><p>函数指针赋值：<code>p = &amp;Add</code>，将函数名为<code>Add</code>的函数指针赋值给<code>p</code>。**同样注意只要满足<code>p</code>声明时的函数签名的函数名都可以赋值给<code>p</code>**。</p></li><li><p>函数指针的使用：<code>int c = (*p)(2, 3)</code>，**先对<code>p</code>解引用得到函数<code>Add</code>**，然后正常传参和返回即可。</p></li><li><p><strong>在为函数指针赋值时，可以不用取地址符号<code>&amp;</code>，仅用函数名同样会返回正确的函数地址。与之匹配的，在调用函数的时候也不需要再解引用。这种用法更加常见</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">p = Add;</span><br><span class="line">c = p(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>​回调函数的本质即是：<strong>函数指针可以用作函数参数，而接收函数指针作为参数的这个函数，可以回调函数指针所指向的那个函数</strong>。</p><p>​<strong>对于排序算法，可以通过回调函数来实现不同的排序规则切换（升降序或者绝对值升降序）</strong>，具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> size, <span class="type">int</span> (*compare)(<span class="type">int</span>, <span class="type">int</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">bool</span> isSorted = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size - <span class="number">1</span> - i; j++)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="keyword">if</span> (compare(A[j], A[j+<span class="number">1</span>]) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">isSorted = <span class="literal">false</span>;</span><br><span class="line">                temp = A[j];</span><br><span class="line">                A[j] = A[j+<span class="number">1</span>];</span><br><span class="line">                A[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">if</span> (isSorted)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">greater</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">abs_greater</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(a) &gt; <span class="built_in">abs</span>(b)) </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> A[] = &#123;<span class="number">2</span>, <span class="number">-4</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">-5</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(A[<span class="number">0</span>]);</span><br><span class="line">    BubbleSort(A, size, greater);</span><br><span class="line">    <span class="comment">//BubbleSort(A, size, abs_greater);</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在排序函数中接收一个<strong>函数指针<code>Compare</code>作为参数，用这个参数来指示排序的规则</strong>。</p><p>其中：**<code>greater</code>函数为升序排列，<code>abs_greater</code>函数为绝对值升序排列**。</p><h3 id="引用传参和指针传参的区别"><a href="#引用传参和指针传参的区别" class="headerlink" title="引用传参和指针传参的区别"></a>引用传参和指针传参的区别</h3><p>​首先申明<strong>C语言中并不存在引用传参</strong>，但是因为vc6.0编译器建立的是后缀格式为.cpp的文件，所以引用传参同样可以应用，<strong>引用传参的简单理解就是：起别名，使用指针传递参数，是为了避免拷贝副本，从而提高程序执行效率</strong>。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li><strong>指针从本质上讲是一个变量，变量的值是另一个变量的地址</strong>，指针在<strong>逻辑上是独立的</strong>，它可以被改变的，包括指针变量的值（所指向的地址）和指针变量的值对应的内存中的数据（所指向地址中所存放的数据）。</li><li><strong>引用从本质上讲是一个别名，是另一个变量的同义词</strong>，它在<strong>逻辑上不是独立的</strong>，它的存在具有依附性，所以<strong>引用必须在一开始就被初始化</strong>（先有这个变量，这个实物，这个实物才能有别名），而且<strong>其引用的对象在其整个生命周期中不能被改变，即自始至终只能依附于同一个变量</strong>（初始化的时候代表的是谁的别名，就一直是谁的别名，不能变）。</li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><table><thead><tr><th>指针</th><th>变量，独立，可变，可空，替身，无类型检查</th></tr></thead><tbody><tr><td><strong>引用</strong></td><td><strong>别名，依赖，不变，非空，本体，有类型检查</strong></td></tr></tbody></table><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><ul><li><strong>指针参数传递本质上是值传递，它所传递的是一个地址值</strong>。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，<strong>会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）</strong>。值传递的特点是，<strong>被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）</strong>。</li><li>引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。<strong>被调函数对形参（本体）的任何操作都被处理成间接寻址</strong>，<strong>即通过栈中存放的地址访问主调函数中的实参变量</strong>（根据别名找到主调函数中的本体）。因此，<strong>被调函数对形参的任何操作都会影响主调函数中的实参变量。</strong></li><li><strong>引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针（二级指针）或者指针引用</strong>。</li><li>从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。<strong>指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改</strong>。</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="exit-函数"><a href="#exit-函数" class="headerlink" title="exit()函数"></a>exit()函数</h3><p>​<code>exit()</code>函数用来终止整个程序的运行。一旦执行到该函数，程序就会立即结束。该函数的原型定义在头文件<code>stdlib.h</code>里面。</p><p>​<code>exit()</code>可以向程序外部返回一个值，它的参数就是程序的返回值。一般来说，使用两个常量作为它的参数：**<code>EXIT_SUCCESS</code>（相当于 0）表示程序运行成功，<code>EXIT_FAILURE</code>（相当于 1）表示程序异常中止。这两个常数也是定义在<code>stdlib.h</code>里面。**</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序运行成功</span></span><br><span class="line"><span class="comment">// 等同于 exit(0);</span></span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序异常中止</span></span><br><span class="line"><span class="comment">// 等同于 exit(1);</span></span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br></pre></td></tr></table></figure><p>​在<code>main()</code>函数里面，<code>exit()</code>等价于使用<code>return</code>语句。其他函数使用<code>exit()</code>，就是终止整个程序的运行，没有其他作用。</p><p>​C 语言还提供了一个<code>atexit()</code>函数，用来登记<code>exit()</code>执行时额外执行的函数，用来做一些退出程序时的收尾工作。该函数的原型也是定义在头文件<code>stdlib.h</code>。</p><h3 id="函数说明符"><a href="#函数说明符" class="headerlink" title="函数说明符"></a>函数说明符</h3><p>​C 语言提供了一些函数说明符，让函数用法更加明确。</p><h4 id="extern-说明符"><a href="#extern-说明符" class="headerlink" title="extern 说明符"></a>extern 说明符</h4><p>​<strong>对于多文件的项目，源码文件会用到其他文件声明的函数。这时，当前文件里面，需要给出外部函数的原型，并用<code>extern</code>说明该函数的定义来自其他文件。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> arg1, <span class="type">char</span> arg2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = foo(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面示例中，函数<code>foo()</code>定义在其他文件，<code>extern</code>告诉编译器当前文件不包含该函数的定义。</p><p>​不过，<strong>由于函数原型默认就是<code>extern</code>，所以这里不加<code>extern</code>，效果是一样的</strong>。</p><h4 id="static-说明符"><a href="#static-说明符" class="headerlink" title="static 说明符"></a>static 说明符</h4><p>​默认情况下，每次调用函数时，函数的内部变量都会重新初始化，不会保留上一次运行的值。<code>static</code>说明符可以改变这种行为。</p><p>​<strong><code>static</code>用于函数内部声明变量时，表示该变量只需要初始化一次，不需要在每次调用时都进行初始化。也就是说，它的值在两次调用之间保持不变。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">counter</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">1</span>;  <span class="comment">// 只初始化一次</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    counter();  <span class="comment">// 1</span></span><br><span class="line">    counter();  <span class="comment">// 2</span></span><br><span class="line">    counter();  <span class="comment">// 3</span></span><br><span class="line">    counter();  <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面示例中，函数<code>counter()</code>的内部变量<code>count</code>，使用<code>static</code>说明符修饰，表明这个变量只初始化一次，以后每次调用时都会使用上一次的值，造成递增的效果。</p><p>​<strong>注意，<code>static</code>修饰的变量初始化时，只能赋值为常量，不能赋值为变量。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> j = i; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>j</code>属于静态变量，初始化时不能赋值为另一个变量<code>i</code>。</p><p>​<strong>另外，在块作用域中，<code>static</code>声明的变量有默认值<code>0</code>。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> foo;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> foo = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>​<strong><code>static</code>可以用来修饰函数本身。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">Twice</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = num * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面示例中，**<code>static</code>关键字表示该函数只能在当前文件里使用，如果没有这个关键字，其他文件也可以使用这个函数（通过声明函数原型）**。</p><p>​<strong><code>static</code>也可以用在参数里面，修饰参数数组。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sum_array</span><span class="params">(<span class="type">int</span> a[<span class="type">static</span> <span class="number">3</span>], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面示例中，**<code>static</code>对程序行为不会有任何影响，只是用来告诉编译器，该数组长度至少为3，某些情况下可以加快程序运行速度。另外，需要注意的是，对于多维数组的参数，<code>static</code>仅可用于第一维的说明。(vc6.0不支持这个操作)**</p><h4 id="const-说明符"><a href="#const-说明符" class="headerlink" title="const 说明符"></a>const 说明符</h4><p>​<strong>函数参数里面的<code>const</code>说明符，表示函数内部不得修改该参数变量。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>* p)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面示例中，函数<code>f()</code>的参数是一个指针<code>p</code>，函数内部可能会改掉它所指向的值<code>*p</code>，从而影响到函数外部。</p><p>​为了避免这种情况，可以在声明函数时，在指针参数前面加上<code>const</code>说明符，告诉编译器，函数内部不能修改该参数所指向的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* p)</span> &#123;</span><br><span class="line">    *p = <span class="number">0</span>; <span class="comment">// 该行报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面示例中，声明函数时，<code>const</code>指定不能修改指针<code>p</code>指向的值，所以<code>*p = 0</code>就会报错。</p><p>​<strong>但是上面这种写法，只限制修改<code>p</code>所指向的值，而<code>p</code>本身的地址是可以修改的。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">13</span>;</span><br><span class="line">    p = &amp;x; <span class="comment">// 允许修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>p</code>本身是可以修改，<code>const</code>只限定<code>*p</code>不能修改。</p><p>​<strong>如果想限制修改<code>p</code>，可以把<code>const</code>放在<code>p</code>前面。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>* <span class="type">const</span> p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">13</span>;</span><br><span class="line">    p = &amp;x; <span class="comment">// 该行报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>如果想同时限制修改<code>p</code>和<code>*p</code>，需要使用两个<code>const</code>。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>​<strong>有些函数的参数数量是不确定的，声明函数的时候，可以使用省略号<code>...</code>表示可变数量的参数。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br></pre></td></tr></table></figure><p>​上面示例是<code>printf()</code>函数的原型，除了第一个参数，其他参数的数量是可变的，与格式字符串里面的占位符数量有关。这时，就可以用<code>...</code>表示可变数量的参数。</p><p>​<strong>注意，<code>...</code>符号必须放在参数序列的结尾，否则会报错。</strong></p><p>​<strong>头文件<code>stdarg.h</code>定义了一些宏，可以操作可变参数。</strong></p><ul><li><strong><code>va_list</code>：一个数据类型，用来定义一个可变参数对象。它必须在操作可变参数时，首先使用。</strong></li><li><strong><code>va_start</code>：一个函数，用来初始化可变参数对象。它接受两个参数，第一个参数是可变参数对象，第二个参数是原始函数里面，可变参数之前的那个参数，用来为可变参数定位。</strong></li><li><strong><code>va_arg</code>：一个函数，用来取出当前那个可变参数，每次调用后，内部指针就会指向下一个可变参数。它接受两个参数，第一个是可变参数对象，第二个是当前可变参数的类型。</strong></li><li><strong><code>va_end</code>：一个函数，用来清理可变参数对象。</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">average</span><span class="params">(<span class="type">int</span> i, ...)</span> &#123;</span><br><span class="line">    <span class="type">double</span> total = <span class="number">0</span>;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">      total += va_arg(ap, <span class="type">double</span>);</span><br><span class="line">&#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> total / i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, average(<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4.4</span>)); <span class="comment">// -0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, average(<span class="number">4</span>, (<span class="type">double</span>)<span class="number">1</span>, (<span class="type">double</span>)<span class="number">2</span>, (<span class="type">double</span>)<span class="number">3</span>, (<span class="type">double</span>)<span class="number">4.4</span>)); <span class="comment">// 2.6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>va_list ap</code>定义<code>ap</code>为可变参数对象，<code>va_start(ap, i)</code>将参数<code>i</code>后面的参数统一放入<code>ap</code>，<code>va_arg(ap, double)</code>用来从<code>ap</code>依次取出一个参数，并且指定该参数为 double 类型，<code>va_end(ap)</code>用来清理可变参数对象。</p><p>​<strong>注意，可变参数传参时需要适当进行强制类型转换，使其与<code>va_agr</code>中的第二个参数相同，否则无法达到预期效果。</strong></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组赋值"><a href="#数组赋值" class="headerlink" title="数组赋值"></a>数组赋值</h3><ol><li><p>数组也可以在声明时，使用大括号，同时对每一个成员赋值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">3490</span>, <span class="number">18</span>, <span class="number">95</span>&#125;;</span><br></pre></td></tr></table></figure><p>注意，使用大括号赋值时，必须在数组声明时赋值，否则编译时会报错。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line">a = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">3490</span>, <span class="number">18</span>, <span class="number">95</span>&#125;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，数组<code>a</code>声明之后再进行大括号赋值，导致报错。</p><p>报错的原因是，C 语言规定，数组变量一旦声明，就不得修改变量指向的地址，具体会在后文解释。由于同样的原因，数组赋值之后，再用大括号修改值，也是不允许的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">a = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">3490</span>, <span class="number">18</span>, <span class="number">95</span>&#125;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，数组<code>a</code>赋值后，再用大括号重新赋值也是不允许的。</p><p>使用大括号赋值时，大括号里面的值不能多于数组的长度，否则编译时会报错。</p><p>如果大括号里面的值，少于数组的成员数量，那么未赋值的成员自动初始化为<code>0</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">3490</span>&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">3490</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><p>如果要将整个数组的每一个成员都设置为零，最简单的写法就是下面这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>数组初始化时，可以指定为哪些位置的成员赋值。(这个操作在vc6.0里不被允许)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">15</span>] = &#123;[<span class="number">2</span>] = <span class="number">29</span>, [<span class="number">9</span>] = <span class="number">7</span>, [<span class="number">14</span>] = <span class="number">48</span>&#125;;</span><br></pre></td></tr></table></figure><p>上面示例中，数组的2号、9号、14号位置被赋值，其他位置的值都自动设为0。</p><p>指定位置的赋值可以不按照顺序，下面的写法与上面的例子是等价的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">15</span>] = &#123;[<span class="number">9</span>] = <span class="number">7</span>, [<span class="number">14</span>] = <span class="number">48</span>, [<span class="number">2</span>] = <span class="number">29</span>&#125;;</span><br></pre></td></tr></table></figure><p>指定位置的赋值与顺序赋值，可以结合使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">15</span>] = &#123;<span class="number">1</span>, [<span class="number">5</span>] = <span class="number">10</span>, <span class="number">11</span>, [<span class="number">10</span>] = <span class="number">20</span>, <span class="number">21</span>&#125;</span><br></pre></td></tr></table></figure><p>上面示例中，0号、5号、6号、10号、11号被赋值。</p></li><li><p>C 语言允许省略方括号里面的数组成员数量，这时将根据大括号里面的值的数量，自动确定数组的长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">3490</span>&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">3490</span>&#125;;</span><br></pre></td></tr></table></figure><p>上面示例中，数组<code>a</code>的长度，将根据大括号里面的值的数量，确定为<code>3</code>。</p><p><strong>省略成员数量时，如果同时采用指定位置的赋值，那么数组长度将是最大的指定位置再加1。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;[<span class="number">2</span>] = <span class="number">6</span>, [<span class="number">9</span>] = <span class="number">12</span>&#125;;</span><br></pre></td></tr></table></figure><p>上面示例中，数组<code>a</code>的最大指定位置是<code>9</code>，所以数组的长度是10。</p></li></ol><h3 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h3><p>​数组声明的时候，数组长度除了使用常量，也可以使用变量。这叫做变长数组（variable-length array，简称 VLA）。</p><p>​<strong>注意，变长数组是C99里加入的规则，vc6.0并不支持这种操作。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = x + y;</span><br><span class="line"><span class="type">int</span> arr[n];</span><br></pre></td></tr></table></figure><p>​上面示例中，数组<code>arr</code>就是变长数组，因为它的长度取决于变量<code>n</code>的值，编译器没法事先确定，只有运行时才能知道<code>n</code>是多少。</p><p>​<strong>变长数组的根本特征，就是数组长度只有运行时才能确定。它的好处是程序员不必在开发时，随意为数组指定一个估计的长度，程序可以在运行时为数组分配精确的长度。</strong></p><p>​变长数组也可以用于多维数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> c[m][n];</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>c[m][n]</code>就是二维变长数组。</p><h3 id="数组作函数参数"><a href="#数组作函数参数" class="headerlink" title="数组作函数参数"></a>数组作函数参数</h3><h4 id="多为数组作为参数"><a href="#多为数组作为参数" class="headerlink" title="多为数组作为参数"></a>多为数组作为参数</h4><p>​如果函数的参数是多维数组，那么除了第一维的长度可以当作参数传入函数，其他维的长度需要写入函数的定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum_array</span><span class="params">(<span class="type">int</span> a[][<span class="number">4</span>], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> sum = sum_array(a, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>​上面示例中，函数<code>sum_array()</code>的参数是一个二维数组。第一个参数是数组本身（<code>a[][4]</code>），这时可以不写第一维的长度，因为它作为第二个参数，会传入函数，但是一定要写第二维的长度<code>4</code>。</p><p>​这是因为函数内部拿到的，只是数组的起始地址<code>a</code>，以及第一维的成员数量<code>2</code>。如果要正确计算数组的结束地址，还必须知道第一维每个成员的字节长度。写成<code>int a[][4]</code>，编译器就知道了，第一维每个成员本身也是一个数组，里面包含了4个整数，所以每个成员的字节长度就是<code>4 * sizeof(int)</code>。</p><h4 id="变长数组作为参数"><a href="#变长数组作为参数" class="headerlink" title="变长数组作为参数"></a>变长数组作为参数</h4><p>​变长数组作为函数参数时，写法略有不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum_array</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> a[n])</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> sum = sum_array(<span class="number">4</span>, a);</span><br></pre></td></tr></table></figure><p>​上面示例中，数组<code>a[n]</code>是一个变长数组，它的长度取决于变量<code>n</code>的值，只有运行时才能知道。所以，变量<code>n</code>作为参数时，顺序一定要在变长数组前面，这样运行时才能确定数组<code>a[n]</code>的长度，否则就会报错。</p><p>​因为函数原型可以省略参数名，所以变长数组的原型中，可以使用<code>*</code>代替变量名，也可以省略变量名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum_array</span><span class="params">(<span class="type">int</span>, <span class="type">int</span> [*])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum_array</span><span class="params">(<span class="type">int</span>, <span class="type">int</span> [])</span>;</span><br></pre></td></tr></table></figure><p>​上面两种变长函数的原型写法，都是合法的。</p><p>​变长数组作为函数参数有一个好处，就是多维数组的参数声明，可以把后面的维度省掉了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原来的写法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum_array</span><span class="params">(<span class="type">int</span> a[][<span class="number">4</span>], <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变长数组的写法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum_array</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> a[n][m])</span>;</span><br></pre></td></tr></table></figure><p>​上面示例中，函数<code>sum_array()</code>的参数是一个多维数组，按照原来的写法，一定要声明第二维的长度。但是使用变长数组的写法，就不用声明第二维长度了，因为它可以作为参数传入函数。</p><h4 id="数组字面量作为参数"><a href="#数组字面量作为参数" class="headerlink" title="数组字面量作为参数"></a>数组字面量作为参数</h4><p>​<strong>C 语言允许将数组字面量作为参数，传入函数。(但是vc6.0不允许)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组变量作为参数</span></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> sum = sum_array(a, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组字面量作为参数</span></span><br><span class="line"><span class="type">int</span> sum = sum_array((<span class="type">int</span> [])&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>​上面示例中，两种写法是等价的。第二种写法省掉了数组变量的声明，直接将数组字面量传入函数。<code>&#123;2, 3, 4, 5&#125;</code>是数组值的字面量，<code>(int [])</code>类似于强制的类型转换，告诉编译器怎么理解这组值。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><p>​如果字符串过长，可以在需要折行的地方，使用反斜杠（<code>\</code>）结尾，将一行拆成多行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello \</span></span><br><span class="line"><span class="string">world&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，第一行尾部的反斜杠，将字符串拆成两行。</p><p>​上面这种写法有一个缺点，就是第二行必须顶格书写，如果想包含缩进，那么缩进也会被计入字符串。<strong>为了解决这个问题，C 语言允许合并多个字符串字面量，只要这些字符串之间没有间隔，或者只有空格，C 语言会将它们自动合并。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> greeting[<span class="number">50</span>] = <span class="string">&quot;Hello, &quot;</span><span class="string">&quot;how are you &quot;</span><span class="string">&quot;today!&quot;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">char</span> greeting[<span class="number">50</span>] = <span class="string">&quot;Hello, how are you today!&quot;</span>;</span><br></pre></td></tr></table></figure><p>​这种新写法支持多行字符串的合并。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> greeting[<span class="number">50</span>] = <span class="string">&quot;Hello, &quot;</span></span><br><span class="line">  <span class="string">&quot;how are you &quot;</span></span><br><span class="line">  <span class="string">&quot;today!&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="字符数组与字符指针的差异"><a href="#字符数组与字符指针的差异" class="headerlink" title="字符数组与字符指针的差异"></a>字符数组与字符指针的差异</h3><p>​字符指针和字符数组，这两种声明字符串变量的写法基本是等价的，但是有两个差异。</p><ol><li><p><strong>指针指向的字符串，在 C 语言内部被当作常量，不能修改字符串本身。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;z&#x27;</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>​上面代码使用指针，声明了一个字符串变量，然后修改了字符串的第一个字符。这种写法是错的，会导致难以预测的后果，执行时很可能会报错。</p><p><strong>如果使用数组声明字符串变量，就没有这个问题，可以修改数组的任意成员。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;z&#x27;</span>;</span><br></pre></td></tr></table></figure><p>​为什么字符串声明为指针时不能修改，声明为数组时就可以修改？<strong>原因是系统会将字符串的字面量保存在内存的常量区，这个区是不允许用户修改的。</strong>声明为指针时，指针变量存储的值是一个指向常量区的内存地址，因此用户不能通过这个地址去修改常量区。<strong>但是，声明为数组时，编译器会给数组在栈区单独分配一段内存，字符串字面量会被编译器解释成字符数组，逐个字符写入这段新分配的内存之中，而这段新内存是允许修改的。</strong></p><p>​为了提醒用户，字符串声明为指针后不得修改，可以在声明时使用<code>const</code>说明符，保证该字符串是只读的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* s = <span class="string">&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>指针变量可以指向其它字符串。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s = <span class="string">&quot;world&quot;</span>;</span><br></pre></td></tr></table></figure><p>​上面示例中，字符指针可以指向另一个字符串。<strong>但是，字符数组变量不能指向另一个字符串。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s = <span class="string">&quot;world&quot;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>​上面示例中，字符数组的数组名，总是指向初始化时的字符串地址，不能修改。</p><p>​<strong>同样的原因，声明字符数组后，不能直接用字符串赋值。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>];</span><br><span class="line">s = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>​上面示例中，不能直接把字符串赋值给字符数组变量，会报错。<strong>原因是字符数组的变量名，跟所指向的数组是绑定的，不能指向另一个地址。</strong></p><p>​为什么数组变量不能赋值为另一个数组？原因是数组变量所在的地址无法改变，或者说，编译器一旦为数组变量分配地址后，这个地址就绑定这个数组变量了，这种绑定关系是不变的。<strong>C 语言也因此规定，数组变量是一个不可修改的左值，即不能用赋值运算符为它重新赋值。</strong></p><p>​想要重新赋值，必须使用 C 语言原生提供的<code>strcpy()</code>函数，通过字符串拷贝完成赋值。这样做以后，数组变量的地址还是不变的，即<code>strcpy()</code>只是在原地址写入新的字符串，而不是让数组变量指向新的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(s, <span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>strcpy()</code>函数把字符串<code>abc</code>拷贝给变量<code>s</code>。</p></li></ol><h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen()"></a>strlen()</h3><p>​<code>strlen()</code>函数返回字符串的字节长度，**不包括末尾的空字符<code>\0</code>**。该函数的原型如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span>;</span><br></pre></td></tr></table></figure><p>​它的参数是字符串变量，返回的是<code>size_t</code>类型的无符号整数，除非是极长的字符串，一般情况下当作<code>int</code>类型处理即可。下面是一个用法实例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(str); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>​<strong>注意，字符串长度（<code>strlen()</code>）与字符串变量长度（<code>sizeof()</code>），是两个不同的概念。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">50</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(s));  <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(s));  <span class="comment">// 50</span></span><br></pre></td></tr></table></figure><p>​上面示例中，字符串长度是5，字符串变量长度是50。</p><p>​如果不使用这个函数，可以通过判断字符串末尾的<code>\0</code>，自己计算字符串长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (s[count] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">      count++;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy()"></a>strcpy()</h3><p>​<strong>字符串的复制，不能使用赋值运算符，直接将一个字符串赋值给字符数组变量。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span> str2[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">str1 = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 报错</span></span><br><span class="line">str2 = str1;  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>​上面两种字符串的复制写法，都是错的。<strong>因为数组的变量名是一个固定的地址，不能修改，使其指向另一个地址。</strong></p><p>​<strong>如果是字符指针，赋值运算符（<code>=</code>）只是将一个指针的地址复制给另一个指针，而不是复制字符串。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s1;</span><br><span class="line"><span class="type">char</span>* s2;</span><br><span class="line"></span><br><span class="line">s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s2 = s1;</span><br></pre></td></tr></table></figure><p>​上面代码可以运行，结果是两个指针变量<code>s1</code>和<code>s2</code>指向同一字符串，而不是将字符串<code>s1</code>的内容复制给<code>s2</code>。</p><p>​<code>strcpy()</code>函数，用于将一个字符串的内容复制到另一个字符串，相当于字符串赋值。该函数的原型如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(<span class="type">char</span> dest[], <span class="type">const</span> <span class="type">char</span> source[])</span><br></pre></td></tr></table></figure><p>​<code>strcpy()</code>接受两个参数，<strong>第一个参数是目的字符串数组，第二个参数是源字符串数组</strong>。<strong>复制字符串之前，必须要保证第一个参数的长度不小于第二个参数，否则虽然不会报错，但会溢出第一个字符串变量的边界，发生难以预料的结果</strong>。<strong>第二个参数的<code>const</code>说明符，表示这个函数不会修改第二个字符串</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> t[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(t, s);</span><br><span class="line"></span><br><span class="line">    t[<span class="number">0</span>] = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);  <span class="comment">// &quot;Hello, world!&quot;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, t);  <span class="comment">// &quot;zello, world!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面示例将变量<code>s</code>的值，拷贝一份放到变量<code>t</code>，变成两个不同的字符串，修改一个不会影响到另一个。<strong>另外，变量<code>t</code>的长度大于<code>s</code>，复制后多余的位置（结束标志<code>\0</code>后面的位置）都为随机值。</strong></p><p>​<strong><code>strcpy()</code>也可以用于字符数组的赋值。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;abcd&quot;</span>);</span><br></pre></td></tr></table></figure><p>​上面示例将字符数组变量，赋值为字符串“abcd”。</p><p>​<strong><code>strcpy()</code>的返回值是一个字符串指针（即<code>char*</code>），指向第一个参数。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s1 = <span class="string">&quot;beast&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[<span class="number">40</span>] = <span class="string">&quot;Be the best that you can be.&quot;</span>;</span><br><span class="line"><span class="type">char</span>* ps;</span><br><span class="line"></span><br><span class="line">ps = <span class="built_in">strcpy</span>(s2 + <span class="number">7</span>, s1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(s2); <span class="comment">// Be the beast</span></span><br><span class="line"><span class="built_in">puts</span>(ps); <span class="comment">// beast</span></span><br></pre></td></tr></table></figure><p>​上面示例中，从<code>s2</code>的第7个位置开始拷贝字符串<code>beast</code>，前面的位置不变<strong>。这导致<code>s2</code>后面的内容都被截去了，因为会连<code>beast</code>结尾的空字符一起拷贝。</strong><code>strcpy()</code>返回的是一个指针，指向拷贝开始的位置。</p><p>​<strong><code>strcpy()</code>返回值的另一个用途，是连续为多个字符数组赋值。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(str1, <span class="built_in">strcpy</span>(str2, <span class="string">&quot;abcd&quot;</span>));</span><br></pre></td></tr></table></figure><p>​上面示例调用两次<code>strcpy()</code>，完成两个字符串变量的赋值。</p><p>​<strong>另外，<code>strcpy()</code>的第一个参数最好是一个已经声明的数组，而不是声明后没有进行初始化的字符指针。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* str;</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;hello world&quot;</span>); <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>​<strong>上面的代码是有问题的，即使它可以通过编译</strong>。<code>strcpy()</code>将字符串分配给指针变量<code>str</code>，但是<code>str</code>并没有进行初始化，指向的是一个随机的位置，因此字符串可能被复制到任意地方。</p><p>​如果不用<code>strcpy()</code>，自己实现字符串的拷贝，可以用下面的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* source)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* ptr = dest;</span><br><span class="line">    <span class="keyword">while</span> (*dest++ = *source++);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">25</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面代码中，<strong>关键的一行是<code>while (*dest++ = *source++)</code>，这是一个循环，依次将<code>source</code>的每个字符赋值给<code>dest</code>，然后移向下一个位置，直到遇到<code>\0</code>，循环判断条件不再为真，从而跳出循环</strong>。其中，<code>*dest++</code>这个表达式等同于<code>*(dest++)</code>，即先返回<code>dest</code>这个地址，再进行自增运算移向下一个位置，而<code>*dest</code>可以对当前位置赋值。</p><p>​<strong><code>strcpy()</code>函数有安全风险，因为它并不检查目标字符串的长度，是否足够容纳源字符串的副本，可能导致写入溢出。</strong>如果不能保证不会发生溢出，建议使用<code>strncpy()</code>函数代替。</p><h3 id="strncpy"><a href="#strncpy" class="headerlink" title="strncpy()"></a>strncpy()</h3><p>​<code>strncpy()</code>跟<code>strcpy()</code>的用法完全一样，<strong>只是多了第3个参数，用来指定复制的最大字符数，防止溢出目标字符串变量的边界。</strong>该函数的原型如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strncpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">char</span>* src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><p>​上面原型中，第三个参数<code>n</code>定义了复制的最大字符数。<strong>如果达到最大字符数以后，源字符串仍然没有复制完，就会停止复制，这时目的字符串结尾将没有终止符<code>\0</code>，这一点务必注意。</strong></p><p>​<strong>如果源字符串的字符数小于<code>n</code>，则<code>strncpy()</code>的行为与<code>strcpy()</code>完全一致。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strncpy</span>(str1, str2, <span class="keyword">sizeof</span>(str1) - <span class="number">1</span>);</span><br><span class="line">str1[<span class="keyword">sizeof</span>(str1) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure><p>​上面示例中，字符串<code>str2</code>复制给<code>str1</code>，但是复制长度最多为<code>str1</code>的长度减去1，<code>str1</code>剩下的最后一位用于写入字符串的结尾标志<code>\0</code>。<strong>这是因为<code>strncpy()</code>不会自己添加<code>\0</code>，如果复制的字符串片段不包含结尾标志，就需要手动添加。</strong></p><p>​<strong><code>strncpy()</code>也可以用来拷贝部分字符串。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s1[<span class="number">40</span>];</span><br><span class="line"><span class="type">char</span> s2[<span class="number">12</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncpy</span>(s1, s2, <span class="number">5</span>);</span><br><span class="line">s1[<span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s1); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>​上面示例中，指定只拷贝前5个字符。</p><h3 id="strcat"><a href="#strcat" class="headerlink" title="strcat()"></a>strcat()</h3><p>​<code>strcat()</code>函数用于连接字符串。它接受两个字符串作为参数，把第二个字符串的副本添加到第一个字符串的末尾。<strong>这个函数会改变第一个字符串，但是第二个字符串不变</strong>。该函数的原型如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcat</span><span class="params">(<span class="type">char</span>* s1, <span class="type">const</span> <span class="type">char</span>* s2)</span>;</span><br></pre></td></tr></table></figure><p>​<code>strcat()</code>的返回值是一个字符串指针，指向第一个参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s1[<span class="number">12</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[<span class="number">6</span>] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcat</span>(s1, s2);</span><br><span class="line"><span class="built_in">puts</span>(s1); <span class="comment">// &quot;helloworld&quot;</span></span><br></pre></td></tr></table></figure><p>​<strong>注意，<code>strcat()</code>的第一个参数的长度，必须足以容纳添加第二个参数字符串。否则，拼接后的字符串会溢出第一个字符串的边界，写入相邻的内存单元，这是很危险的，建议使用下面的<code>strncat()</code>代替。</strong></p><h3 id="strncat"><a href="#strncat" class="headerlink" title="strncat()"></a>strncat()</h3><p>​<code>strncat()</code>用于连接两个字符串，用法与<code>strcat()</code>完全一致，<strong>只是增加了第三个参数，指定最大添加的字符数。在添加过程中，一旦达到指定的字符数，或者在源字符串中遇到空字符<code>\0</code>，就不再添加了</strong>。函数的原型如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strncat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><p>​<code>strncat()</code>返回第一个参数，即目标字符串指针。</p><p>​<strong>为了保证连接后的字符串，不超过目标字符串的长度，<code>strncat()</code>通常会写成下面这样。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strncat</span>(str1, str2, <span class="keyword">sizeof</span>(str1) - <span class="built_in">strlen</span>(str1) - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>​<strong><code>strncat()</code>总是会在拼接结果的结尾，自动添加空字符<code>\0</code>，所以第三个参数的最大值，应该是<code>str1</code>的变量长度减去<code>str1</code>的字符串长度，再减去<code>1</code>。</strong>下面是一个用法实例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s1[<span class="number">10</span>] = <span class="string">&quot;Monday&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[<span class="number">8</span>] = <span class="string">&quot;Tuesday&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncat</span>(s1, s2, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">puts</span>(s1); <span class="comment">// &quot;MondayTue&quot;</span></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>s1</code>的变量长度是10，字符长度是6，两者相减后再减去1，得到<code>3</code>，表明<code>s1</code>最多可以再添加三个字符，所以得到的结果是<code>MondayTue</code>。</p><h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp()"></a>strcmp()</h3><p>​如果要比较两个字符串，无法直接比较，只能一个个字符进行比较，C 语言提供了<code>strcmp()</code>函数。<code>strcmp()</code>函数用于比较两个字符串的内容。该函数的原型如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s1, <span class="type">const</span> <span class="type">char</span>* s2)</span>;</span><br></pre></td></tr></table></figure><p>​<strong>按照字典顺序，如果两个字符串相同，返回值为<code>0</code>；如果<code>s1</code>小于<code>s2</code>，<code>strcmp()</code>返回值小于0；如果<code>s1</code>大于<code>s2</code>，返回值大于0。</strong>下面是一个用法示例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s1 = Happy New Year</span></span><br><span class="line"><span class="comment">// s2 = Happy New Year</span></span><br><span class="line"><span class="comment">// s3 = Happy Holidays</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcmp</span>(s1, s2) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">strcmp</span>(s1, s3) <span class="comment">// 大于 0</span></span><br><span class="line"><span class="built_in">strcmp</span>(s3, s1) <span class="comment">// 小于 0</span></span><br></pre></td></tr></table></figure><p>​<strong>注意，<code>strcmp()</code>只用来比较字符串，不用来比较字符。因为字符就是小整数，直接用相等运算符（<code>==</code>）就能比较。所以，不要把字符类型（<code>char</code>）的值，放入<code>strcmp()</code>当作参数。</strong></p><h3 id="strncmp"><a href="#strncmp" class="headerlink" title="strncmp()"></a>strncmp()</h3><p>​由于<code>strcmp()</code>比较的是整个字符串，C 语言又提供了<code>strncmp()</code>函数，只比较到指定的位置。<strong>该函数增加了第三个参数，指定了比较的字符数</strong>。该函数的原型如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s1, <span class="type">const</span> <span class="type">char</span>* s2, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><p>​它的返回值与<code>strcmp()</code>一样。如果两个字符串相同，返回值为<code>0</code>；如果<code>s1</code>小于<code>s2</code>，<code>strcmp()</code>返回值小于0；如果<code>s1</code>大于<code>s2</code>，返回值大于0。下面是一个例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s1[<span class="number">12</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[<span class="number">12</span>] = <span class="string">&quot;hello C&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(s1, s2, <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;They all have hello.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面示例只比较两个字符串的前5个字符。</p><h3 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf()"></a>sprintf()</h3><p>​<strong><code>sprintf()</code>函数跟<code>printf()</code>类似，但是用于将数据写入字符串，而不是输出到显示器。该函数的原型定义在<code>stdio.h</code>头文件里面。</strong>该函数的原型如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span>* s, <span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br></pre></td></tr></table></figure><p>​<code>sprintf()</code>的第一个参数是字符串指针变量，其余参数和<code>printf()</code>相同，即第二个参数是格式字符串，后面的参数是待写入的变量列表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> first[<span class="number">6</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> last[<span class="number">6</span>] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">char</span> s[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%s %s&quot;</span>, first, last);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s); <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>sprintf()</code>将输出内容组合成“hello world”，然后放入了变量<code>s</code>。</p><p>​<strong><code>sprintf()</code>的返回值是写入变量的字符数量（不计入尾部的空字符<code>\0</code>）。如果遇到错误，返回负值。</strong></p><p>​<strong><code>sprintf()</code>有严重的安全风险，如果写入的字符串过长，超过了目标字符串的长度，<code>sprintf()</code>依然会将其写入，导致发生溢出。</strong>为了控制写入的字符串的长度，C 语言又提供了另一个函数<code>snprintf()</code>。</p><h3 id="snprintf"><a href="#snprintf" class="headerlink" title="snprintf()"></a>snprintf()</h3><p>​<code>snprintf()</code>只比<code>sprintf()</code>多了一个参数<code>n</code>，**用来控制写入变量的字符串不超过<code>n - 1</code>个字符，剩下一个位置写入空字符<code>\0</code>**。该函数的原型如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span>*s, <span class="type">size_t</span> n, <span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br></pre></td></tr></table></figure><p>​<strong><code>snprintf()</code>总是会自动写入字符串结尾的空字符。如果你尝试写入的字符数超过指定的最大字符数，<code>snprintf()</code>会写入 n - 1 个字符，留出最后一个位置写入空字符。</strong>下面是一个例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">snprintf</span>(s, <span class="number">12</span>, <span class="string">&quot;%s %s&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure><p>​上面的例子中，<code>snprintf()</code>的第二个参数是12，表示写入字符串的最大长度不超过12（包括尾部的空字符）。</p><p>​<strong><code>snprintf()</code>的返回值是写入格式字符串的字符数量（不计入尾部的空字符<code>\0</code>）。如果<code>n</code>足够大，返回值应该小于<code>n</code>，但是有时候格式字符串的长度可能大于<code>n</code>，那么这时返回值会大于<code>n</code>，但实际上真正写入变量的还是<code>n-1</code>个字符。如果遇到错误，返回一个负值。因此，返回值只有在非负并且小于<code>n</code>时，才能确认完整的格式字符串写入了变量。</strong></p><p>​<strong>注意，<code>snprintf()</code>是C99标准才引入库中的，vc6.0并不能使用该函数，只可以使用<code>sprintf()</code>。</strong></p><h3 id="字符串数组与指针数组"><a href="#字符串数组与指针数组" class="headerlink" title="字符串数组与指针数组"></a>字符串数组与指针数组</h3><p>​如果一个数组的每个成员都是一个字符串，需要通过二维的字符数组实现。每个字符串本身是一个字符数组，多个字符串再组成一个数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> weekdays[<span class="number">7</span>][<span class="number">10</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;Monday&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Tuesday&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Thursday&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Friday&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Saturday&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Sunday&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​上面示例就是一个字符串数组，一共包含7个字符串，所以第一维的长度是7。<strong>其中，最长的字符串的长度是10（含结尾的终止符<code>\0</code>），所以第二维的长度统一设为10。</strong></p><p>​因为第一维的长度，编译器可以自动计算，所以可以省略。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> weekdays[][<span class="number">10</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;Monday&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Tuesday&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Thursday&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Friday&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Saturday&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Sunday&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​上面示例中，二维数组第一维的长度，可以由编译器根据后面的赋值，自动计算，所以可以不写。</p><p>​<strong>数组的第二维，长度统一定为10，有点浪费空间，因为大多数成员的长度都小于10。解决方法就是把数组的第二维，从字符数组改成字符指针。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* weekdays[] = &#123;</span><br><span class="line">    <span class="string">&quot;Monday&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Tuesday&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Thursday&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Friday&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Saturday&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Sunday&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​<strong>上面的字符串数组，其实是一个一维数组，成员就是7个字符指针，每个指针指向一个字符串（字符数组）。</strong></p><p>​遍历字符串数组的写法如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, weekdays[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h2><h3 id="restrict-说明符"><a href="#restrict-说明符" class="headerlink" title="restrict 说明符"></a>restrict 说明符</h3><p>​声明指针变量时，可以使用<code>restrict</code>说明符，告诉编译器，<strong>该块内存区域只有当前指针一种访问方式，其他指针不能读写该块内存</strong>。这种指针称为“<strong>受限指针</strong>”（restrict pointer）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="keyword">restrict</span> p;</span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><p>​上面示例中，声明指针变量<code>p</code>时，加入了<code>restrict</code>说明符，使得<code>p</code>变成了受限指针。后面，当<code>p</code>指向<code>malloc()</code>函数返回的一块内存区域，<strong>就味着，该区域只有通过<code>p</code>来访问，不存在其他访问方式</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="keyword">restrict</span> p;</span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* q = p;</span><br><span class="line">*q = <span class="number">0</span>; <span class="comment">// 未定义行为</span></span><br></pre></td></tr></table></figure><p>​上面示例中，另一个指针<code>q</code>与受限指针<code>p</code>指向同一块内存，现在该内存有<code>p</code>和<code>q</code>两种访问方式。这就违反了对编译器的承诺，后面通过<code>*q</code>对该内存区域赋值，会导致未定义行为。</p><h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy()"></a>memcpy()</h3><p>​**<code>memcpy()</code>用于将一块内存拷贝到另一块内存。该函数的原型定义在头文件<code>string.h</code>**。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">memcpy</span><span class="params">(<span class="type">void</span>* <span class="keyword">restrict</span> dest,  <span class="type">void</span>* <span class="keyword">restrict</span> source,  <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><p>​上面代码中，<code>dest</code>是目标地址，<code>source</code>是源地址，第三个参数<code>n</code>是要拷贝的字节数<code>n</code>。如果要拷贝10个 double 类型的数组成员，<code>n</code>就等于<code>10 * sizeof(double)</code>，而不是<code>10</code>。该函数会将从<code>source</code>开始的<code>n</code>个字节，拷贝到<code>dest</code>。</p><p>​<strong><code>dest</code>和<code>source</code>都是 void 指针，表示这里不限制指针类型，各种类型的内存数据都可以拷贝。两者都有 restrict 关键字，表示这两个内存块不应该有互相重叠的区域。</strong></p><p>​<code>memcpy()</code>的返回值是第一个参数，即目标地址的指针。</p><p>​因为<code>memcpy()</code>只是将一段内存的值，复制到另一段内存，所以不需要知道内存里面的数据是什么类型。下面是复制字符串的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;Goats!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> t[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(t, s, <span class="keyword">sizeof</span>(s)); <span class="comment">// 拷贝7个字节，包括终止符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, t); <span class="comment">// &quot;Goats!&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面示例中，字符串<code>s</code>所在的内存，被拷贝到字符数组<code>t</code>所在的内存。</p><p>​<strong><code>memcpy()</code>可以取代<code>strcpy()</code>进行字符串拷贝，而且是更好的方法，不仅更安全，速度也更快，它不检查字符串尾部的<code>\0</code>字符。</strong></p><h3 id="memmove"><a href="#memmove" class="headerlink" title="memmove()"></a>memmove()</h3><p>​<strong><code>memmove()</code>函数用于将一段内存数据复制到另一段内存。它跟<code>memcpy()</code>的主要区别是，它允许目标区域与源区域有重叠。如果发生重叠，源区域的内容会被更改；如果没有重叠，它与<code>memcpy()</code>行为相同。该函数的原型定义在头文件<code>string.h</code>。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">memmove</span><span class="params">(<span class="type">void</span>* dest,  <span class="type">void</span>* source,  <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><p>​<strong>上面代码中，<code>dest</code>是目标地址，<code>source</code>是源地址，<code>n</code>是要移动的字节数。<code>dest</code>和<code>source</code>都是 void 指针，表示可以移动任何类型的内存数据，两个内存区域可以有重叠。</strong></p><p>​<code>memmove()</code>返回值是第一个参数，即目标地址的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">memmove(&amp;a[<span class="number">0</span>], &amp;a[<span class="number">1</span>], <span class="number">99</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><p>​上面示例中，从数组成员<code>a[1]</code>开始的99个成员，都向前移动一个位置。</p><p>下面是另一个例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> x[] = <span class="string">&quot;Home Sweet Home&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 Sweet Home Home</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span> *) memmove(x, &amp;x[<span class="number">5</span>], <span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>​上面示例中，从字符串<code>x</code>的5号位置开始的10个字节，就是<code>“Sweet Home”</code>，<code>memmove()</code>将其前移到0号位置，所以<code>x</code>就变成了<code>“Sweet Home Home”</code>。</p><h3 id="memcmp"><a href="#memcmp" class="headerlink" title="memcmp()"></a>memcmp()</h3><p>​<strong><code>memcmp()</code>函数用来比较两个内存区域。它的原型定义在<code>string.h</code>。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *s1, <span class="type">const</span> <span class="type">void</span> *s2, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><p>​它接受三个参数，前两个参数是用来比较的指针，第三个参数指定比较的字节数。</p><p>​<strong>它的返回值是一个整数。两块内存区域的每个字节以字符形式解读，按照字典顺序进行比较，如果两者相同，返回<code>0</code>；如果<code>s1</code>大于<code>s2</code>，返回大于0的整数；如果<code>s1</code>小于<code>s2</code>，返回小于0的整数。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">char</span>* s2 = <span class="string">&quot;acd&quot;</span>;</span><br><span class="line"><span class="type">int</span> r = <span class="built_in">memcmp</span>(s1, s2, <span class="number">3</span>); <span class="comment">// 小于 0</span></span><br></pre></td></tr></table></figure><p>​上面示例比较<code>s1</code>和<code>s2</code>的前三个字节，由于<code>s1</code>小于<code>s2</code>，所以<code>r</code>是一个小于0的整数，一般为-1。下面是另一个例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s1[] = &#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> s2[] = &#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;t&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(s1, s2, <span class="number">3</span>) == <span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(s1, s2, <span class="number">4</span>) == <span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(s1, s2, <span class="number">7</span>) == <span class="number">0</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>​<strong>上面示例展示了，<code>memcmp()</code>可以比较内部带有字符串终止符<code>\0</code>的内存区域。</strong></p><h2 id="struct-结构"><a href="#struct-结构" class="headerlink" title="struct 结构"></a>struct 结构</h2><h3 id="struct的大小"><a href="#struct的大小" class="headerlink" title="struct的大小"></a>struct的大小</h3><p>​<strong>struct 结构占用的存储空间，不是各个属性存储空间的总和，而是最大内存占用属性的存储空间的倍数，其他属性会添加空位与之对齐。这样可以提高读写效率。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> *b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> foo)); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>struct foo</code>有三个属性，在64位计算机上占用的存储空间分别是：<code>int a</code>占4个字节，指针<code>char* b</code>占8个字节，<code>char c</code>占1个字节。它们加起来，一共是13个字节（4 + 8 + 1）。但是实际上，<code>struct foo</code>会占用24个字节，原因是它最大的内存占用属性是<code>char* b</code>的8个字节，导致其他属性的存储空间也是8个字节，这样才可以对齐，导致整个<code>struct foo</code>就是24个字节（8 * 3）。</p><p>​<strong>注意，指针变量的大小取决于计算机的位数，在32位计算机中，指针变量的大小为4个字节，在64位计算机中，指针变量的大小为8个字节。同时需要注意的是，编译器的位数也是影响指针变量大小的因素，即使是64位计算机，如果使用的编译器是32位的，那么指针变量的大小也会是4个字节。</strong></p><p>​多出来的存储空间，都采用空位填充，所以上面的<code>struct foo</code>真实的结构其实是下面这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a;        <span class="comment">// 4</span></span><br><span class="line">    <span class="type">char</span> pad1[<span class="number">4</span>]; <span class="comment">// 填充4字节</span></span><br><span class="line">    <span class="type">char</span> *b;      <span class="comment">// 8</span></span><br><span class="line">    <span class="type">char</span> c;       <span class="comment">// 1</span></span><br><span class="line">    <span class="type">char</span> pad2[<span class="number">7</span>]; <span class="comment">// 填充7字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> foo)); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure><p>​<strong>为什么浪费这么多空间进行内存对齐呢？这是为了加快读写速度，把内存占用划分成等长的区块，就可以快速在 Struct 结构体中定位到每个属性的起始地址。</strong></p><p>​<strong>由于这个特性，在有必要的情况下，定义 Struct 结构体时，可以采用存储空间递增的顺序，定义每个属性，这样就能节省一些空间。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> foo)); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><p>​上面示例中，占用空间最小的<code>char c</code>排在第一位，其次是<code>int a</code>，占用空间最大的<code>char* b</code>排在最后。整个<code>strct foo</code>的内存占用就从24字节下降到16字节。</p><h3 id="struct的复制"><a href="#struct的复制" class="headerlink" title="struct的复制"></a>struct的复制</h3><p>​<strong>struct 变量可以使用赋值运算符（<code>=</code>），复制给另一个变量，这时会生成一个全新的副本。系统会分配一块新的内存空间，大小与原来的变量相同，把每个属性都复制过去，即原样生成了一份数据。这一点跟数组的复制不一样，务必小心。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cat</span> &#123;</span> <span class="type">char</span> name[<span class="number">30</span>]; <span class="type">short</span> age; &#125; a, b;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(a.name, <span class="string">&quot;Hula&quot;</span>);</span><br><span class="line">a.age = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">b = a;</span><br><span class="line">b.name[<span class="number">0</span>] = <span class="string">&#x27;M&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, a.name); <span class="comment">// Hula</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, b.name); <span class="comment">// Mula</span></span><br></pre></td></tr></table></figure><p>​上面示例中，变量<code>b</code>是变量<code>a</code>的副本，两个变量的值是各自独立的，修改掉<code>b.name</code>不影响<code>a.name</code>。</p><p>​<strong>上面这个示例是有前提的，就是 struct 结构的属性必须定义成字符数组，才能复制数据。如果稍作修改，属性定义成字符指针，结果就不一样。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cat</span> &#123;</span> <span class="type">char</span>* name; <span class="type">short</span> age; &#125; a, b;</span><br><span class="line"></span><br><span class="line">a.name = <span class="string">&quot;Hula&quot;</span>;</span><br><span class="line">a.age = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">b = a;</span><br></pre></td></tr></table></figure><p>​<strong>上面示例中，<code>name</code>属性变成了一个字符指针，这时<code>a</code>赋值给<code>b</code>，导致<code>b.name</code>也是同样的字符指针，指向同一个地址，也就是说两个属性共享同一个地址。</strong>因为这时，struct 结构内部保存的是一个指针，而不是上一个例子的数组，这时复制的就不是字符串本身，而是它的指针。<strong>并且，这个时候也没法修改字符串，因为字符指针指向的字符串是不能修改的。</strong></p><p>​<strong>总结一下，赋值运算符（<code>=</code>）可以将 struct 结构每个属性的值，一模一样复制一份，拷贝给另一个 struct 变量。这一点跟数组完全不同，使用赋值运算符复制数组，不会复制数据，只会共享地址。</strong></p><p>​<strong>注意，这种赋值要求两个变量是同一个类型，不同类型的 struct 变量无法互相赋值。</strong></p><p>​<strong>另外，C 语言没有提供比较两个自定义数据结构是否相等的方法，无法用比较运算符（比如<code>==</code>和<code>!=</code>）比较两个数据结构是否相等或不等。</strong></p><h3 id="段字位"><a href="#段字位" class="headerlink" title="段字位"></a>段字位</h3><p>​<strong>struct 还可以用来定义二进制位组成的数据结构，称为“位字段”（bit field），这对于操作底层的二进制数据非常有用。</strong></p><p>​<strong>位字段是C语言中一种存储结构，不同于一般结构体的是它在定义成员的时候需要指定成员所占的位数。</strong></p><p>​位字段是一个signed int 或 unsigned int 类型的变量中的一组相邻的位。位字段通过一个结构声明来建立的，该结构声明为每个字段提供标签，并确定该字段的宽度。</p><p>在结构体声明位字段如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">type [member_name] : width ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>位字段中变量元素的描述：</p><table><thead><tr><th align="center"></th><th></th></tr></thead><tbody><tr><td align="center">type</td><td>整数类型，决定了如何解释位域的值。 类型可以为unsigned int，signed int。</td></tr><tr><td align="center">member_name</td><td>位字段的名称。</td></tr><tr><td align="center">width</td><td>位字段的宽度必须小于或者等于指定位的宽度</td></tr></tbody></table><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ab:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cd:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ef:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> gh:<span class="number">1</span>;</span><br><span class="line">&#125; synth;</span><br><span class="line"></span><br><span class="line">synth.ab = <span class="number">0</span>;</span><br><span class="line">synth.cd = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>​上面示例中，每个属性后面的<code>:1</code>，表示指定这些属性只占用一个二进制位，所以这个数据结构一共是4个二进制位。</p><p>​<strong>注意，定义二进制位时，结构内部的各个属性只能是整数类型。</strong></p><p>​<strong>实际存储的时候，C 语言会按照<code>int</code>类型占用的字节数，存储一个位字段结构。</strong>如果有剩余的二进制位，可以使用未命名属性，填满那些位。也可以使用宽度为0的属性，表示占满当前字节剩余的二进制位，迫使下一个属性存储在下一个字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> field1 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        : <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> field2 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        : <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> field3 : <span class="number">1</span>;</span><br><span class="line">&#125; stuff;</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>stuff.field1</code>与<code>stuff.field2</code>之间，有一个宽度为两个二进制位的未命名属性。<code>stuff.field3</code>将存储在下一个字节。</p><h3 id="弹性数组成员"><a href="#弹性数组成员" class="headerlink" title="弹性数组成员"></a>弹性数组成员</h3><p>​<strong>很多时候，不能事先确定数组到底有多少个成员。如果声明数组的时候，事先给出一个很大的成员数，就会很浪费空间。C 语言提供了一个解决方法，叫做弹性数组成员（flexible array member）。</strong></p><p>​如果不能事先确定数组成员的数量时，可以定义一个 struct 结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vstring</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">char</span> chars[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​<strong>上面示例中，<code>struct vstring</code>结构有两个属性。<code>len</code>属性用来记录数组<code>chars</code>的长度，<code>chars</code>属性是一个数组，但是没有给出成员数量。</strong></p><p>​<strong><code>chars</code>数组到底有多少个成员，可以在为<code>vstring</code>分配内存时确定。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vstring</span> *<span class="title">str</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> vstring) + n * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">str-&gt;len = n;</span><br></pre></td></tr></table></figure><p>​上面示例中，假定<code>chars</code>数组的成员数量是<code>n</code>，只有在运行时才能知道<code>n</code>到底是多少。然后，就为<code>struct vstring</code>分配它需要的内存：它本身占用的内存长度，再加上<code>n</code>个数组成员占用的内存长度。最后，<code>len</code>属性记录一下<code>n</code>是多少。</p><p>​<strong>这样就可以让数组<code>chars</code>有<code>n</code>个成员，不用事先确定，可以跟运行时的需要保持一致。</strong></p><p>​<strong>弹性数组成员有一些专门的规则。首先，弹性成员的数组，必须是 struct 结构的最后一个属性。另外，除了弹性数组成员，struct 结构必须至少还有一个其他属性。</strong></p><h2 id="typedef-命令"><a href="#typedef-命令" class="headerlink" title="typedef 命令"></a>typedef 命令</h2><h3 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h3><ol><li><p><strong>typedef 可以一次指定多个别名。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> antelope, bagel, mushroom;</span><br></pre></td></tr></table></figure><p>上面示例中，一次性为<code>int</code>类型起了三个别名。</p></li><li><p><strong>typedef 可以为指针起别名。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* intptr;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">intptr x = &amp;a;</span><br></pre></td></tr></table></figure><p>上面示例中，<code>intptr</code>是<code>int*</code>的别名。不过，使用的时候要小心，这样不容易看出来，变量<code>x</code>是一个指针类型。</p></li><li><p><strong>typedef 也可以用来为数组类型起别名。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> five_ints[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">five_ints x = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br></pre></td></tr></table></figure><p>上面示例中，<code>five_ints</code>是一个数组类型，包含5个整数的</p></li><li><p><strong>typedef 为函数起别名的写法如下。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">signed</span> <span class="title function_">char</span> <span class="params">(*fp)</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>上面示例中，类型别名<code>fp</code>是一个指针，代表函数<code>signed char (*)(void)</code>。</p></li></ol><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ol><li><p><strong>更好的代码可读性。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* STRING;</span><br><span class="line"></span><br><span class="line">STRING name;</span><br></pre></td></tr></table></figure><p>上面示例为字符指针起别名为<code>STRING</code>，以后使用<code>STRING</code>声明变量时，就可以轻易辨别该变量是字符串。</p></li><li><p><strong>为 struct、union、enum 等命令定义的复杂数据结构创建别名，从而便于引用。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treenode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">treenode</span> *<span class="title">Tree</span>;</span></span><br></pre></td></tr></table></figure><p>上面示例中，<code>Tree</code>为<code>struct treenode*</code>的别名。</p><p>typedef 也可以与 struct 定义数据类型的命令写在一起。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> leg_count, speed;</span><br><span class="line">&#125; animal;</span><br></pre></td></tr></table></figure><p>上面示例中，自定义数据类型时，同时使用<code>typedef</code>命令，为<code>struct animal</code>起了一个别名<code>animal</code>。</p><p><strong>这种情况下，C 语言允许省略 struct 命令后面的类型名。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> leg_count, speed;</span><br><span class="line">&#125; animal;</span><br></pre></td></tr></table></figure><p>上面示例相当于为一个匿名的数据类型起了别名<code>animal</code>。</p></li><li><p><strong>typedef 方便以后为变量改类型。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> app_float;</span><br><span class="line"></span><br><span class="line">app_float f1, f2, f3;</span><br></pre></td></tr></table></figure><p>上面示例中，变量<code>f1</code>、<code>f2</code>、<code>f3</code>的类型都是<code>float</code>。如果以后需要为它们改类型，只需要修改<code>typedef</code>语句即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> app_float;</span><br></pre></td></tr></table></figure><p>上面命令将变量<code>f1</code>、<code>f2</code>、<code>f3</code>的类型都改为<code>long double</code>。</p></li><li><p><strong>可移植性</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">100000</span>;</span><br></pre></td></tr></table></figure><p>某一个值在不同计算机上的类型，可能是不一样的。</p><p>上面代码在32位整数的计算机没有问题，但是在16位整数的计算机就会出错。</p><p><strong>C 语言的解决办法，就是提供了类型别名，在不同计算机上会解释成不同类型，比如<code>int32_t</code>。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> i = <span class="number">100000</span>;</span><br></pre></td></tr></table></figure><p>上面示例将变量<code>i</code>声明成<code>int32_t</code>类型，保证它在不同计算机上都是32位宽度，移植代码时就不会出错。</p><p>这一类的类型别名都是用 typedef 定义的。下面是类似的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> <span class="type">ptrdiff_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="type">size_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">wchar_t</span>;</span><br></pre></td></tr></table></figure><p><strong>这些整数类型别名都放在头文件<code>stdint.h</code>，不同架构的计算机只需修改这个头文件即可，而无需修改代码。</strong></p><p>因此，<code>typedef</code>有助于提高代码的可移植性，使其能适配不同架构的计算机。</p></li><li><p><strong>简化类型声明</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> (*(*x(<span class="type">void</span>))[<span class="number">5</span>])(<span class="type">void</span>);</span><br></pre></td></tr></table></figure><p>C 语言有些类型声明相当复杂，比如上面示例中的这个。</p><p>typedef 可以简化复杂的类型声明，使其更容易理解。首先，最外面一层起一个类型别名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">char</span> <span class="params">(*Func)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">Func (*x(<span class="type">void</span>))[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>这个看起来还是有点复杂，就为里面一层也定义一个别名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">char</span> <span class="params">(*Func)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">typedef</span> Func Arr[<span class="number">5</span>];</span><br><span class="line">Arr* <span class="title function_">x</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>上面代码就比较容易解读了。</p><ul><li><code>x</code>是一个函数，返回一个指向 Arr 类型的指针。</li><li><code>Arr</code>是一个数组，有5个成员，每个成员是<code>Func</code>类型。</li><li><code>Func</code>是一个函数指针，指向一个无参数、返回字符值的函数。</li></ul></li></ol><h2 id="Union-结构"><a href="#Union-结构" class="headerlink" title="Union 结构"></a>Union 结构</h2><p>​有时需要一种数据结构，不同的场合表示不同的数据类型。比如，如果只用一种数据结构表示水果的“量”，这种结构就需要有时是整数（6个苹果），有时是浮点数（1.5公斤草莓）。</p><p>​<strong>C 语言提供了 Union 结构，用来自定义可以灵活变更的数据结构。它内部可以包含各种属性，但同一时间只能有一个属性，因为所有属性都保存在同一个内存地址，后面写入的属性会覆盖前面的属性。这样做的最大好处是节省空间。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">quantity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">short</span> count;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line">    <span class="type">float</span> volume;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>union</code>命令定义了一个包含三个属性的数据类型<code>quantity</code>。<strong>虽然包含三个属性，但是同一时间只能取到一个属性。最后赋值的属性，就是可以取到值的那个属性。</strong></p><p>​使用时，声明一个该类型的变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">quantity</span> <span class="title">q</span>;</span></span><br><span class="line">q.count = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">quantity</span> <span class="title">q</span> =</span> &#123;.count=<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">quantity</span> <span class="title">q</span> =</span> &#123;<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><p>​上面代码展示了为 Union 结构赋值的三种写法。<strong>最后一种写法不指定属性名，就会赋值给第一个属性。</strong></p><p>​<strong>执行完上面的代码以后，<code>q.count</code>可以取到值，另外两个属性取不到值。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q.weight = <span class="number">0.5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;weight is %f\n&quot;</span>, q.weight); <span class="comment">// weight is 0.5</span></span><br></pre></td></tr></table></figure><p>​<strong>一旦为其他属性赋值，原先可以取到值的<code>q.count</code>属性就不再有效了。</strong>除了这一点，Union 结构的其他用法与 Struct 结构，基本上是一致的。</p><p>​Union 结构也支持指针运算符<code>-&gt;</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">quantity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">short</span> count;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line">    <span class="type">float</span> volume;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">quantity</span> <span class="title">q</span>;</span></span><br><span class="line">q.count = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">quantity</span> *<span class="title">ptr</span>;</span></span><br><span class="line">ptr = &amp;q;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ptr-&gt;count); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>ptr</code>是<code>q</code>的指针，那么<code>ptr-&gt;count</code>等同于<code>q.count</code>。</p><p>​<strong>Union 结构指针与它的属性有关，当前哪个属性能够取到值，它的指针就是对应的数据类型。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line">&#125; x;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *foo_int_p = (<span class="type">int</span> *)&amp;x;</span><br><span class="line"><span class="type">float</span> *foo_float_p = (<span class="type">float</span> *)&amp;x;</span><br><span class="line"></span><br><span class="line">x.a = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x.a);        <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *foo_int_p); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line">x.b = <span class="number">3.141592</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, x.b);          <span class="comment">// 3.141592</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, *foo_float_p); <span class="comment">// 3.141592</span></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>&amp;x</code>是 foo 结构的指针，它的数据类型完全由当前赋值的属性决定。</p><p>​<strong>Union 结构占用的内存长度，等于它内部最长属性的长度。</strong></p><p>​typedef 命令可以为 Union 类型起别名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">short</span> count;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line">    <span class="type">float</span> volume;</span><br><span class="line">&#125; quantity;</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>union</code>命令定义了一个包含三个属性的数据类型，<code>typedef</code>命令为它起别名为<code>quantity</code>。</p><p>​<strong>Union 结构的好处，主要是节省空间。它将一段内存空间，重用于不同类型的数据。定义了三个属性，但同一时间只用到一个，使用 Union 结构就可以节省另外两个属性的空间。</strong></p><h2 id="Enum-类型"><a href="#Enum-类型" class="headerlink" title="Enum 类型"></a>Enum 类型</h2><p>​<strong>如果一种数据类型的取值只有少数几种可能，并且每种取值都有自己的含义，为了提高代码的可读性，可以将它们定义为 Enum 类型，中文名为枚举。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">colors</span> &#123;</span>RED, GREEN, BLUE&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, RED); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, GREEN);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, BLUE);  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>​上面示例中，假定程序里面需要三种颜色，就可以使用<code>enum</code>命令，把这三种颜色定义成一种枚举类型<code>colors</code>，它只有三种取值可能<code>RED</code>、<code>GREEN</code>、<code>BLUE</code>。这时，这三个名字自动成为整数常量，编译器默认将它们的值设为数字<code>0</code>、<code>1</code>、<code>2</code>。相比之下，<code>RED</code>要比<code>0</code>的可读性好了许多。</p><p>​<strong>注意，Enum 内部的常量名，遵守标识符的命名规范，但是通常都使用大写。</strong></p><p>​使用时，可以将变量声明为 Enum 类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">colors</span> <span class="title">color</span>;</span></span><br></pre></td></tr></table></figure><p>​上面代码将变量<code>color</code>声明为<code>enum colors</code>类型。这个变量的值就是常量<code>RED</code>、<code>GREEN</code>、<code>BLUE</code>之中的一个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">color = BLUE;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, color); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>​上面代码将变量<code>color</code>的值设为<code>BLUE</code>，这里<code>BLUE</code>就是一个常量，值等于<code>2</code>。</p><p>​typedef 命令可以为 Enum 类型起别名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SHEEP,</span><br><span class="line">    WHEAT,</span><br><span class="line">    WOOD,</span><br><span class="line">    BRICK,</span><br><span class="line">    ORE</span><br><span class="line">&#125; RESOURCE;</span><br><span class="line"></span><br><span class="line">RESOURCE r;</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>RESOURCE</code>是 Enum 类型的别名。声明变量时，使用这个别名即可。</p><p>​<strong>由于 Enum 的属性会自动声明为常量，所以有时候使用 Enum 的目的，不是为了自定义一种数据类型，而是为了声明一组常量。这时就可以使用下面这种写法，比较简单。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> ONE, TWO &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, ONE, TWO);  <span class="comment">// 0 1</span></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>enum</code>是一个关键字，后面跟着一个代码块，常量就在代码内声明。<code>ONE</code>和<code>TWO</code>就是两个 Enum 常量。</p><p>​常量之间使用逗号分隔。最后一个常量后面的尾逗号，可以省略，也可以保留。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> ONE, TWO, &#125;;</span><br></pre></td></tr></table></figure><p>​<strong>由于Enum 会自动编号，因此可以不必为常量赋值。C 语言会自动从0开始递增，为常量赋值。但是，C 语言也允许为 ENUM 常量指定值，不过只能指定为整数，不能是其他类型。因此，任何可以使用整数的场合，都可以使用 Enum 常量。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> ONE = <span class="number">1</span>, TWO = <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, ONE, TWO);  <span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure><p>​<strong>Enum 常量可以是不连续的值。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> X = <span class="number">2</span>, Y = <span class="number">18</span>, Z = <span class="number">-2</span> &#125;;</span><br></pre></td></tr></table></figure><p>​<strong>Enum 常量也可以是同一个值。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> X = <span class="number">2</span>, Y = <span class="number">2</span>, Z = <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure><p>​<strong>如果一组常量之中，有些指定了值，有些没有指定。那么，没有指定值的常量会从上一个指定了值的常量，开始自动递增赋值。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    A,     <span class="comment">// 0</span></span><br><span class="line">    B,     <span class="comment">// 1</span></span><br><span class="line">    C = <span class="number">4</span>, <span class="comment">// 4</span></span><br><span class="line">    D,     <span class="comment">// 5</span></span><br><span class="line">    E,     <span class="comment">// 6</span></span><br><span class="line">    F = <span class="number">3</span>, <span class="comment">// 3</span></span><br><span class="line">    G,     <span class="comment">// 4</span></span><br><span class="line">    H      <span class="comment">// 5</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​<strong>Enum 的作用域与变量相同。如果是在顶层声明，那么在整个文件内都有效；如果是在代码块内部声明，则只对该代码块有效。如果与使用<code>int</code>声明的常量相比，Enum 的好处是更清晰地表示代码意图。</strong></p><h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><p>​<strong>C 语言编译器在编译程序之前，会先使用预处理器（preprocessor）处理代码。</strong></p><p>​<strong>预处理器首先会清理代码，进行删除注释、多行语句合成一个逻辑行等工作。然后，执行<code>#</code>开头的预处理指令。</strong></p><p>​<strong>预处理指令可以出现在程序的任何地方，但是习惯上，往往放在代码的开头部分。</strong></p><p>​每个预处理指令都以<code>#</code>开头，放在一行的行首，指令前面可以有空白字符（比如空格或制表符）。<code>#</code>和指令的其余部分之间也可以有空格，但是为了兼容老的编译器，一般不留空格。</p><p>​所有预处理指令都是一行的，除非在行尾使用反斜杠，将其折行。指令结尾处不需要分号。</p><h3 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h3><p>​<code>#define</code>是最常见的预处理指令，用来将指定的词替换成另一个词。它的参数分成两个部分，第一个参数就是要被替换的部分，其余参数是替换后的内容。<strong>每条替换规则，称为一个宏（macro）。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100</span></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>#define</code>指定将源码里面的<code>MAX</code>，全部替换成<code>100</code>。<code>MAX</code>就称为一个宏。</p><p>​宏的名称不允许有空格，而且必须遵守 C 语言的变量命名规则，只能使用字母、数字与下划线（<code>_</code>），且首字符不能是数字。</p><p>​<strong>宏是原样替换，指定什么内容，就一模一样替换成什么内容。</strong></p><p>​<strong><code>#define</code>指令可以出现在源码文件的任何地方，从指令出现的地方到文件末尾都有效。</strong>习惯上，会将<code>#define</code>放在源码文件的头部。它的主要好处是，会使得程序的可读性更好，也更容易修改。</p><p>​<strong><code>#define</code>指令从<code>#</code>开始，一直到换行符为止。如果整条指令过长，可以在折行处使用反斜杠，延续到下一行。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OW <span class="string">&quot;C programming language is invented \</span></span></span><br><span class="line"><span class="string"><span class="meta">in 1970s.&quot;</span></span></span><br></pre></td></tr></table></figure><p>​上面示例中，第一行结尾的反斜杠将<code>#define</code>指令拆成两行。</p><p>​<strong><code>#define</code>允许多重替换，即一个宏可以包含另一个宏。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TWO 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOUR TWO*TWO</span></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>FOUR</code>会被替换成<code>2*2</code>。</p><p>​<strong>注意，如果宏出现在字符串里面（即出现在双引号中），或者是其他标识符的一部分，就会失效，并不会发生替换。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TWO 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 TWO</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;TWO\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 22</span></span><br><span class="line"><span class="type">const</span> TWOs = <span class="number">22</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, TWOs);</span><br></pre></td></tr></table></figure><p>​上面示例中，双引号里面的<code>TWO</code>，以及标识符<code>TWOs</code>，都不会被替换。</p><p>​<strong>同名的宏可以重复定义，只要定义是相同的，就没有问题。如果定义不同，就会报错。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOO hello</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOO hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BAR hello</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BAR world</span></span><br></pre></td></tr></table></figure><p>​上面示例中，宏<code>FOO</code>没有变化，所以可以重复定义，宏<code>BAR</code>发生了变化，就报错了。</p><h3 id="带参数的宏"><a href="#带参数的宏" class="headerlink" title="带参数的宏"></a>带参数的宏</h3><p>​<strong>宏的强大之处在于，它的名称后面可以使用括号，指定接受一个或多个参数。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(X) X*X</span></span><br></pre></td></tr></table></figure><p>​上面示例中，宏<code>SQUARE</code>可以接受一个参数<code>X</code>，替换成<code>X*X</code>。</p><p>​<strong>注意，宏的名称与左边圆括号之间，不能有空格。</strong></p><p>这个宏的用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换成 z = 2*2;</span></span><br><span class="line">z = SQUARE(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>​<strong>这种写法很像函数，但又不是函数，而是完全原样的替换，会跟函数有不一样的行为。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(X) X*X</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出19</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, SQUARE(<span class="number">3</span> + <span class="number">4</span>));</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>SQUARE(3 + 4)</code>如果是函数，输出的应该是49（<code>7*7</code>）；宏是原样替换，所以替换成<code>3 + 4*3 + 4</code>，最后输出19。</p><p>​<strong>可以看到，原样替换可能导致意料之外的行为。解决办法就是在定义宏的时候，尽量多使用圆括号，这样可以避免很多意外。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(X) ((X) * (X))</span></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>SQUARE(X)</code>替换后的形式，有两层圆括号，就可以避免很多错误的发生。</p><p>​<strong>宏的参数也可以是空的。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> getchar() getc(stdin)</span></span><br></pre></td></tr></table></figure><p>​上面示例中，宏<code>getchar()</code>的参数就是空的。这种情况其实可以省略圆括号，但是加上了，会让它看上去更像函数。</p><p>​<strong>一般来说，带参数的宏都是一行的。下面是两个例子。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x, y) ((x)&gt;(y)?(x):(y))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_EVEN(n) ((n)%2==0)</span></span><br></pre></td></tr></table></figure><p>​<strong>如果宏的长度过长，可以使用反斜杠（<code>\</code>）折行，将宏写成多行。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_NUMS_TO_PRODUCT(a, b)       \</span></span><br><span class="line"><span class="meta">    &#123;                                     \</span></span><br><span class="line"><span class="meta">        int product = (a) * (b);          \</span></span><br><span class="line"><span class="meta">        for (int i = 0; i &lt; product; i++) \</span></span><br><span class="line"><span class="meta">        &#123;                                 \</span></span><br><span class="line"><span class="meta">            printf(<span class="string">&quot;%d\n&quot;</span>, i);            \</span></span><br><span class="line"><span class="meta">        &#125;                                 \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br></pre></td></tr></table></figure><p>​<strong>上面示例中，替换文本放在大括号里面，这是为了创造一个块作用域，避免宏内部的变量污染外部。</strong></p><p>​<strong>带参数的宏也可以嵌套，一个宏里面包含另一个宏。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> QUADP(a, b, c) ((-(b) + sqrt((b) * (b) - 4 * (a) * (c))) / (2 * (a)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUADM(a, b, c) ((-(b) - sqrt((b) * (b) - 4 * (a) * (c))) / (2 * (a)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUAD(a, b, c) QUADP(a, b, c), QUADM(a, b, c)</span></span><br></pre></td></tr></table></figure><p>​上面示例是一元二次方程组求解的宏，由于存在正负两个解，所以宏<code>QUAD</code>先替换成另外两个宏<code>QUADP</code>和<code>QUADM</code>，后者再各自替换成一个解。</p><p>​那么，什么时候使用带参数的宏，什么时候使用函数呢？</p><p>​<strong>一般来说，应该首先使用函数，它的功能更强、更容易理解。宏有时候会产生意想不到的替换结果，而且往往只能写成一行，除非对换行符进行转义，但是可读性就变得很差。</strong></p><p>​<strong>宏的优点是相对简单，本质上是字符串替换，不涉及数据类型，不像函数必须定义数据类型。而且，宏将每一处都替换成实际的代码，省掉了函数调用的开销，所以性能会好一些。另外，以前的代码大量使用宏，尤其是简单的数学运算，为了读懂前人的代码，需要对它有所了解。</strong></p><h3 id="运算符，-运算符"><a href="#运算符，-运算符" class="headerlink" title="#运算符，##运算符"></a><code>#</code>运算符，<code>##</code>运算符</h3><p>​<strong>由于宏不涉及数据类型，所以替换以后可能为各种类型的值。如果希望替换后的值为字符串，可以在替换文本的参数前面加上<code>#</code>。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STR(x) #x</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 printf(&quot;%s\n&quot;, &quot;3.14159&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, STR(<span class="number">3.14159</span>));</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>STR(3.14159)</code>会被替换成<code>3.14159</code>。如果<code>x</code>前面没有<code>#</code>，这会被解释成一个浮点数，有了<code>#</code>以后，就会被转换成字符串。下面是另一个例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> XNAME(n) <span class="string">&quot;x&quot;</span>#n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 x4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, XNAME(<span class="number">4</span>));</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>#n</code>指定参数输出为字符串，再跟前面的字符串结合，最终输出为<code>&quot;x4&quot;</code>。如果不加<code>#</code>，这里实现起来就很麻烦了。</p><p>​<strong>如果替换后的文本里面，参数需要跟其他标识符连在一起，组成一个新的标识符，可以使用<code>##</code>运算符。它起到粘合作用，将参数“嵌入”一个标识符之中。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MK_ID(n) i##n</span></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>n</code>是宏<code>MK_ID</code>的参数，这个参数需要跟标识符<code>i</code>粘合在一起，这时<code>i</code>和<code>n</code>之间就要使用<code>##</code>运算符。下面是这个宏的用法示例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MK_ID</span><span class="params">(<span class="number">1</span>)</span>, <span class="title function_">MK_ID</span><span class="params">(<span class="number">2</span>)</span>, <span class="title function_">MK_ID</span><span class="params">(<span class="number">3</span>)</span>;</span><br><span class="line"><span class="comment">// 替换成</span></span><br><span class="line"><span class="type">int</span> i1, i2, i3;</span><br></pre></td></tr></table></figure><p>​上面示例中，替换后的文本<code>i1</code>、<code>i2</code>、<code>i3</code>是三个标识符，参数<code>n</code>是标识符的一部分。<strong>从这个例子可以看到，<code>##</code>运算符的一个主要用途是批量生成变量名和标识符</strong>。</p><h3 id="不定参数的宏"><a href="#不定参数的宏" class="headerlink" title="不定参数的宏"></a>不定参数的宏</h3><p>​<strong>宏的参数还可以是不定数量的（即不确定有多少个参数），<code>...</code>表示剩余的参数。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> X(a, b, ...) (10*(a) + 20*(b)), __VA_ARGS__</span></span><br></pre></td></tr></table></figure><p>​<strong>上面示例中，<code>X(a, b, ...)</code>表示<code>X()</code>至少有两个参数，多余的参数使用<code>...</code>表示。在替换文本中，<code>__VA_ARGS__</code>代表多余的参数（每个参数之间使用逗号分隔）</strong>。下面是用法示例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X(<span class="number">5</span>, <span class="number">4</span>, <span class="number">3.14</span>, <span class="string">&quot;Hi!&quot;</span>, <span class="number">12</span>)</span><br><span class="line"><span class="comment">// 替换成</span></span><br><span class="line">(<span class="number">10</span>*(<span class="number">5</span>) + <span class="number">20</span>*(<span class="number">4</span>)), <span class="number">3.14</span>, <span class="string">&quot;Hi!&quot;</span>, <span class="number">12</span></span><br></pre></td></tr></table></figure><p>​<strong>注意，<code>...</code>只能替代宏的尾部参数，不能写成下面这样。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRONG(X, ..., Y) #X #__VA_ARGS__ #Y</span></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>...</code>替代中间部分的参数，这是不允许的，会报错。</p><p>​<strong><code>__VA_ARGS__</code>前面加上一个<code>#</code>号，可以让输出变成一个字符串。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> X(...) #__VA_ARGS__</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, X(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));  <span class="comment">// Prints &quot;1, 2, 3&quot;</span></span><br></pre></td></tr></table></figure><h3 id="undef"><a href="#undef" class="headerlink" title="#undef"></a>#undef</h3><p>​<strong><code>#undef</code>指令用来取消已经使用<code>#define</code>定义的宏。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIMIT 400</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> LIMIT</span></span><br></pre></td></tr></table></figure><p>​上面示例的<code>undef</code>指令取消已经定义的宏<code>LIMIT</code>，后面就可以重新用 LIMIT 定义一个宏。</p><p>​<strong>有时候想重新定义一个宏，但不确定是否以前定义过，就可以先用<code>#undef</code>取消，然后再定义。因为同名的宏如果两次定义不一样，会报错，而<code>#undef</code>的参数如果是不存在的宏，并不会报错。</strong></p><p>​<strong>GCC 的<code>-U</code>选项可以在命令行取消宏的定义，相当于<code>#undef</code>。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -ULIMIT foo.c</span><br></pre></td></tr></table></figure><p>​<strong>上面示例中的<code>-U</code>参数，取消了宏<code>LIMIT</code>，相当于源文件里面的<code>#undef LIMIT</code>。</strong></p><h3 id="include"><a href="#include" class="headerlink" title="#include"></a>#include</h3><p>​<strong><code>#include</code>指令用于编译时将其他源码文件，加载进入当前文件。它有两种形式。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形式一</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;foo.h&gt;</span> <span class="comment">// 加载系统提供的文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 形式二</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foo.h&quot;</span> <span class="comment">// 加载用户提供的文件</span></span></span><br></pre></td></tr></table></figure><p>​<strong>形式一，文件名写在尖括号里面，表示该文件是系统提供的，通常是标准库的库文件，不需要写路径。因为编译器会到系统指定的安装目录里面，去寻找这些文件。</strong></p><p>​<strong>形式二，文件名写在双引号里面，表示该文件由用户提供，具体的路径取决于编译器的设置，可能是当前目录，也可能是项目的工作目录。如果所要包含的文件在其他位置，就需要指定路径，下面是一个例子。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;/usr/local/lib/foo.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>​<strong>GCC 编译器的<code>-I</code>参数，也可以用来指定<code>include</code>命令中用户文件的加载路径。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -Iinclude/ -o code code.c</span><br></pre></td></tr></table></figure><p>​上面命令中，<code>-Iinclude/</code>指定从当前目录的<code>include</code>子目录里面，加载用户自己的文件。</p><p>​<strong><code>#include</code>最常见的用途，就是用来加载包含函数原型的头文件（后缀名为<code>.h</code>）。多个<code>#include</code>指令的顺序无关紧要，多次包含同一个头文件也是合法的。</strong></p><h3 id="if…-endif"><a href="#if…-endif" class="headerlink" title="#if…#endif"></a>#if…#endif</h3><p>​<strong><code>#if...#endif</code>指令用于预处理器的条件判断，满足条件时，内部的行会被编译，否则就被编译器忽略。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.1415</span>; <span class="comment">// 不会执行</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>​<strong>上面示例中，<code>#if</code>后面的<code>0</code>，表示判断条件不成立。所以，内部的变量定义语句会被编译器忽略。<code>#if 0</code>这种写法常用来当作注释使用，不需要的代码就放在<code>#if 0</code>里面。</strong></p><p>​<strong><code>#if</code>后面的判断条件，通常是一个表达式。如果表达式的值不等于<code>0</code>，就表示判断条件为真，编译内部的语句；如果表达式的值等于0，表示判断条件为伪，则忽略内部的语句。</strong></p><p>​<strong><code>#if...#endif</code>之间还可以加入<code>#else</code>指令，用于指定判断条件不成立时，需要编译的语句。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FOO 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FOO</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;defined\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;not defined\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>​上面示例中，宏<code>FOO</code>如果定义过，会被替换成<code>1</code>，从而输出<code>defined</code>，否则输出<code>not defined</code>。</p><p>​<strong>如果有多个判断条件，还可以加入<code>#elif</code>命令。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> HAPPY_FACTOR == 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m not happy!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> HAPPY_FACTOR == 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m just regular\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m extra happy!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>​上面示例中，通过<code>#elif</code>指定了第二重判断。<strong>注意，<code>#elif</code>的位置必须在<code>#else</code>之前。如果多个判断条件皆不满足，则执行<code>#else</code>的部分。</strong></p><p>​<strong>没有定义过的宏，等同于<code>0</code>。因此如果<code>UNDEFINED</code>是一个没有定义过的宏，那么<code>#if UNDEFINED</code>为伪，而<code>#if !UNDEFINED</code>为真。</strong></p><p>​<strong><code>#if</code>的常见应用就是打开（或关闭）调试模式。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;value of i : %d\n&quot;</span>, i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;value of j : %d\n&quot;</span>, j);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>​<strong>上面示例中，通过将<code>DEBUG</code>设为<code>1</code>，就打开了调试模式，可以输出调试信息。</strong></p><p>​GCC 的<code>-D</code>参数可以在编译时指定宏的值，因此可以很方便地打开调试开关。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -DDEBUG=1 foo.c</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>-D</code>参数指定宏<code>DEBUG</code>为<code>1</code>，相当于在代码中指定<code>#define DEBUG 1</code>。</p><h3 id="ifdef…-endif"><a href="#ifdef…-endif" class="headerlink" title="#ifdef…#endif"></a>#ifdef…#endif</h3><p>​<strong><code>#ifdef...#endif</code>指令用于判断某个宏是否定义过。</strong></p><p>​<strong>有时源码文件可能会重复加载某个库，为了避免这种情况，可以在库文件里使用<code>#define</code>定义一个空的宏。通过这个宏，判断库文件是否被加载了。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EXTRA_HAPPY</span></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>EXTRA_HAPPY</code>就是一个空的宏。</p><p>​然后，源码文件使用<code>#ifdef...#endif</code>检查这个宏是否定义过。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> EXTRA_HAPPY</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m extra happy!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>​<strong>上面示例中，<code>#ifdef</code>检查宏<code>EXTRA_HAPPY</code>是否定义过。如果已经存在，表示加载过库文件，就会打印一行提示。</strong></p><p>​<strong><code>#ifdef</code>可以与<code>#else</code>指令配合使用。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> EXTRA_HAPPY</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m extra happy!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m just regular\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>​上面示例中，如果宏<code>EXTRA_HAPPY</code>没有定义过，就会执行<code>#else</code>的部分。</p><p>​<strong><code>#ifdef...#else...#endif</code>可以用来实现条件加载。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAVIS</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foo.h&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> STABLES 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bar.h&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> STABLES 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>​<strong>上面示例中，通过判断宏<code>MAVIS</code>是否定义过，实现加载不同的头文件。</strong></p><h3 id="defined-运算符"><a href="#defined-运算符" class="headerlink" title="defined 运算符"></a>defined 运算符</h3><p>​<strong><code>#ifdef</code>指令，等同于<code>#if defined</code>。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> FOO</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined FOO</span></span><br></pre></td></tr></table></figure><p>​<strong>上面示例中，<code>defined</code>是一个预处理运算符，如果它的参数是一个定义过的宏，就会返回1，否则返回0。</strong></p><p>​<strong>使用这种语法，可以完成多重判断。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined FOO</span></span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined BAR</span></span><br><span class="line">    x = <span class="number">3</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>​<strong>这个运算符的一个应用，就是对于不同架构的系统，加载不同的头文件。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined IBMPC</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ibmpc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined MAC</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mac.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;general.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>​<strong>上面示例中，不同架构的系统需要定义对应的宏。代码根据不同的宏，加载对应的头文件。</strong></p><h3 id="ifndef…-endif"><a href="#ifndef…-endif" class="headerlink" title="#ifndef…#endif"></a>#ifndef…#endif</h3><p>​<strong><code>#ifndef...#endif</code>指令跟<code>#ifdef...#endif</code>正好相反。它用来判断，如果某个宏没有被定义过，则执行指定的操作。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> EXTRA_HAPPY</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m extra happy!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EXTRA_HAPPY</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m just regular\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>​上面示例中，针对宏<code>EXTRA_HAPPY</code>是否被定义过，<code>#ifdef</code>和<code>#ifndef</code>分别指定了两种情况各自需要编译的代码。</p><p>​<strong><code>#ifndef</code>常用于防止重复加载。举例来说，为了防止头文件<code>myheader.h</code>被重复加载，可以把它放在<code>#ifndef...#endif</code>里面加载。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYHEADER_H</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> MYHEADER_H</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myheader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，宏<code>MYHEADER_H</code>对应文件名<code>myheader.h</code>的大写。只要<code>#ifndef</code>发现这个宏没有被定义过，就说明该头文件没有加载过，从而加载内部的代码，并会定义宏<code>MYHEADER_H</code>，防止被再次加载。</p><p>​<strong><code>#ifndef</code>等同于<code>#if !defined</code>。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FOO</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined FOO</span></span><br></pre></td></tr></table></figure><h3 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h3><p>​<strong>C 语言提供一些预定义的宏，可以直接使用。</strong></p><ul><li><code>__DATE__</code>：编译日期，格式为“Mmm dd yyyy”的字符串（比如 Nov 23 2021）。</li><li><code>__TIME__</code>：编译时间，格式为“hh:mm:ss”。</li><li><code>__FILE__</code>：当前文件名。</li><li><code>__LINE__</code>：当前行号。</li><li><code>__func__</code>：当前正在执行的函数名。该预定义宏必须在函数作用域使用。</li><li><code>__STDC__</code>：如果被设为1，表示当前编译器遵循 C 标准。</li><li><code>__STDC_HOSTED__</code>：如果被设为1，表示当前编译器可以提供完整的标准库；否则被设为0（嵌入式系统的标准库常常是不完整的）。</li><li><code>__STDC_VERSION__</code>：编译所使用的 C 语言版本，是一个格式为<code>yyyymmL</code>的长整数，C99 版本为“199901L”，C11 版本为“201112L”，C17 版本为“201710L”。</li></ul><p>下面示例打印这些预定义宏的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This function: %s\n&quot;</span>, __func__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This file: %s\n&quot;</span>, __FILE__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This line: %d\n&quot;</span>, __LINE__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Compiled on: %s %s\n&quot;</span>, __DATE__, __TIME__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;C Version: %ld\n&quot;</span>, __STDC_VERSION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出如下</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This function: main</span></span><br><span class="line"><span class="comment">This file: D:\develop\c++\c_code\temp.c</span></span><br><span class="line"><span class="comment">This line: 7</span></span><br><span class="line"><span class="comment">Compiled on: Nov 12 2022 21:51:12</span></span><br><span class="line"><span class="comment">C Version: 201710</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="line"><a href="#line" class="headerlink" title="#line"></a>#line</h3><p>​<strong><code>#line</code>指令用于覆盖预定义宏<code>__LINE__</code>，将其改为自定义的行号。后面的行将从<code>__LINE__</code>的新值开始计数。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将下一行的行号重置为 300</span></span><br><span class="line"><span class="meta">#<span class="keyword">line</span> 300</span></span><br></pre></td></tr></table></figure><p>​上面示例中，紧跟在<code>#line 300</code>后面一行的行号，将被改成300，其后的行会在300的基础上递增编号。</p><p>​<strong><code>#line</code>还可以改掉预定义宏<code>__FILE__</code>，将其改为自定义的文件名。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">line</span> 300 <span class="string">&quot;newfilename&quot;</span></span></span><br></pre></td></tr></table></figure><p>​上面示例中，下一行的行号重置为<code>300</code>，文件名重置为<code>newfilename</code>。</p><h3 id="error"><a href="#error" class="headerlink" title="#error"></a>#error</h3><p>​<strong><code>#error</code>指令用于让预处理器抛出一个错误，终止编译。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __STDC_VERSION__ != 201112L</span></span><br><span class="line">    <span class="meta">#<span class="keyword">error</span> Not C11</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>​上面示例指定，如果编译器不使用 C11 标准，就中止编译，<strong>在vsc中会直接报错而无法编译</strong>。GCC 编译器会像下面这样报错。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">error</span> 指令:Not C11</span></span><br></pre></td></tr></table></figure><p>​上面示例中，GCC 使用 C99 标准编译，就报错了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> INT_MAX &lt; 100000</span></span><br><span class="line">    <span class="meta">#<span class="keyword">error</span> int type is too small</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，编译器一旦发现<code>INT</code>类型的最大值小于<code>100,000</code>，就会停止编译。</p><p><code>#error</code>指令也可以用在<code>#if...#elif...#else</code>的部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined WIN32</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined MAC_OS</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined LINUX</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">error</span> NOT support the operating system</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="pragma"><a href="#pragma" class="headerlink" title="#pragma"></a>#pragma</h3><p>​<strong><code>#pragma</code>指令用来修改编译器属性。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 C99 标准</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> c9x on</span></span><br></pre></td></tr></table></figure><p>​<strong>上面示例让编译器以 C99 标准进行编译。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> c9x on</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STDC_VERSION__ != 201710L</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> Not C17</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>​在vsc中会直接报错而无法编译。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">error</span> 指令:Not C17</span></span><br></pre></td></tr></table></figure><h2 id="I-x2F-O-函数"><a href="#I-x2F-O-函数" class="headerlink" title="I&#x2F;O 函数"></a>I&#x2F;O 函数</h2><p>​<strong>C 语言提供了一些函数，用于与外部设备通信，称为输入输出函数，简称 I&#x2F;O 函数。输入（import）指的是获取外部数据，输出（export）指的是向外部传递数据。</strong></p><h3 id="缓存和字节流"><a href="#缓存和字节流" class="headerlink" title="缓存和字节流"></a>缓存和字节流</h3><p>​<strong>严格地说，输入输出函数并不是直接与外部设备通信，而是通过缓存（buffer）进行间接通信。</strong></p><p>​普通文件一般都保存在磁盘上面，跟 CPU 相比，磁盘读取或写入数据是一个很慢的操作。所以，程序直接读写磁盘是不可行的，可能每执行一行命令，都必须等半天。<strong>C 语言的解决方案，就是只要打开一个文件，就在内存里面为这个文件设置一个缓存区。</strong></p><p>​程序向文件写入数据时，程序先把数据放入缓存，等到缓存满了，再把里面的数据会一次性写入磁盘文件。这时，缓存区就空了，程序再把新的数据放入缓存，重复整个过程。</p><p>​程序从文件读取数据时，文件先把一部分数据放到缓存里面，然后程序从缓存获取数据，等到缓存空了，磁盘文件再把新的数据放入缓存，重复整个过程。</p><p>​内存的读写速度比磁盘快得多，缓存的设计减少了读写磁盘的次数，大大提高了程序的执行效率。另外，一次性移动大块数据，要比多次移动小块数据快得多。</p><p>​<strong>这种读写模式，对于程序来说，就有点像水流（stream），不是一次性读取或写入所有数据，而是一个持续不断的过程。先操作一部分数据，等到缓存吞吐完这部分数据，再操作下一部分数据。这个过程就叫做字节流操作。</strong></p><p>​<strong>由于缓存读完就空了，所以字节流读取都是只能读一次，第二次就读不到了。这跟读取文件很不一样。</strong></p><p>​<strong>C 语言的输入输出函数，凡是涉及读写文件，都是属于字节流操作。</strong>输入函数从文件获取数据，操作的是输入流；输出函数向文件写入数据，操作的是输出流。</p><h3 id="printf"><a href="#printf" class="headerlink" title="printf()"></a>printf()</h3><p>​<code>printf()</code>是最常用的输出函数，用于屏幕输出，原型定义在头文件<code>stdio.h</code>，详见基本语法。</p><h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf()"></a>scanf()</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>​<code>scanf()</code>函数用于读取用户的键盘输入。程序运行到这个语句时，会停下来，等待用户从键盘输入。用户输入数据、按下回车键后，<code>scanf()</code>就会处理用户的输入，将其存入变量。它的原型定义在头文件<code>stdio.h</code>。<code>scanf()</code>的语法跟<code>printf()</code>类似。</p><p>​<strong><code>scanf()</code>处理数值占位符时，会自动过滤空白字符，包括空格、制表符、换行符等。所以，用户输入的数据之间，有一个或多个空格不影响<code>scanf()</code>解读数据。另外，用户使用回车键，将输入分成几行，也不影响解读。</strong></p><p>​<strong>注意，针对于scanf函数能否读取换行\n这个问题，我们需要区分不同情况展开讨论。这里不做深究，详情请见：</strong><a href="https://blog.csdn.net/m0_55653575/article/details/120933076">关于C语言中scanf函数换行符\n的读取问题概论</a></p><p>​<strong><code>scanf()</code>处理用户输入的原理是，用户的输入先放入缓存，等到按下回车键后，按照占位符对缓存进行解读。解读用户输入时，会从上一次解读遗留的第一个字符开始，直到读完缓存，或者遇到第一个不符合条件的字符为止。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">float</span> y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户输入 &quot;    -13.45e12# 0&quot;</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;y);</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>scanf()</code>读取用户输入时，<code>%d</code>占位符会忽略起首的空格，从<code>-</code>处开始获取数据，读取到<code>-13</code>停下来，因为后面的<code>.</code>不属于整数的有效字符。这就是说，占位符<code>%d</code>会读到<code>-13</code>。</p><p>​第二次调用<code>scanf()</code>时，就会从上一次停止解读的地方，继续往下读取。这一次读取的首字符是<code>.</code>，由于对应的占位符是<code>%f</code>，会读取到<code>.45e12</code>，这是采用科学计数法的浮点数格式。后面的<code>#</code>不属于浮点数的有效字符，所以会停在这里。</p><p>​<strong><code>scanf()</code>的返回值是一个整数，表示成功读取的变量个数。如果没有读取任何项，或者匹配失败，则返回<code>0</code>。如果读取到文件结尾，则返回常量 EOF。</strong></p><h4 id="占位符-1"><a href="#占位符-1" class="headerlink" title="占位符"></a>占位符</h4><p>​<code>scanf()</code>常用的占位符如下，与<code>printf()</code>的占位符基本一致。</p><ul><li><code>%c</code>：字符。</li><li><code>%d</code>：整数。</li><li><code>%f</code>：<code>float</code>类型浮点数。</li><li><code>%lf</code>：<code>double</code>类型浮点数。</li><li><code>%Lf</code>：<code>long double</code>类型浮点数。</li><li><code>%s</code>：字符串。</li><li><code>%[]</code>：在方括号中指定一组匹配的字符（比如<code>%[0-9]</code>），遇到不在集合之中的字符，匹配将会停止。</li></ul><p>​上面所有占位符之中，除了<code>%c</code>以外，都会自动忽略起首的空白字符。**<code>%c</code>不忽略空白字符，总是返回当前第一个字符，无论该字符是否为空格。如果要强制跳过字符前的空白字符，可以写成<code>scanf(&quot; %c&quot;, &amp;ch)</code>，即<code>%c</code>前加上一个空格，表示跳过零个或多个空白字符。**</p><p>​<strong>下面要特别说一下占位符<code>%s</code>，它其实不能简单地等同于字符串。它的规则是，从当前第一个非空白字符开始读起，直到遇到空白字符（即空格、换行符、制表符等）为止。</strong>因为<code>%s</code>不会包含空白字符，所以无法用来读取多个单词，除非多个<code>%s</code>一起使用。这也意味着，**<code>scanf()</code>不适合读取可能包含空格的字符串<strong>，比如书名或歌曲名。另外，</strong><code>scanf()</code>遇到<code>%s</code>占位符，会在字符串变量末尾存储一个空字符<code>\0</code>。**</p><p>​<strong><code>scanf()</code>将字符串读入字符数组时，不会检测字符串是否超过了数组长度。</strong>所以，储存字符串时，很可能会超过数组的边界，导致预想不到的结果。为了防止这种情况，<strong>使用<code>%s</code>占位符时，应该指定读入字符串的最长长度，即写成<code>%[m]s</code>，其中的<code>[m]</code>是一个整数，表示读取字符串的最大长度，后面的字符将被丢弃。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">11</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%10s&quot;</span>, name);</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>name</code>是一个长度为11的字符数组，<code>scanf()</code>的占位符<code>%10s</code>表示最多读取用户输入的10个字符，后面的字符将被丢弃，这样就不会有数组溢出的风险了。</p><h4 id="赋值忽略符"><a href="#赋值忽略符" class="headerlink" title="赋值忽略符"></a>赋值忽略符</h4><p>​有时，用户的输入可能不符合预定的格式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d-%d-%d&quot;</span>, &amp;year, &amp;month, &amp;day);</span><br></pre></td></tr></table></figure><p>​上面示例中，如果用户输入<code>2020-01-01</code>，就会正确解读出年、月、日。问题是用户可能输入其他格式，比如<code>2020/01/01</code>，这种情况下，<code>scanf()</code>解析数据就会失败。</p><p>​为了避免这种情况，**<code>scanf()</code>提供了一个赋值忽略符（assignment suppression character）<code>*</code>。只要把<code>*</code>加在任何占位符的百分号后面，该占位符就不会返回值，解析后将被丢弃。**</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%*c%d%*c%d&quot;</span>, &amp;year, &amp;month, &amp;day);</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>%*c</code>就是在占位符的百分号后面，加入了赋值忽略符<code>*</code>，表示这个占位符没有对应的变量，解读后不必返回。</p><h3 id="sscanf"><a href="#sscanf" class="headerlink" title="sscanf()"></a>sscanf()</h3><p>​<strong><code>sscanf()</code>函数与<code>scanf()</code>很类似，不同之处是<code>sscanf()</code>从字符串里面，而不是从用户输入获取数据。</strong>它的原型定义在头文件<code>stdio.h</code>里面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br></pre></td></tr></table></figure><p>​<strong><code>sscanf()</code>的第一个参数是一个字符串指针，用来从其中获取数据。其他参数都与<code>scanf()</code>相同。</strong></p><p>​<strong><code>sscanf()</code>主要用来处理其他输入函数读入的字符串，从其中提取数据。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fgets(str, <span class="keyword">sizeof</span>(str), <span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">sscanf</span>(str, <span class="string">&quot;%d%d&quot;</span>, &amp;i, &amp;j);</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>fgets()</code>先从标准输入获取了一行数据（<code>fgets()</code>的介绍后面会说），存入字符数组<code>str</code>。然后，<code>sscanf()</code>再从字符串<code>str</code>里面提取两个整数，放入变量<code>i</code>和<code>j</code>。</p><p>​<strong><code>sscanf()</code>的一个好处是，它的数据来源不是流数据，所以可以反复使用，不像<code>scanf()</code>的数据来源是流数据，只能读取一次。</strong></p><p>​<strong><code>sscanf()</code>的返回值是成功赋值的变量的数量，如果提取失败，返回常量 EOF。</strong></p><h3 id="getchar-，putchar"><a href="#getchar-，putchar" class="headerlink" title="getchar()，putchar()"></a>getchar()，putchar()</h3><h4 id="getchar"><a href="#getchar" class="headerlink" title="getchar()"></a>getchar()</h4><p>​<strong><code>getchar()</code>函数返回用户从键盘输入的一个字符，使用时不带有任何参数。程序运行到这个命令就会暂停，等待用户从键盘输入，等同于使用<code>scanf()</code>方法读取一个字符。</strong>它的原型定义在头文件<code>stdio.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line">ch = getchar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br></pre></td></tr></table></figure><p>​<strong><code>getchar()</code>不会忽略起首的空白字符，总是返回当前读取的第一个字符，无论是否为空格。如果读取失败，返回常量 EOF，由于 EOF 通常是<code>-1</code>，所以返回值的类型要设为 int，而不是 char。</strong></p><p>​由于<code>getchar()</code>返回读取的字符，所以可以用在循环条件之中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><p>​上面示例中，只有读到的字符等于换行符（<code>\n</code>），才会退出循环，常用来跳过某行。<code>while</code>循环的循环体没有任何语句，表示对该行不执行任何操作。</p><p>​下面的例子是跳过空格字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ch = getchar()) == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><p>​<strong>上面示例中，结束循环后，变量<code>ch</code>等于第一个非空格字符。</strong></p><h4 id="putchar"><a href="#putchar" class="headerlink" title="putchar()"></a>putchar()</h4><p>​<strong><code>putchar()</code>函数将它的参数字符输出到屏幕，等同于使用<code>printf()</code>输出一个字符</strong>。它的原型定义在头文件<code>stdio.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">putchar</span>(ch);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ch);</span><br></pre></td></tr></table></figure><p>​<strong>操作成功时，<code>putchar()</code>返回输出的字符，否则返回常量 EOF。</strong></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>​<strong>由于<code>getchar()</code>和<code>putchar()</code>这两个函数的用法，要比<code>scanf()</code>和<code>printf()</code>更简单，而且通常是用宏来实现，所以要比<code>scanf()</code>和<code>printf()</code>更快。如果操作单个字符，建议优先使用这两个函数。</strong></p><h3 id="puts-，gets"><a href="#puts-，gets" class="headerlink" title="puts()，gets()"></a>puts()，gets()</h3><h4 id="puts"><a href="#puts" class="headerlink" title="puts()"></a>puts()</h4><p>​<strong><code>puts()</code>函数用于将参数字符串显示在屏幕（stdout）上，并且自动在字符串末尾添加换行符。</strong>它的原型定义在头文件<code>stdio.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Here are some messages:&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>puts()</code>在屏幕上输出两行内容。</p><p>​<strong>写入成功时，<code>puts()</code>返回一个非负整数，否则返回常量 EOF。</strong></p><h4 id="gets"><a href="#gets" class="headerlink" title="gets()"></a>gets()</h4><p>​<strong><code>gets()</code>函数以前用于从<code>stdin</code>读取整行输入，现在已经被废除了，仍然放在这里介绍一下。</strong></p><p>​<strong>该函数读取用户的一行输入，不会跳过起始处的空白字符，直到遇到换行符为止。这个函数会丢弃换行符，将其余字符放入参数变量，并在这些字符的末尾添加一个空字符<code>\0</code>，使其成为一个字符串。</strong></p><p>​它经常与<code>puts()</code>配合使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> words[<span class="number">81</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Enter a string, please&quot;</span>);</span><br><span class="line">gets(words);</span><br></pre></td></tr></table></figure><p>​上面示例使用<code>puts()</code>在屏幕上输出提示，然后使用<code>gets()</code>获取用户的输入。</p><p>​<strong>由于<code>gets()</code>获取的字符串，可能超过字符数组变量的最大长度，有安全风险，建议不要使用，改为使用<code>fgets()</code>。</strong></p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h3><p>​<strong>C 语言提供了一个 FILE 数据结构，记录了操作一个文件所需要的信息。该结构定义在头文件<code>stdio.h</code>，所有文件操作函数都要通过这个数据结构，获取文件信息。</strong></p><p>​开始操作一个文件之前，就要定义一个指向该文件的 FILE 指针，相当于获取一块内存区域，用来保存文件信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE* fp;</span><br></pre></td></tr></table></figure><p>​上面示例定义了一个 FILE 指针<code>fp</code>。</p><p>下面是一个读取文件的完整示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    fp = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c = fgetc(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：</p><p>​上面示例中，新建文件指针<code>fp</code>以后，依次使用了下面三个文件操作函数，分成三个步骤。其他的文件操作，大致上也是这样的步骤。</p><p>​<strong>第一步，使用<code>fopen()</code>打开指定文件，返回一个 File 指针。如果出错，返回 NULL。</strong></p><p>​它相当于将指定文件的信息与新建的文件指针<code>fp</code>相关联，在 FILE 结构内部记录了这样一些信息：文件内部的当前读写位置、读写报错的记录、文件结尾指示器、缓冲区开始位置的指针、文件标识符、一个计数器（统计拷贝进缓冲区的字节数）等等。<strong>后继的操作就可以使用这个指针（而不是文件名）来处理指定文件。</strong></p><p>​<strong>同时，它还为文件建立一个缓存区。由于存在缓存区，也可以说<code>fopen()</code>函数“打开一个了流”，后继的读写文件都是流模式。</strong></p><p>​<strong>第二步，使用读写函数，从文件读取数据，或者向文件写入数据。上例使用了<code>fgetc()</code>函数，从已经打开的文件里面，读取一个字符。</strong></p><p>​<code>fgetc()</code>一调用，文件的数据块先拷贝到缓冲区。不同的计算机有不同的缓冲区大小，一般是512字节或是它的倍数，如4096或16384。随着计算机硬盘容量越来越大，缓冲区也越来越大。</p><p>​<code>fgetc()</code>从缓冲区读取数据，同时将文件指针内部的读写位置指示器，指向所读取字符的下一个字符。<strong>所有的文件读取函数都使用相同的缓冲区，后面再调用任何一个读取函数，都将从指示器指向的位置，即上一次读取函数停止的位置开始读取。</strong></p><p>​当读取函数发现已读完缓冲区里面的所有字符时，会请求把下一个缓冲区大小的数据块，从文件拷贝到缓冲区中。读取函数就以这种方式，读完文件的所有内容，直到文件结尾。不过，上例是只从缓存区读取一个字符。<strong>当函数在缓冲区里面，读完文件的最后一个字符时，就把 FILE 结构里面的文件结尾指示器设置为真。于是，下一次再调用读取函数时，会返回常量 EOF。EOF 是一个整数值，代表文件结尾，一般是<code>-1</code>。</strong></p><p>​<strong>第三步，<code>fclose()</code>关闭文件，同时清空缓存区。</strong></p><p>​<strong>上面是文件读取的过程，文件写入也是类似的方式，先把数据写入缓冲区，当缓冲区填满后，缓存区的数据将被转移到文件中。</strong></p><h3 id="fopen"><a href="#fopen" class="headerlink" title="fopen()"></a>fopen()</h3><p>​<code>fopen()</code>函数用来打开文件。所有文件操作的第一步，都是使用<code>fopen()</code>打开指定文件。这个函数的原型定义在头文件<code>stdio.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE* <span class="title function_">fopen</span><span class="params">(<span class="type">char</span>* filename, <span class="type">char</span>* mode)</span>;</span><br></pre></td></tr></table></figure><p>​它接受两个参数。<strong>第一个参数是文件名(可以包含路径)，第二个参数是模式字符串，指定对文件执行的操作</strong>，比如下面的例子中，<code>r</code>表示以读取模式打开文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fp = fopen(<span class="string">&quot;in.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br></pre></td></tr></table></figure><p>​<strong>成功打开文件以后，<code>fopen()</code>返回一个 FILE 指针，其他函数可以用这个指针操作文件。如果无法打开文件（比如文件不存在或没有权限），会返回空指针 NULL。</strong>所以，执行<code>fopen()</code>以后，最好判断一下，有没有打开成功。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t open file!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面示例中，如果<code>fopen()</code>返回一个空指针，程序就会报错。</p><p><strong><code>fopen()</code>的模式字符串有以下几种：</strong></p><ul><li><code>r</code>：读模式，只用来读取数据。如果文件不存在，返回 NULL 指针。</li><li><code>w</code>：写模式，只用来写入数据。<strong>如果文件存在，文件长度会被截为0，然后再写入；如果文件不存在，则创建该文件。</strong></li><li><code>a</code>：写模式，<strong>只用来在文件尾部追加数据。如果文件不存在，则创建该文件。</strong></li><li><code>r+</code>：读写模式。<strong>如果文件存在，指针指向文件开始处，可以在文件头部添加数据。</strong>如果文件不存在，返回 NULL 指针。</li><li><code>w+</code>：读写模式。<strong>如果文件存在，文件长度会被截为0，然后再写入数据。这种模式实际上读不到数据，反而会擦掉数据。如果文件不存在，则创建该文件。</strong></li><li><code>a+</code>：读写模式。<strong>如果文件存在，指针指向文件结尾，可以在现有文件末尾添加内容。如果文件不存在，则创建该文件。</strong></li></ul><p>​<strong><code>fopen()</code>函数会为打开的文件创建一个缓冲区。读模式下，创建的是读缓存区；写模式下，创建的是写缓存区；读写模式下，会同时创建两个缓冲区。C 语言通过缓存区，以流的形式，向文件读写数据。</strong></p><p>​数据在文件里面，都是以二进制形式存储。但是，读取的时候，有不同的解读方法：以原本的二进制形式解读，叫做“二进制流”；将二进制数据转成文本，以文本形式解读，叫做“文本流”。写入操作也是如此，分成以二进制写入和以文本写入，后者会多一个文本转二进制的步骤。</p><p>​<strong><code>fopen()</code>的模式字符串，默认是以文本流读写。如果添加<code>b</code>后缀（表示 binary），就会以“二进制流”进行读写。</strong>比如，<code>rb</code>是读取二进制数据模式，<code>wb</code>是写入二进制数据模式。</p><p>​<strong>模式字符串还有一个<code>x</code>后缀，表示独占模式（exclusive）。如果文件已经存在，则打开文件失败；如果文件不存在，则新建文件，打开后不再允许其他程序或线程访问当前文件。</strong>比如，<code>wx</code>表示以独占模式写入文件，如果文件已经存在，就会打开失败。</p><h3 id="标准流"><a href="#标准流" class="headerlink" title="标准流"></a>标准流</h3><p>​Linux 系统默认提供三个已经打开的文件，它们的文件指针如下。(这一点各操作系统都一样)</p><ul><li><strong><code>stdin</code>（标准输入）：默认来源为键盘，文件指针编号为<code>0</code>。</strong></li><li><strong><code>stdout</code>（标准输出）：默认目的地为显示器，文件指针编号为<code>1</code>。</strong></li><li><strong><code>stderr</code>（标准错误）：默认目的地为显示器，文件指针编号为<code>2</code>。</strong></li></ul><p>​<strong>Linux 系统的文件，不一定是数据文件，也可以是设备文件，即文件代表一个可以读或写的设备。文件指针<code>stdin</code>默认是把键盘看作一个文件，读取这个文件，就能获取用户的键盘输入。同理，<code>stdout</code>和<code>stderr</code>默认是把显示器看作一个文件，将程序的运行结果写入这个文件，用户就能看到运行结果了。它们的区别是，<code>stdout</code>写入的是程序的正常运行结果，<code>stderr</code>写入的是程序的报错信息。</strong></p><p>​这三个输入和输出渠道，是 Linux 默认提供的，所以分别称为标准输入（stdin）、标准输出（stdout）和标准错误（stderr）。因为它们的实现是一样的，都是文件流，所以合称为“标准流”。</p><p>​<strong>Linux 允许改变这三个文件指针（文件流）指向的文件，这称为重定向（redirection）。</strong></p><p>​<strong>如果标准输入不绑定键盘，而是绑定其他文件，可以在文件名前面加上小于号<code>&lt;</code>，跟在程序名后面。这叫做“输入重定向”（input redirection）。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ demo &lt; in.dat</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>demo</code>程序代码里面的<code>stdin</code>，将指向文件<code>in.dat</code>，即从<code>in.dat</code>获取数据。</p><p>​<strong>如果标准输出绑定其他文件，而不是显示器，可以在文件名前加上大于号<code>&gt;</code>，跟在程序名后面。这叫做“输出重定向”（output redirection）。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ demo &gt; out.dat</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>demo</code>程序代码里面的<code>stdout</code>，将指向文件<code>out.dat</code>，即向<code>out.dat</code>写入数据。</p><p>​<strong>输出重定向<code>&gt;</code>会先擦去<code>out.dat</code>的所有原有的内容，然后再写入。如果希望写入的信息追加在<code>out.dat</code>的结尾，可以使用<code>&gt;&gt;</code>符号。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ demo &gt;&gt; out.dat</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>demo</code>程序代码里面的<code>stdout</code>，将向文件<code>out.dat</code>写入数据。与<code>&gt;</code>不同的是，写入的开始位置是<code>out.dat</code>的文件结尾。</p><p>​<strong>标准错误的重定向符号是<code>2&gt;</code>。其中的<code>2</code>代表文件指针的编号，即<code>2&gt;</code>表示将2号文件指针的写入，重定向到<code>err.txt</code>。2号文件指针就是标准错误<code>stderr</code>。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ demo &gt; out.dat 2&gt; err.txt</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>demo</code>程序代码里面的<code>stderr</code>，会向文件<code>err.txt</code>写入报错信息。而<code>stdout</code>向文件<code>out.dat</code>写入。</p><p>​<strong>输入重定向和输出重定向，也可以结合在一条命令里面。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ demo &lt; in.dat &gt; out.dat</span><br><span class="line"></span><br><span class="line">// or</span><br><span class="line">$ demo &gt; out.dat &lt; in.dat</span><br></pre></td></tr></table></figure><p>​<strong>重定向还有另一种情况，就是将一个程序的标准输出<code>stdout</code>，指向另一个程序的标准输入<code>stdin</code>，这时要使用<code>|</code>符号。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ random | sum</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>random</code>程序代码里面的<code>stdout</code>的写入，会从<code>sum</code>程序代码里面的<code>stdin</code>被读取。</p><h3 id="fclose"><a href="#fclose" class="headerlink" title="fclose()"></a>fclose()</h3><p>​<code>fclose()</code>用来关闭已经使用<code>fopen()</code>打开的文件。它的原型定义在<code>stdin.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE* stream)</span>;</span><br></pre></td></tr></table></figure><p>​<strong>它接受一个文件指针<code>fp</code>作为参数。如果成功关闭文件，<code>fclose()</code>函数返回整数<code>0</code>；如果操作失败（比如磁盘已满，或者出现 I&#x2F;O 错误），则返回一个特殊值 EOF。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fclose(fp) != <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Something wrong.&quot;</span>);</span><br></pre></td></tr></table></figure><p>​不再使用的文件，都应该使用<code>fclose()</code>关闭，否则无法释放资源。<strong>一般来说，系统对同时打开的文件数量有限制，及时关闭文件可以避免超过这个限制。</strong></p><h3 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h3><p>​C 语言的文件操作函数的设计是，如果遇到文件结尾，就返回一个特殊值。程序接收到这个特殊值，就知道已经到达文件结尾了。</p><p>​<strong>头文件<code>stdio.h</code>为这个特殊值定义了一个宏<code>EOF</code>（end of file 的缩写），它的值一般是<code>-1</code>。</strong>这是因为从文件读取的二进制值，不管作为无符号数字解释，还是作为 ASCII 码解释，都不可能是负值，所以可以很安全地返回<code>-1</code>，不会跟文件本身的数据相冲突。</p><p>​<strong>需要注意的是，不像字符串结尾真的存储了<code>\0</code>这个值，<code>EOF</code>并不存储在文件结尾，文件中并不存在这个值，完全是文件操作函数发现到达了文件结尾，而返回这个值。</strong></p><h3 id="freopen"><a href="#freopen" class="headerlink" title="freopen()"></a>freopen()</h3><p>​<strong><code>freopen()</code>用于新打开一个文件，直接关联到某个已经打开的文件指针。这样可以复用文件指针。</strong>它的原型定义在头文件<code>stdio.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE* <span class="title function_">freopen</span><span class="params">(<span class="type">char</span>* filename, <span class="type">char</span>* mode, FILE stream)</span>;</span><br></pre></td></tr></table></figure><p>​<strong>它跟<code>fopen()</code>相比，就是多出了第三个参数，表示要复用的文件指针</strong>。其他两个参数都一样，分别是文件名和打开模式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">freopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>​<strong>上面示例将文件<code>output.txt</code>关联到<code>stdout</code>，此后向<code>stdout</code>写入的内容，都会写入<code>output.txt</code>。</strong>由于<code>printf()</code>默认就是输出到<code>stdout</code>，所以运行上面的代码以后，文件<code>output.txt</code>会被写入<code>hello</code>。</p><p>​<code>freopen()</code>的返回值是它的第三个参数（文件指针）。如果打开失败（比如文件不存在），会返回空指针 NULL。</p><p>​<strong><code>freopen()</code>会自动关闭原先已经打开的文件，如果文件指针并没有指向已经打开的文件，则<code>freopen()</code>等同于<code>fopen()</code>。</strong></p><p>​下面是<code>freopen()</code>关联<code>scanf()</code>的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, i2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;i); </span><br><span class="line"></span><br><span class="line">freopen(<span class="string">&quot;someints.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;i2);</span><br></pre></td></tr></table></figure><p>​<strong>上面例子中，一共调用了两次<code>scanf()</code>，第一次调用是从键盘读取，然后使用<code>freopen()</code>将<code>stdin</code>指针关联到某个文件，第二次调用就会从该文件读取。</strong></p><p>​某些系统允许使用<code>freopen()</code>，改变文件的打开模式。这时，<code>freopen()</code>的第一个参数应该是 NULL。</p><h3 id="fgetc-，getc"><a href="#fgetc-，getc" class="headerlink" title="fgetc()，getc()"></a>fgetc()，getc()</h3><p>​<strong><code>fgetc()</code>和<code>getc()</code>用于从文件读取一个字符。它们的用法跟<code>getchar()</code>类似，区别是<code>getchar()</code>只用来从<code>stdin</code>读取，而这两个函数是从任意指定的文件读取。</strong>它们的原型定义在头文件<code>stdio.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *stream)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getc</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>​<code>fgetc()</code>与<code>getc()</code>的用法是一样的，都只有文件指针一个参数。<strong>两者的区别是，<code>getc()</code>一般用宏来实现，而<code>fgetc()</code>是函数实现，所以前者的性能可能更好一些。</strong></p><p>​<strong>注意，虽然这两个函数返回的是一个字符，但是它们的返回值类型却不是<code>char</code>，而是<code>int</code>，这是因为读取失败的情况下，它们会返回 EOF，这个值一般是<code>-1</code>。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = getc(fp)) != EOF)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>getc()</code>依次读取文件的每个字符，将其放入变量<code>c</code>，直到读到文件结尾，返回 EOF，循环终止。<strong>变量<code>c</code>的类型是<code>int</code>，而不是<code>char</code>，因为有可能等于负值，所以设为<code>int</code>更好一些。</strong></p><h3 id="fputc-，putc"><a href="#fputc-，putc" class="headerlink" title="fputc()，putc()"></a>fputc()，putc()</h3><p>​<strong><code>fputc()</code>和<code>putc()</code>用于向文件写入一个字符。它们的用法跟<code>putchar()</code>类似，区别是<code>putchar()</code>是向<code>stdout</code>写入，而这两个函数是向文件写入。</strong>它们的原型定义在头文件<code>stdio.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> <span class="type">char</span>, FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">putc</span><span class="params">(<span class="type">int</span> <span class="type">char</span>, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>​<code>fputc()</code>与<code>putc()</code>的用法是一样，都接受两个参数，第一个参数是待写入的字符，第二个参数是文件指针。<strong>两者的区别是，<code>putc()</code>通常是使用宏来实现，而<code>fputc()</code>只作为函数来实现，所以理论上，<code>putc()</code>的性能会好一点。</strong></p><p>​<strong>写入成功时，它们返回写入的字符；写入失败时，返回 EOF。</strong></p><h3 id="fprintf"><a href="#fprintf" class="headerlink" title="fprintf()"></a>fprintf()</h3><p>​<strong><code>fprintf()</code>用于向文件写入格式化字符串，用法与<code>printf()</code>类似。区别是<code>printf()</code>总是写入<code>stdout</code>，而<code>fprintf()</code>则是写入指定的文件，它的第一个参数必须是一个文件指针。</strong>它的原型定义在头文件<code>stdio.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE* stream, <span class="type">const</span> <span class="type">char</span>* format, ...)</span></span><br></pre></td></tr></table></figure><p>​<strong><code>fprintf()</code>可以替代<code>printf()</code>。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Hello, world!\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>​上面例子中，指定<code>fprintf()</code>写入<code>stdout</code>，结果就等同于调用<code>printf()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(fp, <span class="string">&quot;Sum: %d\n&quot;</span>, sum);</span><br></pre></td></tr></table></figure><p>​上面示例是向文件指针<code>fp</code>写入指定格式的字符串。</p><p>​下面是向<code>stderr</code>输出错误信息的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Something number.\n&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="fscanf"><a href="#fscanf" class="headerlink" title="fscanf()"></a>fscanf()</h3><p>​<strong><code>fscanf()</code>用于按照给定的模式，从文件中读取内容，用法跟<code>scanf()</code>类似。区别是<code>scanf()</code>总是从<code>stdin</code>读取数据，而<code>fscanf()</code>是从文件读入数据，第一个参数必须是文件指针。</strong>它的原型定义在头文件<code>stdio.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE* stream, <span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br></pre></td></tr></table></figure><p>​下面是一个例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d%d&quot;</span>, &amp;i, &amp;j);</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>fscanf()</code>从文件<code>fp</code>里面，读取两个整数，放入变量<code>i</code>和<code>j</code>。</p><p>​<strong>使用<code>fscanf()</code>的前提是知道文件的结构，它的占位符解析规则与<code>scanf()</code>完全一致。由于<code>fscanf()</code>可以连续读取，直到读到文件尾，或者发生错误（读取失败、匹配失败），才会停止读取，所以<code>fscanf()</code>通常放在循环里面。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">fscanf</span>(fp, <span class="string">&quot;%s&quot;</span>, words) == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">puts</span>(words);</span><br></pre></td></tr></table></figure><p>​<strong>上面示例中，<code>fscanf()</code>依次读取文件的每个词，将它们一行打印一个，直到文件结束。</strong></p><p>​<strong><code>fscanf()</code>的返回值是赋值成功的变量数量，如果赋值失败会返回 EOF。</strong></p><h3 id="fgets"><a href="#fgets" class="headerlink" title="fgets()"></a>fgets()</h3><p>​<strong><code>fgets()</code>用于从文件读取指定长度的字符串，它名字的第一个字符是<code>f</code>，就代表<code>file</code>。</strong>它的原型定义在头文件<code>stdio.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">fgets</span><span class="params">(<span class="type">char</span>* str, <span class="type">int</span> STRLEN, File* fp)</span>;</span><br></pre></td></tr></table></figure><p>​<strong>它的第一个参数<code>str</code>是一个字符串指针，用于存放读取的内容。第二个参数<code>STRLEN</code>指定读取的长度，第三个参数是一个 FILE 指针，指向要读取的文件。</strong></p><p>​<strong><code>fgets()</code>读取 STRLEN - 1 个字符之后，或者遇到换行符与文件结尾，就会停止读取，然后在已经读取的内容末尾添加一个空字符<code>\0</code>，使之成为一个字符串。注意，<code>fgets()</code>会将换行符（<code>\n</code>）存储进字符串，这一点它和<code>%s</code>的读取规则是不一样的。</strong></p><p>​<strong>如果<code>fgets</code>的第三个参数是<code>stdin</code>，就可以读取标准输入，等同于<code>scanf()</code>。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fgets(str, <span class="keyword">sizeof</span>(str), <span class="built_in">stdin</span>);</span><br></pre></td></tr></table></figure><p>​<strong>读取成功时，<code>fgets()</code>的返回值是它的第一个参数，即指向字符串的指针，否则返回空指针 NULL。</strong></p><p>​<code>fgets()</code>可以用来读取文件的每一行，下面是读取文件所有行的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">1024</span>]; <span class="comment">// 数组必须足够大，足以放下一行</span></span><br><span class="line">    <span class="type">int</span> linecount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    fp = fopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fgets(s, <span class="keyword">sizeof</span> s, fp) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %s&quot;</span>, ++linecount, s);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面示例中，每读取一行，都会输出行号和该行的内容。</p><p>​下面的例子是循环读取用户的输入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> words[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Enter strings (q to quit):&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fgets(words, <span class="number">10</span>, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (words[<span class="number">0</span>] == <span class="string">&#x27;q&#x27;</span> &amp;&amp; words[<span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(words);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Done.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面的示例中，如果用户输入的字符串大于9个字符，<code>fgets()</code>会多次读取。直到遇到<code>q</code> + 回车键，才会退出循环。</p><h3 id="fputs"><a href="#fputs" class="headerlink" title="fputs()"></a>fputs()</h3><p>​<strong><code>fputs()</code>函数用于向文件写入字符串，和<code>puts()</code>函数只有一点不同，那就是它不会在字符串末尾添加换行符。这是因为<code>fgets()</code>保留了换行符，所以<code>fputs()</code>就不添加了。<code>fputs()</code>函数通常与<code>fgets()</code>配对使用。</strong>它的原型定义在<code>stdio.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, FILE* stream)</span>;</span><br></pre></td></tr></table></figure><p>​它接受两个参数，第一个参数是字符串指针，第二个参数是要写入的文件指针。如果第二个参数为<code>stdout</code>（标准输出），就是将内容输出到计算机屏幕，等同于<code>printf()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> words[<span class="number">14</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Enter a string, please.&quot;</span>);</span><br><span class="line">fgets(words, <span class="number">14</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;This is your string:&quot;</span>);</span><br><span class="line"><span class="built_in">fputs</span>(words, <span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure><p>​上面示例中，先用<code>fgets()</code>从<code>stdin</code>读取用户输入，然后用<code>fputs()</code>输出到<code>stdout</code>。</p><p>​写入成功时，<code>fputs()</code>返回一个非负整数，否则返回 EOF。</p><h3 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite()"></a>fwrite()</h3><p>​<strong><code>fwrite()</code>用来一次性写入较大的数据块，主要用途是将数组数据一次性写入文件，适合写入二进制数据。</strong>它的原型定义在<code>stdio.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE* fp)</span>;</span><br></pre></td></tr></table></figure><p>它接受四个参数：</p><ul><li><code>ptr</code>：数组指针。</li><li><code>size</code>：每个数组成员的大小，单位字节。</li><li><code>nmemb</code>：数组成员的数量。</li><li><code>fp</code>：要写入的文件指针。</li></ul><p>​<strong>注意，<code>fwrite()</code>原型的第一个参数类型是<code>void*</code>，这是一个无类型指针，编译器会自动将参数指针转成<code>void*</code>类型。正是由于<code>fwrite()</code>不知道数组成员的类型，所以才需要知道每个成员的大小（第二个参数）和成员数量（第三个参数）。</strong></p><p>​<strong><code>fwrite()</code>函数的返回值是成功写入的数组成员的数量（注意不是字节数）。正常情况下，该返回值就是第三个参数<code>nmemb</code>，但如果出现写入错误，只写入了一部分成员，返回值会比<code>nmemb</code>小。</strong></p><p>​<strong>要将整个数组<code>arr</code>写入文件，可以采用下面的写法。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fwrite(arr, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), fp);</span><br></pre></td></tr></table></figure><p>​下面的例子是将一个大小为256字节的字符串写入文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">fwrite(buffer, <span class="number">1</span>, <span class="number">256</span>, fp);</span><br></pre></td></tr></table></figure><p>​上面示例中，数组<code>buffer</code>每个成员是1个字节，一共有256个成员。<strong>由于<code>fwrite()</code>是连续内存复制，所以写成<code>fwrite(buffer, 256, 1, fp)</code>也能达到目的。</strong></p><p>​<code>fwrite()</code>没有规定一定要写入整个数组，只写入数组的一部分也是可以的。</p><p>​<strong>任何类型的数据都可以看成是1字节数据组成的数组，或者是一个成员的数组，所以<code>fwrite()</code>实际上可以写入任何类型的数据，而不仅仅是数组。</strong>比如，<code>fwrite()</code>可以将一个 Struct 结构写入文件保存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fwrite(&amp;s, <span class="keyword">sizeof</span>(s), <span class="number">1</span>, fp);</span><br></pre></td></tr></table></figure><p>​<strong>上面示例中，<code>s</code>是一个 Struct 结构指针，可以看成是一个成员的数组。</strong></p><p>​<strong>注意，如果<code>s</code>的属性包含指针，存储时需要小心，因为保存指针可能没意义，还原出来的时候，并不能保证指针指向的数据还存在。</strong></p><p>​<strong><code>fwrite()</code>以及后面要介绍的<code>fread()</code>，比较适合读写二进制数据，因为它们不会对写入的数据进行解读。二进制数据可能包含空字符<code>\0</code>，这是 C 语言的字符串结尾标记，所以读写二进制文件，不适合使用文本读写函数（比如<code>fprintf()</code>等）。</strong></p><p>​下面是一个写入二进制文件的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> bytes[] = &#123;<span class="number">5</span>, <span class="number">37</span>, <span class="number">0</span>, <span class="number">88</span>, <span class="number">255</span>, <span class="number">12</span>&#125;;</span><br><span class="line"></span><br><span class="line">    fp = fopen(<span class="string">&quot;output.bin&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    fwrite(bytes, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="keyword">sizeof</span>(bytes), fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>上面示例中，写入二进制文件时，<code>fopen()</code>要使用<code>wb</code>模式打开，表示二进制写入。<code>fwrite()</code>可以把数据解释成单字节数组，因此它的第二个参数是<code>sizeof(char)</code>，第三个参数是数组的总字节数<code>sizeof(bytes)</code>。</strong></p><p>​上面例子写入的文件<code>output.bin</code>，使用十六进制编辑器打开，会是下面的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">05</span> <span class="number">25</span> <span class="number">00</span> <span class="number">58</span> ff <span class="number">0</span>c</span><br></pre></td></tr></table></figure><p>​<code>fwrite()</code>还可以连续向一个文件写入数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clientData</span> <span class="title">myClient</span> =</span> &#123;<span class="number">1</span>, <span class="string">&#x27;foo bar&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    fwrite(&amp;myClient, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> clientData), <span class="number">1</span>, cfPtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>fwrite()</code>连续将100条数据写入文件。</p><h3 id="fread"><a href="#fread" class="headerlink" title="fread()"></a>fread()</h3><p>​<strong><code>fread()</code>函数用于一次性从文件读取较大的数据块，主要用途是将文件内容读入一个数组，适合读取二进制数据。</strong>它的原型定义在头文件<code>stdio.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE* fp)</span>;</span><br></pre></td></tr></table></figure><p>它接受四个参数，与<code>fwrite()</code>完全相同：</p><ul><li><p><code>ptr</code>：数组地址。</p></li><li><p><code>size</code>：每个数组成员的大小，单位为字节。</p></li><li><p><code>nmemb</code>：数组的成员数量。</p></li><li><p><code>fp</code>：文件指针。</p><p><strong>要将文件内容读入数组<code>arr</code>，可以采用下面的写法。</strong></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fread(arr, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]) , <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), fp);</span><br></pre></td></tr></table></figure><p>​上面示例中，数组长度（第二个参数）和每个成员的大小（第三个参数）的乘积，就是数组占用的内存空间的大小。<code>fread()</code>会从文件（第四个参数）里面读取相同大小的内容，然后将<code>ptr</code>（第一个参数）指向这些内容的内存地址。</p><p>​下面的例子是将文件内容读入一个10个成员的双精度浮点数数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> earnings[<span class="number">10</span>];</span><br><span class="line">fread(earnings, <span class="keyword">sizeof</span>(<span class="type">double</span>), <span class="number">10</span>, fp);</span><br></pre></td></tr></table></figure><p>​上面示例中，每个数组成员的大小是<code>sizeof(double)</code>，一个有10个成员，就会从文件<code>fp</code>读取<code>sizeof(double) * 10</code>大小的内容。</p><p>​<strong><code>fread()</code>函数的返回值是成功读取的数组成员的数量。正常情况下，该返回值就是第三个参数<code>nmemb</code>，但如果出现读取错误或读到文件结尾，该返回值就会比<code>nmemb</code>小。所以，检查<code>fread()</code>的返回值是非常重要的。</strong></p><p>​<strong><code>fread()</code>和<code>fwrite()</code>可以配合使用。在程序终止之前，使用<code>fwrite()</code>将数据保存进文件，下次运行时再用<code>fread()</code>将数据还原进入内存。</strong></p><p>​下面是读取上一节生成的二进制文件<code>output.bin</code>的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    fp = fopen(<span class="string">&quot;output.bin&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (fread(&amp;c, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="number">1</span>, fp) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​运行后，得到如下结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">37</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">88</span></span><br><span class="line"><span class="number">255</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="feof"><a href="#feof" class="headerlink" title="feof()"></a>feof()</h3><p>​<strong><code>feof()</code>函数判断文件的内部指针是否指向文件结尾。</strong>它的原型定义在头文件<code>stdio.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *fp)</span>;</span><br></pre></td></tr></table></figure><p>​<strong><code>feof()</code>接受一个文件指针作为参数。如果已经到达文件结尾，会返回一个非零值（表示 true），否则返回<code>0</code>（表示 false）。</strong></p><p>​<strong>诸如<code>fgetc()</code>这样的文件读取函数，如果返回 EOF，有两种可能，一种可能是已读取到文件结尾，另一种可能是出现读取错误。<code>feof()</code>可以用来判断到底是那一种情况。</strong></p><p>​下面是通过<code>feof()</code>判断是否到达文件结尾，从而循环读取整个文件的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">FILE *cfPtr = fopen(<span class="string">&quot;clients.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!feof(cfPtr))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fscanf</span>(cfPtr, <span class="string">&quot;%d%s\n&quot;</span>, &amp;num, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>, num, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fclose(cfPtr);</span><br></pre></td></tr></table></figure><p>​上面示例通过循环判断<code>feof()</code>是否读到文件结尾，从而实现读出整个文件内容。</p><p>​<code>feof()</code>为真时，可以通过<code>fseek()</code>、<code>rewind()</code>、<code>fsetpos()</code>函数改变文件内部读写位置的指示器，从而清除这个函数的状态。</p><h3 id="fseek"><a href="#fseek" class="headerlink" title="fseek()"></a>fseek()</h3><p>​<strong>每个文件指针都有一个内部指示器（内部指针），记录当前打开的文件的读写位置（file position），即下一次读写从哪里开始。</strong>文件操作函数（比如<code>getc()</code>、<code>fgets()</code>、<code>fscanf()</code>和<code>fread()</code>等）都从这个指示器指定的位置开始按顺序读写文件。</p><p>​<strong>如果希望改变这个指示器，将它移到文件的指定位置，可以使用<code>fseek()</code>函数。</strong>它的原型定义在头文件<code>stdio.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE* stream, <span class="type">long</span> <span class="type">int</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><p><code>fseek()</code>接受3个参数：</p><ul><li><code>stream</code>：文件指针。</li><li><code>offset</code>：距离基准（第三个参数）的字节数。类型为 long int，可以为正值（向文件末尾移动）、负值（向文件开始处移动）或 0（保持不动）。</li><li><code>whence</code>：位置基准，用来确定计算起点。它的值是以下三个宏（定义在<code>stdio.h</code>）：<code>SEEK_SET</code>（文件开始处）、<code>SEEK_CUR</code>（内部指针的当前位置）、<code>SEEK_END</code>（文件末尾）</li></ul><p>请看下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定位到文件开始处</span></span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定位到文件末尾</span></span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从当前位置后移2个字节</span></span><br><span class="line">fseek(fp, <span class="number">2L</span>, SEEK_CUR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定位到文件第10个字节</span></span><br><span class="line">fseek(fp, <span class="number">10L</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定位到文件倒数第10个字节</span></span><br><span class="line">fseek(fp, <span class="number">-10L</span>, SEEK_END);</span><br></pre></td></tr></table></figure><p>​<strong>上面示例中，<code>fseek()</code>的第二个参数为 long 类型，所以移动距离必须加上后缀<code>L</code>，将其转为 long 类型。</strong></p><p>​下面的示例逆向输出文件的所有字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (count = <span class="number">1L</span>; count &lt;= size; count++)</span><br><span class="line">&#123;</span><br><span class="line">    fseek(fp, -count, SEEK_END);</span><br><span class="line">    ch = getc(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>注意，<code>fseek()</code>最好只用来操作二进制文件，不要用来读取文本文件。因为文本文件的字符有不同的编码，某个位置的准确字节位置不容易确定。</strong></p><p>​<strong>正常情况下，<code>fseek()</code>的返回值为0。如果发生错误（如移动的距离超出文件的范围），返回值为非零值（比如<code>-1</code>)。</strong></p><h3 id="ftell"><a href="#ftell" class="headerlink" title="ftell()"></a>ftell()</h3><p>​<strong><code>ftell()</code>函数返回文件内部指示器的当前位置。</strong>它的原型定义在头文件<code>stdio.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">ftell</span><span class="params">(FILE* stream)</span>;</span><br></pre></td></tr></table></figure><p>​<strong>它接受一个文件指针作为参数。返回值是一个 long 类型的整数，表示内部指示器的当前位置，即文件开始处到当前位置的字节数，<code>0</code>表示文件开始处。如果发生错误，<code>ftell()</code>返回<code>-1L</code>。</strong></p><p>​<strong><code>ftell()</code>可以跟<code>fseek()</code>配合使用，先记录内部指针的位置，一系列操作过后，再用<code>fseek()</code>返回原来的位置。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> file_pos = ftell(fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一系列文件操作之后</span></span><br><span class="line">fseek(fp, file_pos, SEEK_SET);</span><br></pre></td></tr></table></figure><p>​<strong>下面的例子先将指示器定位到文件结尾，然后得到文件开始处到结尾的字节数。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_END);</span><br><span class="line">size = ftell(fp);</span><br></pre></td></tr></table></figure><h3 id="rewind"><a href="#rewind" class="headerlink" title="rewind()"></a>rewind()</h3><p>​<strong><code>rewind()</code>函数可以让文件的内部指示器回到文件开始处。</strong>它的原型定义在<code>stdio.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rewind</span><span class="params">(file* stream)</span>;</span><br></pre></td></tr></table></figure><p>​它接受一个文件指针作为参数。</p><p>​<strong><code>rewind(fp)</code>基本等价于<code>fseek(fp, 0l, seek_set)</code>，唯一的区别是<code>rewind()</code>没有返回值，而且会清除当前文件的错误指示器。</strong></p><h3 id="fgetpos-，fsetpos"><a href="#fgetpos-，fsetpos" class="headerlink" title="fgetpos()，fsetpos()"></a>fgetpos()，fsetpos()</h3><p>​<code>fseek()</code>和<code>ftell()</code>有一个潜在的问题，那就是它们都把文件大小限制在 long int 类型能表示的范围内。这看起来相当大，但是在32位计算机上，long int 的长度为4个字节，能够表示的范围最大为 4GB。</p><p>​<strong>随着存储设备的容量迅猛增长，文件也越来越大，往往会超出这个范围。鉴于此，C 语言新增了两个处理大文件的新定位函数：<code>fgetpos()</code>和<code>fsetpos()</code>。</strong>它们的原型都定义在头文件<code>stdio.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetpos</span><span class="params">(FILE* stream, <span class="type">fpos_t</span>* pos)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fsetpos</span><span class="params">(FILE* stream, <span class="type">const</span> <span class="type">fpos_t</span>* pos)</span>;</span><br></pre></td></tr></table></figure><p>​<strong><code>fgetpos()</code>函数会将文件内部指示器的当前位置，存储在指针变量<code>pos</code>。该函数接受两个参数，第一个是文件指针，第二个存储指示器位置的变量。</strong></p><p>​<strong><code>fsetpos()</code>函数会将文件内部指示器的位置，移动到指针变量<code>pos</code>指定的地址。注意，变量<code>pos</code>必须是通过调用<code>fgetpos()</code>方法获得的。<code>fsetpos()</code>的两个参数与<code>fgetpos()</code>必须是一样的。</strong></p><p>​<strong>记录文件内部指示器位置的指针变量<code>pos</code>，类型为<code>fpos_t*</code>（file position type 的缩写，意为文件定位类型）。它不一定是整数，也可能是一个 Struct 结构。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">fpos_t</span> file_pos;</span><br><span class="line">fgetpos(fp, &amp;file_pos);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一系列文件操作之后</span></span><br><span class="line">fsetpos(fp, &amp;file_pos);</span><br></pre></td></tr></table></figure><p>​上面示例中，先用<code>fgetpos()</code>获取内部指针的位置，后面再用<code>fsetpos()</code>恢复指针的位置。</p><p>​<strong>执行成功时，<code>fgetpos()</code>和<code>fsetpos()</code>都会返回<code>0</code>，否则返回非零值。</strong></p><h3 id="ferror-，clearerr"><a href="#ferror-，clearerr" class="headerlink" title="ferror()，clearerr()"></a>ferror()，clearerr()</h3><p>​<strong>所有的文件操作函数如果执行失败，都会在文件指针里面记录错误状态。后面的操作只要读取错误指示器，就知道前面的操作出错了。</strong></p><p>​<strong><code>ferror()</code>函数用来返回错误指示器的状态。可以通过这个函数，判断前面的文件操作是否成功</strong>。它的原型定义在头文件<code>stdio.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ferror</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>​<strong>它接受一个文件指针作为参数。如果前面的操作出现错误，<code>ferror()</code>就会返回一个非零整数（表示 true），否则返回<code>0</code>。</strong></p><p>​<strong><code>clearerr()</code>函数用来重置出错指示器。</strong>它的原型定义在头文件<code>stdio.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clearerr</span><span class="params">(FILE* fp)</span>;</span><br></pre></td></tr></table></figure><p>​<strong>它接受一个文件指针作为参数，没有返回值。</strong></p><p>​下面是一个例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="type">char</span> c = fgetc(fp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ferror(fp))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;读取文件：file.txt 时发生错误\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clearerr(fp);</span><br></pre></td></tr></table></figure><p>​上面示例中，<code>fgetc()</code>尝试读取一个以”写模式“打开的文件，读取失败就会返回 EOF。这时调用<code>ferror()</code>就可以知道上一步操作出错了。处理完以后，再用<code>clearerr()</code>清除出错状态。</p><p>​<strong>文件操作函数如果正常执行，<code>ferror()</code>和<code>feof()</code>都会返回零。如果执行不正常，就要判断到底是哪里出了问题。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d&quot;</span>, &amp;n) != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ferror(fp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;io error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (feof(fp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;end of file\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clearerr(fp);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>上面示例中，当<code>fscanf()</code>函数报错时，通过检查<code>ferror()</code>和<code>feof()</code>，确定到底发生什么问题。</strong></p><p>​<strong>这两个指示器改变状态后，会保持不变，所以要用<code>clearerr()</code>清除它们，<code>clearerr()</code>可以同时清除两个指示器。</strong></p><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><p>​<strong><code>remove()</code>函数用于删除指定文件</strong>。它的原型定义在头文件<code>stdio.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span>;</span><br></pre></td></tr></table></figure><p>​<strong>它接受文件名作为参数。如果删除成功，<code>remove()</code>返回<code>0</code>，否则返回非零值。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remove(<span class="string">&quot;foo.txt&quot;</span>);</span><br></pre></td></tr></table></figure><p>​上面示例删除了<code>foo.txt</code>文件。</p><p>​<strong>注意，删除文件必须是在文件关闭的状态下。如果是用<code>fopen()</code>打开的文件，必须先用<code>fclose()</code>关闭后再删除。</strong></p><h3 id="rename"><a href="#rename" class="headerlink" title="rename()"></a>rename()</h3><p>​<strong><code>rename()</code>函数用于文件改名，也用于移动文件。</strong>它的原型定义在头文件<code>stdio.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* old_filename, <span class="type">const</span> <span class="type">char</span>* new_filename)</span>;</span><br></pre></td></tr></table></figure><p>​<strong>它接受两个参数，第一个参数是现在的文件名，第二个参数是新的文件名。如果改名成功，<code>rename()</code>返回<code>0</code>，否则返回非零值。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename(<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;bar.txt&quot;</span>);</span><br></pre></td></tr></table></figure><p>​上面示例将<code>foo.txt</code>改名为<code>bar.txt</code>。</p><p>​<strong>注意，改名后的文件不能与现有文件同名。另外，如果要改名的文件已经打开了，必须先关闭，然后再改名，对打开的文件进行改名会失败。</strong></p><p>​<strong>下面是移动文件的例子。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename(<span class="string">&quot;/tmp/evidence.txt&quot;</span>, <span class="string">&quot;/home/beej/nothing.txt&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="变量说明符"><a href="#变量说明符" class="headerlink" title="变量说明符"></a>变量说明符</h2><p>​<strong>C 语言允许声明变量的时候，加上一些特定的说明符（specifier），为编译器提供变量行为的额外信息。它的主要作用是帮助编译器优化代码，有时会对程序行为产生影响。</strong></p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>​<strong><code>const</code>说明符表示变量是只读的，不得被修改。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14159</span>;</span><br><span class="line">PI = <span class="number">3</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>​上面示例里面的<code>const</code>，表示变量<code>PI</code>的值不应改变。如果改变的话，编译器会报错。</p><p>​<strong>对于数组，<code>const</code>表示数组成员不能修改。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">5</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>const</code>使得数组<code>arr</code>的成员无法修改。</p><p>​<strong>对于指针变量，<code>const</code>有两种写法，含义是不一样的。</strong></p><p>​<strong>如果<code>const</code>在<code>*</code>前面，表示指针指向的值不可修改。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const 表示指向的值 *x 不能修改</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> * x</span><br></pre></td></tr></table></figure><p>​下面示例中，对<code>x</code>指向的值进行修改导致报错。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p = <span class="number">1</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* x = &amp;p;</span><br><span class="line"></span><br><span class="line">(*x)++; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>​<strong>如果<code>const</code>在<code>*</code>后面，表示指针包含的地址不可修改。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const 表示地址 x 不能修改</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> x</span><br></pre></td></tr></table></figure><p>​下面示例中，对<code>x</code>进行修改导致报错。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p = <span class="number">1</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> x = &amp;p;</span><br><span class="line"></span><br><span class="line">x++; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>​<strong>这两者可以结合起来。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> x;</span><br></pre></td></tr></table></figure><p>​上面示例中，指针变量<code>x</code>指向一个字符串。两个<code>const</code>意味着，<code>x</code>包含的内存地址以及<code>x</code>指向的字符串，都不能修改。</p><p>​<strong><code>const</code>的一个用途，就是防止函数体内修改函数参数。如果某个参数在函数体内不会被修改，可以在函数声明时，对该参数添加<code>const</code>说明符。这样的话，使用这个函数的人看到原型里面的<code>const</code>，就知道调用函数前后，参数数组保持不变。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* arr, <span class="type">int</span> n)</span>;</span><br></pre></td></tr></table></figure><p>​上面示例中，函数<code>find</code>的参数数组<code>arr</code>有<code>const</code>说明符，就说明该数组在函数内部将保持不变。</p><p>​<strong>有一种情况需要注意，如果一个指针变量指向<code>const</code>变量，那么该指针变量也不应该被修改。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>* j = &amp;i;</span><br><span class="line">*j = <span class="number">2</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>j</code>是一个指针变量，指向变量<code>i</code>，即<code>j</code>和<code>i</code>指向同一个地址。<code>j</code>本身没有<code>const</code>说明符，但是<code>i</code>有。这种情况下，<code>j</code>指向的值也不能被修改。</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>​<code>static</code>说明符对于全局变量和局部变量有不同的含义。</p><ol><li><p>用于局部变量（位于块作用域内部）。</p><p>​<strong><code>static</code>用于函数内部声明的局部变量时，表示该变量的值会在函数每次执行后得到保留，下次执行时不会进行初始化，就类似于一个只用于函数内部的全局变量。由于不必每次执行函数时，都对该变量进行初始化，这样可以提高函数的执行速度。</strong></p></li><li><p>用于全局变量（位于块作用域外部）。</p><p>​<strong><code>static</code>用于函数外部声明的全局变量时，表示该变量只用于当前文件，其他源码文件不可以引用该变量，即该变量不会被链接（link）。</strong></p></li></ol><p>​<strong><code>static</code>修饰的变量，初始化时，值不能等于变量，必须是常量。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="type">static</span> m = n; <span class="comment">// 报错</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，变量<code>m</code>有<code>static</code>修饰，它的值如果等于变量<code>n</code>，就会报错，必须等于常量。</p><p>​<strong>只在当前文件里面使用的函数，也可以声明为<code>static</code>，表明该函数只在当前文件使用，其他文件可以定义同名函数。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>​<strong><code>auto</code>说明符表示该变量的存储，由编译器自主分配内存空间，且只存在于定义时所在的作用域，退出作用域时会自动释放。</strong></p><p>​<strong>由于只要不是<code>extern</code>的变量（外部变量），都是由编译器自主分配内存空间的，这属于默认行为，所以该说明符没有实际作用，一般都省略不写。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="type">int</span> a;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><p>​<strong><code>extern</code>说明符表示，该变量在其他文件里面声明，没有必要在当前文件里面为它分配空间。通常用来表示，该变量是多个文件共享的。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面代码中，<code>a</code>是<code>extern</code>变量，表示该变量在其他文件里面定义和初始化，当前文件不必为它分配存储空间。</p><p>​<strong>但是，变量声明时，同时进行初始化，<code>extern</code>就会无效。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extern 无效</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>上面代码中，<code>extern</code>对变量初始化的声明是无效的。这是为了防止多个<code>extern</code>对同一个变量进行多次初始化。</strong></p><p>​<strong>函数内部使用<code>extern</code>声明变量，就相当于该变量是静态存储，每次执行时都要从外部获取它的值。</strong></p><p>​<strong>函数本身默认是<code>extern</code>，即该函数可以被外部文件共享，通常省略<code>extern</code>不写。如果只希望函数在当前文件可用，那就需要在函数前面加上<code>static</code>。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="register"><a href="#register" class="headerlink" title="register"></a>register</h3><p>​<strong><code>register</code>说明符向编译器表示，该变量是经常使用的，应该提供最快的读取速度，所以应该放进寄存器。但是，编译器可以忽略这个说明符，不一定按照这个指示行事。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="type">int</span> a;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>register</code>提示编译器，变量<code>a</code>会经常用到，要为它提供最快的读取速度。</p><p>​<strong><code>register</code>只对声明在代码块内部的变量有效。</strong></p><p>​<strong>设为<code>register</code>的变量，不能获取它的地址。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> *p = &amp;a; <span class="comment">// 编译器报错</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>&amp;a</code>会报错，因为变量<code>a</code>可能放在寄存器里面，无法获取内存地址。</p><p>​<strong>如果数组设为<code>register</code>，也不能获取整个数组或任一个数组成员的地址。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="type">int</span> a[] = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p = a;  <span class="comment">// 报错</span></span><br><span class="line"><span class="type">int</span> a = *(a + <span class="number">2</span>); <span class="comment">// 报错</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>历史上，CPU 内部的缓存，称为寄存器（register）。</strong>与内存相比，寄存器的访问速度快得多，所以使用它们可以提高速度。但是它们不在内存之中，所以没有内存地址，这就是为什么不能获取指向它们的指针地址。</p><p>​现代编译器已经有巨大的进步，会尽可能优化代码，按照自己的规则决定怎么利用好寄存器，取得最佳的执行速度，所以可能会忽视代码里面的<code>register</code>说明符，不保证一定会把这些变量放到寄存器。</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>​<strong><code>volatile</code>说明符表示所声明的变量，可能会预想不到地发生变化（即其他程序可能会更改它的值），不受当前程序控制，因此编译器不要对这类变量进行优化，每次使用时都应该查询一下它的值。硬件设备的编程中，这个说明符很常用。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> foo;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span>* bar;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<code>volatile</code>的目的是阻止编译器对变量行为进行优化，请看下面的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> foo = x;</span><br><span class="line"><span class="comment">// 其他语句，假设没有改变 x 的值</span></span><br><span class="line"><span class="type">int</span> bar = x;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>上面代码中，由于变量<code>foo</code>和<code>bar</code>都等于<code>x</code>，而且<code>x</code>的值也没有发生变化，所以编译器可能会把<code>x</code>放入缓存，直接从缓存读取值（而不是从 x 的原始内存位置读取），然后对<code>foo</code>和<code>bar</code>进行赋值。</strong></p><p>​<strong>如果<code>x</code>被设定为<code>volatile</code>，编译器就不会把它放入缓存，每次都从原始位置去取<code>x</code>的值，因为在两次读取之间，其他程序可能会改变<code>x</code>。</strong></p><h3 id="restrict"><a href="#restrict" class="headerlink" title="restrict"></a>restrict</h3><p>​<strong><code>restrict</code>说明符允许编译器优化某些代码。它只能用于指针，表明该指针是访问数据的唯一方式。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="keyword">restrict</span> pt = (<span class="type">int</span>*) <span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>上面示例中，<code>restrict</code>表示变量<code>pt</code>是访问 malloc 所分配内存的唯一方式。</strong></p><p>​下面例子的变量<code>foo</code>，就不能使用<code>restrict</code>修饰符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> foo[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span>* bar = foo;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，变量<code>foo</code>指向的内存，可以用<code>foo</code>访问，也可以用<code>bar</code>访问，因此就不能将<code>foo</code>设为 restrict。</p><p>​<strong>如果编译器知道某块内存只能用一个方式访问，可能可以更好地优化代码，因为不用担心其他地方会修改值。</strong></p><p>​<strong><code>restrict</code>用于函数参数时，表示参数的内存地址之间没有重叠。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *<span class="keyword">restrict</span> a, <span class="type">int</span> *<span class="keyword">restrict</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    t = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，函数参数声明里的<code>restrict</code>表示，参数<code>a</code>和参数<code>b</code>的内存地址没有重叠。</p><h2 id="多文件项目"><a href="#多文件项目" class="headerlink" title="多文件项目"></a>多文件项目</h2><p>​<strong>一个软件项目往往包含多个源码文件，编译时需要将这些文件一起编译，生成一个可执行文件。</strong></p><p>​<strong>假定一个项目有两个源码文件<code>foo.c</code>和<code>bar.c</code>，其中<code>foo.c</code>是主文件，<code>bar.c</code>是库文件。所谓“主文件”，就是包含了<code>main()</code>函数的项目入口文件，里面会引用库文件定义的各种函数。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File foo.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, add(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 5!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面代码中，主文件<code>foo.c</code>调用了函数<code>add()</code>，这个函数是在库文件<code>bar.c</code>里面定义的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File bar.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​现在，将这两个文件一起编译。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o foo foo.c bar.c</span><br><span class="line"></span><br><span class="line"># 更省事的写法</span><br><span class="line">$ gcc -o foo *.c</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面命令中，gcc 的<code>-o</code>参数指定生成的二进制可执行文件的文件名，本例是<code>foo</code>。</p><p>​这个命令运行后，编译器会发出警告，原因是在编译<code>foo.c</code>的过程中，编译器发现一个不认识的函数<code>add()</code>，<code>foo.c</code>里面没有这个函数的原型或者定义。因此，最好修改一下<code>foo.c</code>，在文件头部加入<code>add()</code>的原型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File foo.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, add(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// 5!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​如果有多个文件都使用这个函数<code>add()</code>，那么每个文件都需要加入函数原型。一旦需要修改函数<code>add()</code>（比如改变参数的数量），就会非常麻烦，需要每个文件逐一改动。所以，<strong>通常的做法是新建一个专门的头文件<code>bar.h</code>，放置所有在<code>bar.c</code>里面定义的函数的原型。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File bar.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​使用<code>include</code>命令，在用到这个函数的源码文件里面加载这个头文件<code>bar.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File foo.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, add(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// 5!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面代码中，<code>#include &quot;bar.h&quot;</code>表示加入头文件<code>bar.h</code>。<strong>这个文件没有放在尖括号里面，表示它是用户提供的；它没有写路径，就表示与当前源码文件在同一个目录。</strong></p><p>​<strong>最好在<code>bar.c</code>里面也加载这个头文件，这样可以让编译器验证，函数原型与函数定义是否一致。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File bar.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​现在重新编译，就可以顺利得到二进制可执行文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o foo foo.c bar.c</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="重复加载"><a href="#重复加载" class="headerlink" title="重复加载"></a>重复加载</h3><p>​头文件里面还可以加载其他头文件，因此有可能产生重复加载。比如，<code>a.h</code>和<code>b.h</code>都加载了<code>c.h</code>，然后<code>foo.c</code>同时加载了<code>a.h</code>和<code>b.h</code>，这意味着<code>foo.c</code>会编译两次<code>c.h</code>。</p><p>​<strong>最好避免这种重复加载，虽然多次定义同一个函数原型并不会报错，但是有些语句重复使用会报错，比如多次重复定义同一个 Struct 数据结构。</strong></p><p>​<strong>解决重复加载的常见方法是，在头文件里面设置一个专门的宏，加载时一旦发现这个宏存在，就不再继续加载当前文件了。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File bar.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BAR_H</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> BAR_H</span></span><br><span class="line">      <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，头文件<code>bar.h</code>使用<code>#ifndef</code>和<code>#endif</code>设置了一个条件判断。每当加载这个头文件时，就会执行这个判断，查看有没有设置过宏<code>BAR_H</code>。如果设置过了，表明这个头文件已经加载过了，就不再重复加载了，反之就先设置一下这个宏，然后加载函数原型。</p><h3 id="extern-说明符-1"><a href="#extern-说明符-1" class="headerlink" title="extern 说明符"></a>extern 说明符</h3><p>​<strong>当前文件还可以使用其他文件定义的变量，这时要使用<code>extern</code>说明符，在当前文件中声明，这个变量是其他文件定义的。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> myVar;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>extern</code>说明符告诉编译器，变量<code>myvar</code>是其他脚本文件声明的，不需要在这里为它分配内存空间。</p><p>​<strong>由于不需要分配内存空间，所以<code>extern</code>声明数组时，不需要给出数组长度。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a[];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>这种共享变量的声明，可以直接写在源码文件里面，也可以放在头文件中，通过<code>#include</code>指令加载。</strong></p><h3 id="static-说明符-1"><a href="#static-说明符-1" class="headerlink" title="static 说明符"></a>static 说明符</h3><p>​<strong>正常情况下，当前文件内部的全局变量，可以被其他文件使用。</strong>有时候，不希望发生这种情况，而是希望某个变量只局限在当前文件内部使用，不要被其他文件引用。</p><p>​这时可以在声明变量的时候，使用<code>static</code>关键字，使得该变量变成当前文件的私有变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> foo = <span class="number">3</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，变量<code>foo</code>只能在当前文件里面使用，其他文件不能引用。</p><h3 id="编译策略"><a href="#编译策略" class="headerlink" title="编译策略"></a>编译策略</h3><p>​多个源码文件的项目，编译时需要所有文件一起编译。哪怕只是修改了一行，也需要从头编译，非常耗费时间。</p><p>​为了节省时间，<strong>通常的做法是将编译拆分成两个步骤。第一步，使用 GCC 的<code>-c</code>参数，将每个源码文件单独编译为对象文件（object file）。第二步，将所有对象文件链接在一起，合并生成一个二进制可执行文件。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c foo.c # 生成 foo.o</span><br><span class="line">$ gcc -c bar.c # 生成 bar.o</span><br><span class="line"></span><br><span class="line"># 更省事的写法</span><br><span class="line">$ gcc -c *.c</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面命令为源码文件<code>foo.c</code>和<code>bar.c</code>，分别生成对象文件<code>foo.o</code>和<code>bar.o</code>。</p><p>​<strong>对象文件不是可执行文件，只是编译过程中的一个阶段性产物，文件名与源码文件相同，但是后缀名变成了<code>.o</code>。</strong></p><p>​<strong>得到所有的对象文件以后，再次使用<code>gcc</code>命令，将它们通过链接，合并生成一个可执行文件。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o foo foo.o bar.o</span><br><span class="line"></span><br><span class="line"># 更省事的写法</span><br><span class="line">$ gcc -o foo *.o</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>以后，修改了哪一个源文件，就将这个文件重新编译成对象文件，其他文件不用重新编译，可以继续使用原来的对象文件，最后再将所有对象文件重新链接一次就可以了。由于链接的耗时大大短于编译，这样做就节省了大量时间。</strong></p><h3 id="make-命令"><a href="#make-命令" class="headerlink" title="make 命令"></a>make 命令</h3><p>​大型项目的编译，如果全部手动完成，是非常麻烦的，容易出错。一般会使用专门的自动化编译工具，比如 make。</p><p>​<strong>make 是一个命令行工具，使用时会自动在当前目录下搜索配置文件 makefile（也可以写成 Makefile）。该文件定义了所有的编译规则，每个编译规则对应一个编译产物。为了得到这个编译产物，它需要知道两件事。</strong></p><ul><li><strong>依赖项（生成该编译产物，需要用到哪些文件）</strong></li><li><strong>生成命令（生成该编译产物的命令）</strong></li></ul><p>​比如，对象文件<code>foo.o</code>是一个编译产物，它的依赖项是<code>foo.c</code>，生成命令是<code>gcc -c foo.c</code>。对应的编译规则如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo.o: foo.c</span><br><span class="line">gcc -c foo.c</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，编译规则由两行组成。<strong>第一行首先是编译产物，冒号后面是它的依赖项，第二行则是生成命令。</strong></p><p>​<strong>注意，第二行的缩进必须使用 Tab 键，如果使用空格键会报错。</strong></p><p>​完整的配置文件 makefile 由多个编译规则组成，可能是下面的样子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">foo: foo.o bar.o</span><br><span class="line">gcc -o foo foo.o bar.o</span><br><span class="line"></span><br><span class="line">foo.o: bar.h foo.c</span><br><span class="line">gcc -c foo.c</span><br><span class="line"></span><br><span class="line">bar.o: bar.h bar.c</span><br><span class="line">gcc -c bar.c</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>上面是 makefile 的一个示例文件。它包含三个编译规则，对应三个编译产物（<code>foo.o</code>、<code>bar.o</code>和<code>foo</code>），每个编译规则之间使用空行分隔。</strong></p><p>​<strong>有了 makefile，编译时，只要在 make 命令后面指定编译目标（编译产物的名字），就会自动调用对应的编译规则。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ make foo.o</span><br><span class="line"></span><br><span class="line"><span class="meta"># or</span></span><br><span class="line">$ make bar.o</span><br><span class="line"></span><br><span class="line"><span class="meta"># or</span></span><br><span class="line">$ make foo</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，make 命令会根据不同的命令，生成不同的编译产物。</p><p>​如果省略了编译目标，<code>make</code>命令会执行第一条编译规则，构建相应的产物。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>make</code>后面没有编译目标，所以会执行 makefile 的第一条编译规则，本例是<code>make foo</code>。<strong>由于用户期望执行<code>make</code>后得到最终的可执行文件，所以建议总是把最终可执行文件的编译规则，放在 makefile 文件的第一条。makefile 本身对编译规则没有顺序要求。</strong></p><p>​<strong>make 命令的强大之处在于，它不是每次执行命令，都会进行编译，而是会检查是否有必要重新编译。</strong>具体方法是，通过检查每个源码文件的时间戳，确定在上次编译之后，哪些文件发生过变动。然后，重新编译那些受到影响的编译产物（即编译产物直接或间接依赖于那些发生变动的源码文件），不受影响的编译产物，就不会重新编译。</p><p>​举例来说，上次编译之后，修改了<code>foo.c</code>，没有修改<code>bar.c</code>和<code>bar.h</code>。于是，重新运行<code>make foo</code>命令时，Make 就会发现<code>bar.c</code>和<code>bar.h</code>没有变动过，因此不用重新编译<code>bar.o</code>，只需要重新编译<code>foo.o</code>。有了新的<code>foo.o</code>以后，再跟<code>bar.o</code>一起，重新编译成新的可执行文件<code>foo</code>。</p><p>​Make 这样设计的最大好处，就是自动处理编译过程，只重新编译变动过的文件，因此大大节省了时间。</p><h2 id="命令行环境"><a href="#命令行环境" class="headerlink" title="命令行环境"></a>命令行环境</h2><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>​<strong>C 语言程序可以从命令行接收参数。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./foo hello world</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，程序<code>foo</code>接收了两个命令行参数<code>hello</code>和<code>world</code>。</p><p>​程序内部怎么拿到命令行参数呢？<strong>C 语言会把命令行输入的内容，放在一个数组里面。<code>main()</code>函数的参数可以接收到这个数组。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;arg %d: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>main()</code>函数有两个参数<code>argc</code>（argument count）和<code>argv</code>（argument variable）。<strong>这两个参数的名字可以任意取，但是一般来说，约定俗成就是使用这两个词。</strong></p><p>​<strong>第一个参数<code>argc</code>是命令行参数的数量，由于程序名也被计算在内，所以严格地说<code>argc</code>是参数数量 + 1。</strong></p><p>​<strong>第二个参数<code>argv</code>是一个数组，保存了所有的命令行输入，它的每个成员是一个字符串指针。</strong></p><p>​以<code>./foo hello world</code>为例，<code>argc</code>是3，表示命令行输入有三个组成部分：<code>./foo</code>、<code>hello</code>、<code>world</code>。数组<code>argv</code>用来获取这些输入，<code>argv[0]</code>是程序名<code>./foo</code>，<code>argv[1]</code>是<code>hello</code>，<code>argv[2]</code>是<code>world</code>。</p><p>​<strong>一般来说，<code>argv[1]</code>到<code>argv[argc - 1]</code>依次是命令行的所有参数。<code>argv[argc]</code>则是一个空指针 NULL。</strong></p><p>​<strong>由于字符串指针可以看成是字符数组，所以下面三种写法是等价的。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> argv[][])</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>另一方面，每个命令行参数既可以写成数组形式<code>argv[i]</code>，也可以写成指针形式<code>*(argv + i)</code>。</strong></p><p>​<strong>利用<code>argc</code>，可以限定函数只能有多少个参数。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: mult x y\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, atoi(argv[<span class="number">1</span>]) * atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>argc</code>不等于<code>3</code>就会报错，这样就限定了程序必须有两个参数，才能运行。</p><p>​<strong>另外，<code>argv</code>数组的最后一个成员是 NULL 指针（<code>argv[argc] == NULL</code>）。所以，参数的遍历也可以写成下面这样。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">char</span> **p = argv; *p != <span class="literal">NULL</span>; p++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg: %s\n&quot;</span>, *p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，指针<code>p</code>依次移动，指向<code>argv</code>的每个成员，一旦移到空指针 NULL，就表示遍历结束。<strong>由于<code>argv</code>的地址是固定的，不能执行自增运算（<code>argv++</code>），所以必须通过一个中间变量<code>p</code>，完成遍历操作。</strong></p><h3 id="退出状态"><a href="#退出状态" class="headerlink" title="退出状态"></a>退出状态</h3><p>​<strong>C 语言规定，如果<code>main()</code>函数没有<code>return</code>语句，那么结束运行的时候，默认会添加一句<code>return 0</code>，即返回整数<code>0</code>。这就是为什么<code>main()</code>语句通常约定返回一个整数值，并且返回整数<code>0</code>表示程序运行成功。如果返回非零值，就表示程序运行出了问题。</strong></p><p>​Bash 的环境变量<code>$?</code>可以用来读取上一个命令的返回值，从而知道是否运行成功。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./foo hello world</span><br><span class="line">$ echo $?</span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>echo $?</code>用来打印环境变量<code>$?</code>的值，该值为<code>0</code>，就表示上一条命令运行成功，否则就是运行失败。</p><p>​<strong>注意，只有<code>main()</code>会默认添加<code>return 0</code>，其他函数都没有这个机制。</strong></p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>​<strong>C 语言提供了<code>getenv()</code>函数（原型在<code>stdlib.h</code>）用来读取命令行环境变量。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *val = getenv(<span class="string">&quot;HOME&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (val == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Cannot find the HOME environment variable\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value: %s\n&quot;</span>, val);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>getenv(&quot;HOME&quot;)</code>用来获取命令行的环境变量<code>$HOME</code>，如果这个变量为空（<code>NULL</code>），则程序报错返回。</p><h2 id="多字节字符"><a href="#多字节字符" class="headerlink" title="多字节字符"></a>多字节字符</h2><p>​下面介绍 C 语言如何处理非英语字符。</p><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>​<strong>C 语言诞生时，只考虑了英语字符，使用7位的 ASCII 码表示所有字符。ASCII 码的范围是0到127，也就是最多只能表示100多个字符，用一个字节就可以表示，所以<code>char</code>类型只占用一个字节。</strong></p><p>​但是，如果处理非英语字符，一个字节就不够了，单单是中文，就至少有几万个字符，字符集就势必使用多个字节表示。</p><p>​最初，不同国家有自己的字符编码方式，这样不便于多种字符的混用。因此，后来就逐渐统一到 Unicode 编码，将所有字符放入一个字符集。</p><p>​<strong>Unicode 为每个字符提供一个号码，称为码点（code point），其中0到127的部分，跟 ASCII 码是重合的。通常使用“U+十六进制码点”表示一个字符，比如<code>U+0041</code>表示字母<code>A</code>。</strong></p><p>​Unicode 编码目前一共包含了100多万个字符，码点范围是 U+0000 到 U+10FFFF。完整表达整个 Unicode 字符集，至少需要三个字节。但是，并不是所有文档都需要那么多字符，比如对于 ASCII 码就够用的英语文档，如果每个字符使用三个字节表示，就会比单字节表示的文件体积大出三倍。</p><p>​为了适应不同的使用需求，Unicode 标准委员会提供了三种不同的表示方法，表示 Unicode 码点。</p><ul><li><strong>UTF-8：使用1个到4个字节，表示一个码点。不同的字符占用的字节数不一样。</strong></li><li><strong>UTF-16：对于U+0000 到 U+FFFF 的字符（称为基本平面），使用2个字节表示一个码点。其他字符使用4个字节。</strong></li><li><strong>UTF-32：统一使用4个字节，表示一个码点。</strong></li></ul><p>​其中，UTF-8 的使用最为广泛，因为对于 ASCII 字符（U+0000 到 U+007F），它只使用一个字节表示，这就跟 ASCII 的编码方式完全一样。</p><p>​<strong>C 语言提供了两个宏，表示当前系统支持的编码字节长度。这两个宏都定义在头文件<code>limits.h</code>。</strong></p><ul><li><code>MB_LEN_MAX</code>：任意支持地区的最大字节长度，定义在<code>limits.h</code>。</li><li><code>MB_CUR_MAX</code>：当前语言的最大字节长度，总是小于或等于<code>MB_LEN_MAX</code>，定义在<code>stdlib.h</code>。</li></ul><h3 id="字符的表示方法"><a href="#字符的表示方法" class="headerlink" title="字符的表示方法"></a>字符的表示方法</h3><p>​<strong>字符表示法的本质，是将每个字符映射为一个整数，然后从编码表获得该整数对应的字符。</strong></p><p>​C 语言提供了不同的写法，用来表示字符的整数号码。</p><ul><li><code>\123</code>：以八进制值表示一个字符，斜杠后面需要三个数字。</li><li><code>\x4D</code>：以十六进制表示一个字符，<code>\x</code>后面是十六进制整数。</li><li><code>\u2620</code>：以 Unicode 码点表示一个字符（不适用于 ASCII 字符），码点以十六进制表示，<code>\u</code>后面需要4个字符。</li><li><code>\U0001243F</code>：以 Unicode 码点表示一个字符（不适用于 ASCII 字符），码点以十六进制表示，<code>\U</code>后面需要8个字符。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ABC\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\101\102\103\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\x41\x42\x43\n&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面三行都会输出“ABC”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\u2022 Bullet 1\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\U00002022 Bullet 1\n&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面两行都会输出“Bullet 1”。</p><h3 id="多字节字符的表示"><a href="#多字节字符的表示" class="headerlink" title="多字节字符的表示"></a>多字节字符的表示</h3><p>​<strong>C 语言预设只有基本字符，才能使用字面量表示，其它字符都应该使用码点表示，并且当前系统还必须支持该码点的编码方法。</strong></p><p>​<strong>所谓基本字符，指的是所有可打印的 ASCII 字符，但是有三个字符除外：<code>@</code>、<code>$</code>、&#96;&#96;&#96;。</strong></p><p>​因此，遇到非英语字符，应该将其写成 Unicode 码点形式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s = <span class="string">&quot;\u6625\u5929&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s); <span class="comment">// 春天</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面代码会输出中文“春天”。</p><p>​<strong>如果当前系统是 UTF-8 编码，可以直接用字面量表示多字节字符。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s = <span class="string">&quot;春天&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>注意，<code>\u + 码点</code>和<code>\U + 码点</code>的写法，不能用来表示 ASCII 码字符（码点小于<code>0xA0</code>的字符），只有三个字符除外：<code>0x24</code>（<code>$</code>），<code>0x40</code>（<code>@</code>）和<code>0x60</code>（&#96;&#96;&#96;）。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s = <span class="string">&quot;\u0024\u0040\u0060&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);  <span class="comment">// @$`</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>上面代码会输出三个 Unicode 字符“@$&#96;”，但是其它 ASCII 字符都不能用这种表示法表示。</strong></p><p>​为了保证程序执行时，字符能够正确解读，最好将程序环境切换到本地化环境。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>上面代码中，使用<code>setlocale()</code>切换执行环境到系统的本地化语言。<code>setlocale()</code>的原型定义在头文件<code>locale.h</code>。</strong></p><p>​<strong>像下面这样，指定编码语言也可以。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;zh_CN.UTF-8&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面代码将程序执行环境，切换到中文环境的 UTF-8 编码。</p><p>​<strong>C 语言允许使用<code>u8</code>前缀，对多字节字符串指定编码方式为 UTF-8。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s = <span class="string">u8&quot;春天&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>一旦字符串里面包含多字节字符，就意味着字符串的字节数与字符数不再一一对应了</strong>。比如，字符串的长度为10字节，就不再是包含10个字符，而可能只包含7个字符、5个字符等等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* s = <span class="string">&quot;春天&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(s)); <span class="comment">// 6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，字符串<code>s</code>只包含两个字符，但是<code>strlen()</code>返回的结果却是6，表示这两个字符一共占据了6个字节。</p><p>​<strong>C 语言的字符串函数只针对单字节字符有效，对于多字节字符都会失效，比如<code>strtok()</code>、<code>strchr()</code>、<code>strspn()</code>、<code>toupper()</code>、<code>tolower()</code>、<code>isalpha()</code>等不会得到正确结果。</strong></p><h3 id="宽字符"><a href="#宽字符" class="headerlink" title="宽字符"></a>宽字符</h3><p>​<strong>多字节字符串，每个字符的字节宽度是可变的。这种编码方式虽然使用起来方便，但是很不利于字符串处理，因此必须逐一检查每个字符占用的字节数。所以除了这种方式，C 语言还提供了确定宽度的多字节字符存储方式，称为宽字符（wide character）。</strong></p><p>​<strong>所谓“宽字符”，就是每个字符占用的字节数是固定的，要么是2个字节，要么是4个字节。这样的话，就很容易快速处理。</strong></p><p>​<strong>宽字符有一个单独的数据类型 wchar_t，每个宽字符都是这个类型。它属于整数类型的别名，可能是有符号的，也可能是无符号的，由当前实现决定。该类型的长度为16位（2个字节）或32位（4个字节），足以容纳当前系统的所有字符。它定义在头文件<code>wchar.h</code>里面。</strong></p><p>​<strong>宽字符的字面量必须加上前缀“L”，否则 C 语言会把字面量当作窄字符类型处理。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">wchar_t</span> c = <span class="string">L&#x27;牛&#x27;</span>；</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lc\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line"><span class="type">wchar_t</span>* s = <span class="string">L&quot;春天&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ls\n&quot;</span>, s);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，前缀“L”在单引号前面，表示宽字符，对应<code>printf()</code>的占位符为<code>%lc</code>；在双引号前面，表示宽字符串，对应<code>printf()</code>的占位符为<code>%ls</code>。</p><p>​<strong>宽字符串的结尾也有一个空字符，不过是宽空字符，占用多个字节。</strong></p><p>​<strong>处理宽字符，需要使用宽字符专用的函数，绝大部分都定义在头文件<code>wchar.h</code>。</strong></p><h3 id="多字节字符处理函数"><a href="#多字节字符处理函数" class="headerlink" title="多字节字符处理函数"></a>多字节字符处理函数</h3><h4 id="mblen"><a href="#mblen" class="headerlink" title="mblen()"></a>mblen()</h4><p>​<strong><code>mblen()</code>函数返回一个多字节字符占用的字节数。</strong>它的原型定义在头文件<code>stdlib.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mblen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* mbstr, <span class="type">size_t</span> n)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>它接受两个参数，第一个参数是多字节字符串指针，一般会检查该字符串的第一个字符；第二个参数是需要检查的字节数，这个数字不能大于当前系统单个字符占用的最大字节，一般使用<code>MB_CUR_MAX</code>。</strong></p><p>​<strong>它的返回值是该字符占用的字节数。如果当前字符是空的宽字符，则返回<code>0</code>；如果当前字符不是有效的多字节字符，则返回<code>-1</code>。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* mbs1 = <span class="string">&quot;春天&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mblen(mbs1, MB_CUR_MAX)); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* mbs2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mblen(mbs2, MB_CUR_MAX)); <span class="comment">// 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，字符串“春天”的第一个字符“春”，占用3个字节；字符串“abc”的第一个字符“a”，占用1个字节。</p><h4 id="wctomb"><a href="#wctomb" class="headerlink" title="wctomb()"></a>wctomb()</h4><p>​<strong><code>wctomb()</code>函数（wide character to multibyte）用于将宽字符转为多字节字符。</strong>它的原型定义在头文件<code>stdlib.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wctomb</span><span class="params">(<span class="type">char</span>* s, <span class="type">wchar_t</span> wc)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong><code>wctomb()</code>接受两个参数，第一个参数是作为目标的多字节字符数组，第二个参数是需要转换的一个宽字符。它的返回值是多字节字符存储占用的字节数量，如果无法转换，则返回<code>-1</code>。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">wchar_t</span> wc = <span class="string">L&#x27;牛&#x27;</span>;</span><br><span class="line"><span class="type">char</span> mbStr[<span class="number">10</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nBytes = <span class="number">0</span>;</span><br><span class="line">nBytes = wctomb(mbStr, wc);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, mbStr);  <span class="comment">// 牛</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nBytes);  <span class="comment">// 3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>wctomb()</code>将宽字符“牛”转为多字节字符，<code>wctomb()</code>的返回值表示转换后的多字节字符占用3个字节。</p><h4 id="mbtowc"><a href="#mbtowc" class="headerlink" title="mbtowc()"></a>mbtowc()</h4><p>​<strong><code>mbtowc()</code>用于将多字节字符转为宽字符。</strong>它的原型定义在头文件<code>stdlib.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mbtowc</span><span class="params">(<span class="type">wchar_t</span>* wchar, <span class="type">const</span> <span class="type">char</span>* mbchar, <span class="type">size_t</span> count)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>它接受3个参数，第一个参数是作为目标的宽字符指针，第二个参数是待转换的多字节字符指针，第三个参数是多字节字符的字节数。</strong></p><p>​<strong>它的返回值是多字节字符的字节数，如果转换失败，则返回<code>-1</code>。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* mbchar = <span class="string">&quot;牛&quot;</span>;</span><br><span class="line"><span class="type">wchar_t</span> wc;</span><br><span class="line"><span class="type">wchar_t</span>* pwc = &amp;wc;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nBytes = <span class="number">0</span>;</span><br><span class="line">nBytes = mbtowc(pwc, mbchar, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nBytes); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lc\n&quot;</span>, *pwc);  <span class="comment">// 牛</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>mbtowc()</code>将多字节字符“牛”转为宽字符<code>wc</code>，返回值是<code>mbchar</code>占用的字节数（占用3个字节）。</p><h4 id="wcstombs"><a href="#wcstombs" class="headerlink" title="wcstombs()"></a>wcstombs()</h4><p>​<strong><code>wcstombs()</code>用来将宽字符串转换为多字节字符串。</strong>它的原型定义在头文件<code>stdlib.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">wcstombs</span><span class="params">(<span class="type">char</span>* mbstr, <span class="type">const</span> <span class="type">wchar_t</span>* wcstr, <span class="type">size_t</span> count)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>它接受三个参数，第一个参数<code>mbstr</code>是目标的多字节字符串指针，第二个参数<code>wcstr</code>是待转换的宽字符串指针，第三个参数<code>count</code>是用来存储多字节字符串的最大字节数。</strong></p><p>​<strong>如果转换成功，它的返回值是成功转换后的多字节字符串的字节数，不包括尾部的字符串终止符；如果转换失败，则返回<code>-1</code>。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> mbs[<span class="number">20</span>];</span><br><span class="line"><span class="type">wchar_t</span>* wcs = <span class="string">L&quot;春天&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nBytes = <span class="number">0</span>;</span><br><span class="line">nBytes = wcstombs(mbs, wcs, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, mbs); <span class="comment">// 春天</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nBytes); <span class="comment">// 6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，<code>wcstombs()</code>将宽字符串<code>wcs</code>转为多字节字符串<code>mbs</code>，返回值<code>6</code>表示写入<code>mbs</code>的字符串占用6个字节，<strong>不包括尾部的字符串终止符。</strong></p><p>​<strong>如果<code>wcstombs()</code>的第一个参数是 NULL，则返回转换成功所需要的目标字符串的字节数。</strong></p><h4 id="mbstowcs"><a href="#mbstowcs" class="headerlink" title="mbstowcs()"></a>mbstowcs()</h4><p>​<strong><code>mbstowcs()</code>用来将多字节字符串转换为宽字符串。</strong>它的原型定义在头文件<code>stdlib.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">mbstowcs</span><span class="params">(<span class="type">wchar_t</span>* wcstr, <span class="type">const</span> <span class="type">char</span>* mbstr, <span class="type">size_t</span> count)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>它接受三个参数，第一个参数<code>wcstr</code>是目标宽字符串，第二个参数<code>mbstr</code>是待转换的多字节字符串，第三个参数是待转换的多字节字符串的最大字符数。</strong></p><p>​<strong>转换成功时，它的返回值是成功转换的多字节字符的数量；转换失败时，返回<code>-1</code>。如果返回值与第三个参数相同，那么转换后的宽字符串不是以 NULL 结尾的。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* mbs = <span class="string">&quot;天气不错&quot;</span>;</span><br><span class="line"><span class="type">wchar_t</span> wcs[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nBytes = <span class="number">0</span>;</span><br><span class="line">nBytes = mbstowcs(wcs, mbs, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ls\n&quot;</span>, wcs); <span class="comment">// 天气不错</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nBytes); <span class="comment">// 4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面示例中，多字节字符串<code>mbs</code>被<code>mbstowcs()</code>转为宽字符串，成功转换了4个字符，所以该函数的返回值为4。</p><p>如果<code>mbstowcs()</code>的第一个参数为<code>NULL</code>，则返回目标宽字符串会包含的字符数量。</p><h2 id="标准库链接"><a href="#标准库链接" class="headerlink" title="标准库链接"></a>标准库链接</h2><ul><li><a href="https://wangdoc.com/clang/lib/assert.h.html">assert.h</a></li><li><a href="https://wangdoc.com/clang/lib/ctype.h.html">ctype.h</a></li><li><a href="https://wangdoc.com/clang/lib/errno.h.html">errno.h</a></li><li><a href="https://wangdoc.com/clang/lib/float.h.html">float.h</a></li><li><a href="https://wangdoc.com/clang/lib/inttypes.h.html">inttypes.h</a></li><li><a href="https://wangdoc.com/clang/lib/iso646.h.html">iso646.h</a></li><li><a href="https://wangdoc.com/clang/lib/limits.h.html">limits.h</a></li><li><a href="https://wangdoc.com/clang/lib/locale.h.html">locale.h</a></li><li><a href="https://wangdoc.com/clang/lib/math.h.html">math.h</a></li><li><a href="https://wangdoc.com/clang/lib/signal.h.html">signal.h</a></li><li><a href="https://wangdoc.com/clang/lib/stdint.h.html">stdint.h</a></li><li><a href="https://wangdoc.com/clang/lib/stdlib.h.html">stdlib.h</a></li><li><a href="https://wangdoc.com/clang/lib/stdio.h.html">stdio.h</a></li><li><a href="https://wangdoc.com/clang/lib/string.h.html">string.h</a></li><li><a href="https://wangdoc.com/clang/lib/time.h.html">time.h</a></li><li><a href="https://wangdoc.com/clang/lib/wchar.h.html">wchar.h</a></li><li><a href="https://wangdoc.com/clang/lib/wctype.h.html">wctype.h</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;C语言扩展总结&quot;&gt;&lt;a href=&quot;#C语言扩展总结&quot; class=&quot;headerlink&quot; title=&quot;C语言扩展总结&quot;&gt;&lt;/a&gt;C语言扩展总结&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​	本文内容大部分粘贴自原文章，对重要内容进行加粗标注，其中&lt;strong&gt;指针章节为专门章节&lt;/strong&gt;，跟原文无关，我自身用vc6.0对前面的案例代码进行了测试，并将其中不适配的地方以及原文说的不细致的地方进行了说明和补充。从内存管理开始更换了编译器，使用VS Code进行代码测试，对于VC6.0不支持的标准将不再提示。&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://wangdoc.com/clang/intro&quot;&gt;https://wangdoc.com/clang/intro&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="c语法" scheme="https://sixteen-nights.github.io/categories/c%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="c" scheme="https://sixteen-nights.github.io/tags/c/"/>
    
    <category term="总结" scheme="https://sixteen-nights.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer plus 学习笔记</title>
    <link href="https://sixteen-nights.github.io/2022/03/30/C++%20Primer%20plus%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://sixteen-nights.github.io/2022/03/30/C++%20Primer%20plus%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-30T03:40:00.000Z</published>
    <updated>2023-03-30T05:49:59.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-Primer-plus-学习笔记"><a href="#C-Primer-plus-学习笔记" class="headerlink" title="C++ Primer plus 学习笔记"></a>C++ Primer plus 学习笔记</h1><h2 id="第1章-预备知识"><a href="#第1章-预备知识" class="headerlink" title="第1章 预备知识"></a>第1章 预备知识</h2><h3 id="C-简史"><a href="#C-简史" class="headerlink" title="C++简史"></a>C++简史</h3><p>​C++融合了3种不同的编程方式：<strong>C语言代表的过程性语言，C++在C语言基础上添加的类代表的面向对象语言，C++模板支持的泛型编程。</strong></p><span id="more"></span><h2 id="第2章-开始学习C"><a href="#第2章-开始学习C" class="headerlink" title="第2章 开始学习C++"></a>第2章 开始学习C++</h2><h3 id="进入C"><a href="#进入C" class="headerlink" title="进入C++"></a>进入C++</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myfirst.cpp -- displays a message</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Come up an C++ me some time.&quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You won&#x27;t regret it !&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="main-函数"><a href="#main-函数" class="headerlink" title="main() 函数"></a>main() 函数</h4><p>​<strong>C++句法要求main( )函数的定义以函数头int main( )开始。</strong>事实上，该函数头描述的是main( )和操作系统之间的接口。 <strong>在C语言中，省略返回类型相当于说函数的类型为int。然而，C++逐步淘汰了这种用法。</strong>在括号中使用关键字void明确地指出，函数不接受任何参数。<strong>在C++（不是C）中，让括号空着与在括号中使用void等效（在C中，让括号空着意味着对是否接受参数保持沉默）。</strong>如果编译器到达main( )函数末尾 </p><p>时没有遇到返回语句，则认为main( )函数以如下语句结尾：return 0；<strong>这条隐含的返回语句只适用于main( )函数，而不适用于其他函数。</strong></p><h4 id="C-预处理器和iostream文件"><a href="#C-预处理器和iostream文件" class="headerlink" title="C++预处理器和iostream文件"></a>C++预处理器和iostream文件</h4><p>​<strong>如果程序要使用C++输入 或输出工具，请提供这样两行代码： <code>#include &lt;iostream&gt;</code>，<code> using namespace std;</code>。</strong></p><p>​#include编译指令导致iostream文件的内容随源代码文件的内容一起被发送给编译器。<strong>实际上，iostream文件的内容将取代程序中的代码行#include <iostream>。</strong></p><h4 id="头文件名"><a href="#头文件名" class="headerlink" title="头文件名"></a>头文件名</h4><p>​C语言的传统是，头文件使用扩展名h，将其作为一种通过名称标识文件类型的简单方式。例如，头文件math.h支持各种C语言数学函数，<strong>但C++的用法变了。现在，对老式C的头文件保留了扩展名 h（C++程序仍可以使用这种文件），而C++头文件则没有扩展名。有些C头文件被转换为C++头文件，这些文件被重新命名，去掉了扩展名 h（使之成为C++风格的名称），并在文件名称前面加上前缀c（表明来自C语言）。</strong>例如，C++版本的math.h为cmath。</p><h4 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h4><p>​<strong>如果使用iostream，而不是iostream.h，则应使用下面的名称空间编译指令来使iostream中的定义对程序可用：<code> using namespace std;</code>。</strong></p><p>​<strong>名称空间支持是一项C++特性，旨在让编写大型程序以及将多个厂商现有的代码组合起来的程序时更容易，它还有助于组织程序。</strong>一个潜在的问题是，可能使用两个已封装好的产品，而它们都包含一个名为wanda( )的函数。这样，使用wanda( )函数时，编译器将不知道指的是哪 个版本。名称空间让厂商能够将其产品封装在一个叫做名称空间的单元 中，这样就可以用名称空间的名称来指出想使用哪个厂商的产品。</p><p>​<strong><code> using namespace std;</code>：这个using编译指令使得std名称空间中的所有名称都可用。这是一种偷懒的做法，在大型项目中一个潜在的问题。更好的方法是，只使所需的名称可用，这可以通过使用using声明来实现。</strong></p><p>​<strong>同时，using是有作用域的概念的，比如如果写在单个函数中，那么只有单个函数中可以使用，如果写在全局，那么之后的所有函数都可以使用，当前通行的理念是，只让需要访问名称空间std的函数访问它是更好的选择。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello,world\n&quot;</span>;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;hello,world\n&quot;</span>;</span><br><span class="line"><span class="comment">//也等价于</span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello,world\n&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="使用cout进行C-输出"><a href="#使用cout进行C-输出" class="headerlink" title="使用cout进行C++输出"></a>使用cout进行C++输出</h4><p>​<strong>cout是一个预定义的对象，知道如何显示字符串、数字和单个字符等（第1章介绍过，对象是类的特定实例，而类定义了数据的存储和使用方式）。</strong></p><p>​从概念上看，输出是一个流，即从程序流出的一系列字符。cout对象表示这种流，其属性是在iostream文件中定义的。cout的对象属性包括一个插入运算符（&lt;&lt;），它可以将其右侧的信息插入到流中。</p><p>​插入运算符（&lt;&lt;）看上去就像按位左移运算符（&lt;&lt;），这是一个运算符重载的例子，通过重载，同一个运算符将有不同的含义。编译器通过上下文来确定运算符的含义。<strong>C++扩展了运算符重载的概念，允许为用户定义的类型（类）重新定义运算符的含义。</strong></p><h4 id="控制符endl和换行符-n"><a href="#控制符endl和换行符-n" class="headerlink" title="控制符endl和换行符\n"></a>控制符endl和换行符\n</h4><p>​<strong>endl是一个特殊的C++符号，表示一个重要的概念：重起一行。在输出流中插入endl将导致屏幕光标移到下一行开头。</strong>C++还提供了另一种在输出中指示换行的旧式方法：C语言符号\n。</p><p>​诸如endl等对于cout来说有特殊含义的特殊符号被称为控制符（manipulator）。和cout一样，endl也是在头文件iostream中定义的，且位于名称空间std中。</p><p>​<strong>一个差别是，endl确保程序继续运行前刷新输出（将其立即显示在屏幕上）；而使用“\n”不能提供这样的保证，这意味着在有些系统中，有时可能在您输入信息后才会出现提示。</strong></p><h3 id="C-语句"><a href="#C-语句" class="headerlink" title="C++语句"></a>C++语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    using namespace <span class="built_in">std</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> carrots;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;How many carrots do you have?&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; carrots;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Here are two more. &quot;</span>;</span><br><span class="line">    carrots = carrots + <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Now you have &quot;</span> &lt;&lt; carrots &lt;&lt; <span class="string">&quot; carrots.&quot;</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="cout"><a href="#cout" class="headerlink" title="cout"></a>cout</h4><p>​上述程序使用cout来打印变量，该变量的值是一个整数：<code>cout &lt;&lt; carrots;</code>。</p><p>​程序没有打印“carrots”，而是打印存储在carrots中的整数值，即25。实际上，这将两个操作合而为一了。首先，cout将carrots替换为其当前值25；然后，把值转换为合适的输出字符。</p><p>​要打印字符串，cout只需打印字符串中各个字符即可。但整数25被存储为数值，计算机不是单独存储每个数字，而是将25存储为二进制数。<strong>这里的要点是，在打印之前，cout必须将整数形式的数字转换为字符串形式。另外，cout很聪明，知道carrots是一个需要转换的整数。</strong> </p><p>​iostream文件定义了&lt;&lt;运算符，以便可以像下面这样合并（拼接）输出：<code>cout &lt;&lt; &quot;Now you have &quot; &lt;&lt; carrots &lt;&lt; &quot; carrots.&quot; &lt;&lt;endl;</code>。</p><h4 id="cin"><a href="#cin" class="headerlink" title="cin"></a>cin</h4><p>​上述程序使用cin来从键盘输入变量的值，执行语句：<code>cin &gt;&gt; carots;</code>。</p><p>​就像C++将输出看作是流出程序的字符流一样，它也将输 入看作是流入程序的字符流。iostream文件将cin定义为一个表示这种流的对象。输出时，&lt;&lt;运算符将字符串插入到输出流中；输入时，cin使用&gt;&gt;运算符从输入流中抽取字符。通常，需要在运算符右侧提供一个变量，以接收抽取的信息（符号&lt;&lt;和&gt;&gt;被选择用来指示信息流的方向）。 </p><p>​<strong>与cout一样，cin也是一个智能对象。它可以将通过键盘输入的一系列字符（即输入）转换为接收信息的变量能够接受的形式。</strong></p><h4 id="类简介"><a href="#类简介" class="headerlink" title="类简介"></a>类简介</h4><p>​<strong>类是C++中面向对象编程（OOP）的核心概念之一。 类是用户定义的一种数据类型。要定义类，需要描述它能够表示什么信息和可对数据执行哪些操作。类之于对象就像类型之于变量。也就是说，类定义描述的是数据格式及其用法，而对象则是根据数据格式规范创建的实体</strong>。换句话说，如果说类就好比所有著名演员，则对象就好比某个著名的演员，如蛙人Kermit。我们来扩展这种类比，表示演员的类中包括该类可执行的操作的定义，如念某一角色的台词，表达悲伤、威胁恫吓，接受奖励等。如果了解其他OOP术语，就知道C++类对应于某些语言中的对象类型，而C++对象对应于对象实例或实例变量。</p><p>​<strong>类描述了一种数据类型的全部属性（包括可使用它执行的操作），对象是根据这些描述创建的实体。</strong> </p><p>​<strong>与此同时，就像函数可以来自函数库一样，类也可以来自类库。</strong></p><p>​类描述指定了可对类对象执行的所有操作。要对特定对象执行这些允许的操作，需要给该对象发送一条消息。例如，如果希望cout对象显示一个字符串，应向它发送一条消息，告诉它，“对象！显示这些内容！”<strong>C++提供了两种发送消息的方式：一种方式是使用类方法（本质上就是函数调用）；另一种方式是重新定义运算符，cin和cout采用的就是这种方式。</strong></p><h2 id="第3章-处理数据"><a href="#第3章-处理数据" class="headerlink" title="第3章 处理数据"></a>第3章 处理数据</h2><h3 id="简单变量"><a href="#简单变量" class="headerlink" title="简单变量"></a>简单变量</h3><h4 id="C-11初始化方式"><a href="#C-11初始化方式" class="headerlink" title="C++11初始化方式"></a>C++11初始化方式</h4><p>​<strong>在C语言里，使用大括号可以方便的给数组和结构进行初始化，但在C++98中，这种方式也可以用于单值变量：<code>int a = &#123;24&#125;;</code>。</strong>将大括号初始化器用于单值变量的情形还不多，但C++11标准使得这种情形更多了。</p><p>​<strong>首先，采用这种方式时，可以使用等号（&#x3D;），也可以不使用：</strong> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a&#123;<span class="number">24</span>&#125;;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="type">int</span> a = &#123;<span class="number">24</span>&#125;;</span><br></pre></td></tr></table></figure><p>​<strong>其次，大括号内可以不包含任何东西。在这种情况下，变量将被初始化为零：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = &#123;&#125;;<span class="comment">// set a to 0</span></span><br></pre></td></tr></table></figure><p>​<strong>第三，这有助于更好地防范类型转换错误。</strong></p><p>​C++11将使用大括号的初始化称为列表初始化（list-initialization），因为这种初始化常用于给复杂的数据类型提供值列表。<strong>与用<code>=</code>赋值的初始化方式相比，它对类型转换的要求更严格。具体地说，列表初始化不允许缩窄（narrowing），即变量的类型可能无法表示赋给它的值。</strong>例如，不允许将浮点型转换为整型。在不同的整型之间转换或将整型转换为浮点型可能被允许，条件是编译器知道目标变量能够正确地存储赋给它的值。</p><h4 id="整形字面值"><a href="#整形字面值" class="headerlink" title="整形字面值"></a>整形字面值</h4><p>​整型字面值（常量）是显式地书写的常量，如212或1776。与C相同，C++能够以三种不同的计数方式来书写整数：基数为10、基数为8（老式UNIX版本）和基数为16（硬件黑客的最爱）。</p><p>​<strong>如果要以十六进制或八进制方式显示值，则可以使用cout的一些特殊特性。控制符dec、hex和oct，分别用于指示cout以十进制、十六进制和八进制格式显示整数。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> chest = <span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span> waist = <span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span> inseam = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Monsieur cuts a striking figure&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;chest = &quot;</span> &lt;&lt; chest &lt;&lt; <span class="string">&quot; (decimal for 42)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; hex;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;waist = &quot;</span> &lt;&lt; waist &lt;&lt; <span class="string">&quot; (hexadecimal for 42&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; oct;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;inseam = &quot;</span> &lt;&lt; inseam &lt;&lt; <span class="string">&quot; (octal for 42)&quot;</span> &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monsieur cuts a striking figure</span></span><br><span class="line"><span class="comment">// chest = 42 (decimal for 42)</span></span><br><span class="line"><span class="comment">// waist = 2a (hexadecimal for 42)</span></span><br><span class="line"><span class="comment">// inseam = 52 (octal for 42)</span></span><br></pre></td></tr></table></figure><p>​<strong>诸如<code>cout &lt;&lt; hex;</code>等代码不会在屏幕上显示任何内容，而只是修改cout显示整数的方式。因此，控制符hex实际上是一条消息，告诉cout采取何种行为。另外，由于标识符hex位于名称空间std中，而程序使用了 该名称空间，因此不能将hex用作变量名</strong>。然而，如果省略编译指令using，而使用std::cout、std::endl、std::hex和std::oct，则可以将hex用作变量名。 </p><h2 id="第4章-复合类型"><a href="#第4章-复合类型" class="headerlink" title="第4章 复合类型"></a>第4章 复合类型</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="C-11数组初始化方法"><a href="#C-11数组初始化方法" class="headerlink" title="C++11数组初始化方法"></a>C++11数组初始化方法</h4><p>​第3章说过，C++11将使用大括号的初始化（列表初始化）作为一种通用初始化方式，可用于所有类型。数组以前就可使用列表初始化，但C++11中的列表初始化新增了一些功能。</p><p>​<strong>首先，初始化数组时，可省略等号（&#x3D;）：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> earnings[<span class="number">4</span>] &#123;<span class="number">1.2e4</span>, <span class="number">1.6e4</span>, <span class="number">1.1e4</span>, <span class="number">1.7e4</span>&#125;;</span><br></pre></td></tr></table></figure><p>​<strong>其次，可不在大括号内包含任何东西，这将把所有元素都设置为零：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> earnings[<span class="number">10</span>] = &#123;&#125;; <span class="comment">// all elements set to 0</span></span><br></pre></td></tr></table></figure><p>​<strong>最后，列表初始化禁止缩窄转换：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> plifs[] = &#123;<span class="number">25</span>, <span class="number">92</span>, <span class="number">3.0</span>&#125;; <span class="comment">// not allowed</span></span><br><span class="line"><span class="type">char</span> slifs[<span class="number">4</span>] &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="number">1122011</span>&#125;; <span class="comment">// not allowed</span></span><br><span class="line"><span class="type">char</span> tlifs[<span class="number">4</span>] &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="number">112</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">// allowed</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="每次读取一行字符串输入"><a href="#每次读取一行字符串输入" class="headerlink" title="每次读取一行字符串输入"></a>每次读取一行字符串输入</h4><p>​cin使用空白（空格、制表符和换行符）来确定字符串的结束位置，这就意味着对于单词<code>New York</code>，它只能读取<code>New</code>，这是非常不方便的。要将整条短语而不是一个单词作为字符串输入，需要采用另一种字符串读取方法。具体地说，需要采用面向行而不是面向单词的方法。</p><ol><li><p><strong>面向行的输入：getline()</strong><br><strong>getline( )函数读取整行，它使用通过回车键输入的换行符来确定输入结尾。</strong>要调用这种方法，可以使用cin.getline( )。该函数有两个参数。第一个参数是用来存储输入行的数组的名称，第二个参数是要读取的字符数。<strong>如果这个参数为20，则函数最多读取19个字符，余下的空间用于存储自动在结尾处添加的空字符。</strong>getline( )成员函数在读取指定数目的字符或遇到换行符时停止读取。<br>  例如，假设要使用getline( )将姓名读入到一个包含20个元素的name数组中。可以使用这样的函数调用： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">getline</span>(name, <span class="number">20</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>面向行的输入：get()</strong><br><strong>istream类有另一个名为get( )的成员函数，该函数有几种变体。其中一种变体的工作方式与getline( )类似，它们接受的参数相同，解释参数的方式也相同，并且都读取到行尾。但get并不再读取并丢弃换行符，而是将其留在输入队列中。</strong><br>  假设我们连续两次调用get( )：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>(name, ArSize);</span><br><span class="line">cin.<span class="built_in">get</span>(dessert, Arsize); <span class="comment">// a problem</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​由于第一次调用后，换行符将留在输入队列中，因此第二次调用时看到的第一个字符便是换行符。因此get( )认为已到达行尾，而没有发现任何可读取的内容。如果不借助于帮助，get( )将不能跨过该换行符。</p><p>​<strong>幸运的是，get( )有另一种变体。使用不带任何参数的cin.get( )调用可读取下一个字符（即使是换行符），因此可以用它来处理换行符，为读取下一行输入做好准备。</strong>也就是说，可以采用下面的调用序列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>(name, ArSize);</span><br><span class="line">cin.<span class="built_in">get</span>();</span><br><span class="line">cin.<span class="built_in">get</span>(dessert, Arsize);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>另一种使用get( )的方式是将两个类成员函数拼接起来（合并），如下所示：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>(name, ArSize).<span class="built_in">get</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>之所以可以这样做，是由于cin.get（name，ArSize）返回一个cin对象，该对象随后将被用来调用get( )函数。</strong>同样，下面的语句将把输入中连续的两行分别读入到数组name1和name2 中，其效果与两次调用cin.getline( )相同：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">getline</span>(name1, ArSize).<span class="built_in">getline</span>(name2, ArSize);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>空行和其他问题</p><p>​当getline( )或get( )读取空行时，将发生什么情况？最初的做法是，下一条输入语句将在前一条getline( )或get( )结束读取的位置开始读取；<strong>但当前的做法是，当get( )（不是getline( )）读取空行后将设置失效位（failbit）。这意味着接下来的输入将被阻断，但可以用下面的命令来恢复输入：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">clear</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​另一个潜在的问题是，输入字符串可能比分配的空间长。<strong>如果输入行包含的字符数比指定的多，则getline( )和get( )将把余下的字符留在输入队列中，而getline( )还会设置失效位，并关闭后面的输入。</strong></p></li></ol><h4 id="混合输入字符串和数字"><a href="#混合输入字符串和数字" class="headerlink" title="混合输入字符串和数字"></a>混合输入字符串和数字</h4><p>​混合输入数字和面向行的字符串会导致问题。例如下面这个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;What year was your house built?\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    cin &gt;&gt; year;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;What is its street address?\n&quot;</span>;</span><br><span class="line">    <span class="type">char</span> address[<span class="number">80</span>];</span><br><span class="line">    cin.<span class="built_in">getline</span>(address, <span class="number">80</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Year built: &quot;</span> &lt;&lt; year &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Address: &quot;</span> &lt;&lt; address &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Done!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该程序的运行结果如下：</span></span><br><span class="line"><span class="comment">//What year was your house built?</span></span><br><span class="line"><span class="comment">//1966 </span></span><br><span class="line"><span class="comment">//What is its street address?</span></span><br><span class="line"><span class="comment">//Year built: 1966</span></span><br><span class="line"><span class="comment">//Address:</span></span><br><span class="line"><span class="comment">//Done!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​用户根本没有输入地址的机会。问题在于，当cin读取年份，将回车键生成的换行符留在了输入队列中。后面的cin.getline( )看到换行符后，将认为是一个空行，并将一个空字符串赋给address数组。</p><p>​<strong>解决之道是，在读取地址之前先读取并丢弃换行符。这可以通过几种方法来完成，其中包括使用没有参数的get( )和使用接受一个char参数的get( )，如前面的例子所示。可以单独进行调用：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; year;</span><br><span class="line">cin.<span class="built_in">get</span>(); <span class="comment">// or cin.get(ch);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>也可以利用表达式cin&gt;&gt;year返回cin对象，将调用拼接起来：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(cin &gt;&gt; year).<span class="built_in">get</span>(); <span class="comment">// or (cin &gt;&gt; year).get(ch);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="string-类简介"><a href="#string-类简介" class="headerlink" title="string 类简介"></a>string 类简介</h3><p>​ISO&#x2F;ANSI C++98标准通过添加string类扩展了C++库，因此现在可以string类型的变量（使用C++的话说是对象）而不是字符数组来存储字符串。</p><p>​<strong>要使用string类，必须在程序中包含头文件string。string类位于名称空间std中，因此必须提供一条using编译指令，或者使用std::string来引用它。</strong>string类定义隐藏了字符串的数组性质，让用户能够像处理普通变量那样处理字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> charr1[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> charr2[<span class="number">20</span>] = <span class="string">&quot;jaguar&quot;</span>;</span><br><span class="line">    string str1;</span><br><span class="line">    string str2 = <span class="string">&quot;panther&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter a kind of feline: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; charr1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter another kind of feline: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; str1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Here are some filines: \n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; charr1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; charr2 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">         &lt;&lt; str1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The third letter in &quot;</span> &lt;&lt; charr2 &lt;&lt; <span class="string">&quot; is &quot;</span></span><br><span class="line">         &lt;&lt; charr2[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The third letter in &quot;</span> &lt;&lt; str2 &lt;&lt; <span class="string">&quot; is &quot;</span></span><br><span class="line">         &lt;&lt; str2[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果如下：</span></span><br><span class="line"><span class="comment">// Enter a kind of feline: ocelot</span></span><br><span class="line"><span class="comment">// Enter another kind of feline: tiger</span></span><br><span class="line"><span class="comment">// Here are some filines: </span></span><br><span class="line"><span class="comment">// ocelot jaguar tiger panther</span></span><br><span class="line"><span class="comment">// The third letter in jaguar is g</span></span><br><span class="line"><span class="comment">// The third letter in panther is n</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​从这个示例可知，在很多方面，使用string对象的方式与使用字符数组相同。</p><ul><li>可以使用C-风格字符串来初始化string对象。 </li><li>可以使用cin来将键盘输入存储到string对象中。 </li><li>可以使用cout来显示string对象。 </li><li>可以使用数组表示法来访问存储在string对象中的字符。</li></ul><p>​<strong>string对象和字符数组之间的主要区别是，可以将string对象声明为简单变量，而不是数组：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str1; <span class="comment">// create an empty string object</span></span><br><span class="line">string str2 = <span class="string">&quot;panther&quot;</span>; <span class="comment">// create an initialized string</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>类设计让程序能够自动处理string的大小。</strong></p><p>​例如，<strong>str1的声明创建一个长度为0的string对象，但程序将输入读取到str1中时，将自动调整str1的长度：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; str1; <span class="comment">// str1 resized to fit inpt</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​这使得与使用数组相比，使用string对象更方便，也更安全。从理论上说，可以将char数组视为一组用于存储一个字符串的char存储单元，而string类变量是一个表示字符串的实体。</p><h4 id="C-11字符串初始化"><a href="#C-11字符串初始化" class="headerlink" title="C++11字符串初始化"></a><strong>C++11</strong>字符串初始化</h4><p>​<strong>C++11也允许将列表初始化用于C-风格字符串和string对象：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string third_data = &#123;<span class="string">&quot;The Bread Bowl&quot;</span>&#125;;</span><br><span class="line">string fourth_data &#123;<span class="string">&quot;Hank&#x27;s Fine Eats&quot;</span>&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="赋值、拼接和附加"><a href="#赋值、拼接和附加" class="headerlink" title="赋值、拼接和附加"></a>赋值、拼接和附加</h4><p>​<strong>使用string类时，某些操作比使用数组时更简单。例如，不能将一个数组赋给另一个数组，但可以将一个string对象赋给另一个string对象：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> charr1[<span class="number">20</span>];<span class="comment">// create an empty array</span></span><br><span class="line"><span class="type">char</span> charr2[<span class="number">20</span>] = <span class="string">&quot;jagua&quot;</span>;<span class="comment">// create an initialized arry</span></span><br><span class="line">string str1;<span class="comment">// create an empty string object</span></span><br><span class="line">string str2 = <span class="string">&quot;panther&quot;</span>;<span class="comment">// create an initialized string</span></span><br><span class="line">charr1 = charr2;<span class="comment">// INVALID, no array assignment</span></span><br><span class="line">str1 = str2;<span class="comment">// VALID, object assignment ok</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>string类简化了字符串合并操作。可以使用运算符+将两个string对象合并起来，还可以使用运算符+&#x3D;将字符串附加到string对象的末尾。继续前面的代码，可以这样做：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str3;</span><br><span class="line">str3 = str1 + str2;<span class="comment">// assign str3 the joined strings</span></span><br><span class="line">str1 += str2;<span class="comment">// add str2 to the end of str1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>可以将C-风格字符串或string对象与string对象相加，或将它们附加到string对象的末尾。</strong>以下是一个案例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">    string s1 = <span class="string">&quot;penguin&quot;</span>;</span><br><span class="line">    string s2, s3;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You can assign one string object to another: s2 = s1\n&quot;</span>;</span><br><span class="line">    s2 = s1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="string">&quot;, s2: &quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You can assin a C-style string to a string object.\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s2 = \&quot;buzzard\&quot;\n&quot;</span>;</span><br><span class="line">    s2 = <span class="string">&quot;buzzard&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s2: &quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You can concatenate strings: s3 = s1 + s2\n&quot;</span>;</span><br><span class="line">    s3 = s1 + s2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s3: &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You can append strings.\n&quot;</span>;</span><br><span class="line">    s1 += s2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1 += s2 yields s1 = &quot;</span> &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">    s2 += <span class="string">&quot; for a day&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s2 += \&quot; for a day\&quot; yields s2 = &quot;</span> &lt;&lt; s2 &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="comment">// You can assign one string object to another: s2 = s1</span></span><br><span class="line"><span class="comment">// s1: penguin, s2: penguin</span></span><br><span class="line"><span class="comment">// You can assin a C-style string to a string object.</span></span><br><span class="line"><span class="comment">// s2 = &quot;buzzard&quot;</span></span><br><span class="line"><span class="comment">// s2: buzzard</span></span><br><span class="line"><span class="comment">// You can concatenate strings: s3 = s1 + s2</span></span><br><span class="line"><span class="comment">// s3: penguinbuzzard</span></span><br><span class="line"><span class="comment">// You can append strings.</span></span><br><span class="line"><span class="comment">// s1 += s2 yields s1 = penguinbuzzard</span></span><br><span class="line"><span class="comment">// s2 += &quot; for a day&quot; yields s2 = buzzard for a day</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="string类的其他操作"><a href="#string类的其他操作" class="headerlink" title="string类的其他操作"></a>string类的其他操作</h4><p>​在C++新增string类之前，程序员也需要完成诸如给字符串赋值等工作。对于C-风格字符串，程序员使用C语言库中的函数来完成这些任务。头文件cstring（以前为string.h）提供了这些函数。例如，可以使用函数strcpy()将字符串复制到字符数组中，使用函数strcat()将字符串附加到字符数组末尾：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(charr1, charr2);<span class="comment">// copy charr2 to charr1</span></span><br><span class="line"><span class="built_in">strcat</span>(charr1, charr2);<span class="comment">// append contents of charr2 to charr1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​下面程序展示了对用于string对象的技术和用于字符数组的技术的了比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> charr1[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> charr2[<span class="number">20</span>] = <span class="string">&quot;jaguar&quot;</span>;</span><br><span class="line">    string str1;</span><br><span class="line">    string str2 = <span class="string">&quot;panther&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assigment for string objects and character arrays</span></span><br><span class="line">    str1 = str2;</span><br><span class="line">    <span class="built_in">strcpy</span>(charr1, charr2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// appending for string objects and character arrays</span></span><br><span class="line">    str1 += <span class="string">&quot; paste&quot;</span>;</span><br><span class="line">    <span class="built_in">strcat</span>(charr1, charr2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// finding the length of a string object and a C-style string</span></span><br><span class="line">    <span class="type">int</span> len1 = str1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> len2 = <span class="built_in">strlen</span>(charr1);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The string &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="string">&quot; contans &quot;</span> &lt;&lt; len1 &lt;&lt; <span class="string">&quot; characters.\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The string &quot;</span> &lt;&lt; charr1 &lt;&lt; <span class="string">&quot; contans &quot;</span> &lt;&lt; len2 &lt;&lt; <span class="string">&quot; characters.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// The string panther paste contans 13 characters.</span></span><br><span class="line"><span class="comment">// The string jaguarjaguar contans 12 characters.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​处理string对象的语法通常比使用C字符串函数简单，尤其是执行较为复杂的操作时。另外，使用字符数组时，总是存在目标数组过小，无法存储指定信息的危险，<strong>string类具有自动调整大小的功能，从而能够避免这种问题发生。</strong></p><h4 id="string类I-x2F-O"><a href="#string类I-x2F-O" class="headerlink" title="string类I&#x2F;O"></a>string类I&#x2F;O</h4><p>​可以使用cin和运算符&lt;&lt;来将输入存储到string对象中，使用cout和运算符&lt;&lt;来显示string对象，其句法与处理C-风格字符串相同。但每次读取一行而不是一个单词时，使用的句法不同，下面的程序说明了这一点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> charr[<span class="number">20</span>];</span><br><span class="line">    string str;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Length of string in charr before input: &quot;</span> &lt;&lt; <span class="built_in">strlen</span>(charr) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Length of string in str before input: &quot;</span> &lt;&lt; str.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter a line of text:\n&quot;</span>;</span><br><span class="line">    cin.<span class="built_in">getline</span>(charr, <span class="number">20</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; charr &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter another line of text:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">getline</span>(cin, str);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Length of string in charr after input: &quot;</span> &lt;&lt; <span class="built_in">strlen</span>(charr) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Length of string in str after input: &quot;</span> &lt;&lt; str.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// Length of string in charr before input: 1</span></span><br><span class="line"><span class="comment">// Length of string in str before input: 0</span></span><br><span class="line"><span class="comment">// Enter a line of text:</span></span><br><span class="line"><span class="comment">// peanut butter</span></span><br><span class="line"><span class="comment">// You entered: peanut butter</span></span><br><span class="line"><span class="comment">// Enter another line of text:</span></span><br><span class="line"><span class="comment">// blueberry jam</span></span><br><span class="line"><span class="comment">// You entered: blueberry jam</span></span><br><span class="line"><span class="comment">// Length of string in charr after input: 13</span></span><br><span class="line"><span class="comment">// Length of string in str after input: 13</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​在用户输入之前，该程序指出数组charr中的字符串长度为1，这比数组的长度要小。因此在这里需要明确两点。首先，未初始化的数组的内容是未定义的；其次，函数strlen()从数组的第一个元素开始计算字节数，直到遇到空字符。在这个例子中，还未到数组的末尾就遇到了空字符。对于未被初始化的数据，第一个空字符出现的位置是随机的。另外，用户输入之前，str中的字符串长度为0。这是因为未被初始化的string对象的长度被自动设置为0。 </p><p>​<strong>下面是将一行输入读取到数组中的代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">getline</span>(charr, <span class="number">20</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>这种句点表示法表明，函数getline( )是istream类的一个类方法（cin是一个istream对象）。正如前面指出的，第一个参数是目标数组；第二个参数数组长度，getline( )使用它来避免超越数组的边界。</strong> </p><p>​<strong>下面是将一行输入读取到string对象中的代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getline</span>(cin, str);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>这里没有使用句点表示法，这表明这个getline( )不是类方法。它将cin作为参数，指出到哪里去查找输入。另外，也没有指出字符串长度的参数，因为string对象将根据字符串的长度自动调整自己的大小。</strong> </p><p>​那么，为何一个getline( )是istream的类方法，而另一个不是呢？在引入string类之前很久，C++就有istream类。因此istream的设计考虑到了诸如double和int等基本C++数据类型，但没有考虑string类型，所以istream类中，有处理double、int和其他基本类型的类方法，但没有处理string对象的类方法。 </p><p>​<strong>虽然istream类中没有处理string对象的类方法，但是可以将cin和cout用于string对象，例如下面的代码是可行的，但本章在这里不考虑其内部工作原理。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; str;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="其他形式的字符串字面值"><a href="#其他形式的字符串字面值" class="headerlink" title="其他形式的字符串字面值"></a>其他形式的字符串字面值</h4><p>​除char类型外，C++还有类型wchar_t；而C++11新增了类型char16_t和char32_t。可创建这些类型的数组和这些类型的字符 串字面值。<strong>对于这些类型的字符串字面值，C++分别使用前缀L、u和U 表示</strong>，下面是一个如何使用这些前缀的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wchar_t</span> title[] = <span class="string">L&quot;Chief Astrogator&quot;</span>;</span><br><span class="line"><span class="type">char16_t</span> name[] = <span class="string">u&quot;Felonia Ripova&quot;</span>;</span><br><span class="line"><span class="type">char32_t</span> car[] = <span class="string">U&quot;Humber Super Snipe&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>C++11还支持Unicode字符编码方案UTF-8。在这种方案中，根据编码的数字值，字符可能存储为1～4个八位组。C++使用前缀u8来表示这种类型的字符串字面值。</strong> </p><p>​<strong>C++11新增的另一种类型是原始（raw）字符串。</strong>在原始字符串中，字符表示的就是自己，例如，序列\n不表示换行符，而表示两个常规字符—斜杠和n，因此在屏幕上显示时，将显示这两个字符。另一个例子是，可在字符串中使用”，而无需使用繁琐的 \“。当然，既然可在字符串字面量包含”，就不能再使用它来表示字符串的开头和末尾。因此，<strong>原始字符串将”(和)”用作定界符，并使用前缀R来标识原始字符串：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">R&quot;(Jim &quot;King&quot; Tutt uses &quot;\n&quot; instead of endl.)&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="comment">//Jim &quot;King&quot; Tutt uses &quot;\n&quot; instead of endl.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​输入原始字符串时，按回车键不仅会移到下一行，还将在原始字符串中添加回车字符。 </p><p>​如果要在原始字符串中包含 )” ，该如何办呢？编译器见到第一个 )” 时，会不会认为字符串到此结束？会的。但原始字符串语法允许在表示字符串开头的 “ 和 ( 之间添加其他字符，这意味着表示字符串结尾的 “ 和 ) 之间也必须包含这些字符。<strong>因此，使用 R”+* 标识原始字符串的开头时，必须使用) +*“ 标识原始字符串的结尾。</strong>因此，下面的语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">R&quot;+*(&quot;(Who wouldn&#x27;t?)&quot;, she whispered.)+*&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="comment">// &quot;(Who wouldn&#x27;t?)&quot;, she whispered.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>总之，这使用 “+*( 和 )+* “替代了默认定界符 “( 和 )” 。</strong>自定义定界符时，在默认定界符之间添加任意数量的基本字符，但空格、左括号、右括号、斜杠和控制字符（如制表符和换行符）除外。 </p><p>​<strong>可将前缀R与其他字符串前缀结合使用，以标识wchar_t等类型的原始字符串。可将R放在前面，也可将其放在后面，如Ru、UR等。</strong></p><h3 id="结构简介"><a href="#结构简介" class="headerlink" title="结构简介"></a>结构简介</h3><p>​C++允许在声明结构变量时省略关键字struct。</p><h4 id="C-11结构初始化"><a href="#C-11结构初始化" class="headerlink" title="C++11结构初始化"></a>C++11结构初始化</h4><p>​与数组一样，C++11也支持将列表初始化用于结构，且等号（&#x3D;）是可选的；其次，如果大括号内未包含任何东西，各个成员都将被设置为零；最后，不允许缩窄转换。</p><h4 id="结构中的位字段"><a href="#结构中的位字段" class="headerlink" title="结构中的位字段"></a>结构中的位字段</h4><p>​与C语言一样，C++也允许指定占用特定位数的结构成员，这使得创建与某个硬件设备上的寄存器对应的数据结构非常方便。<strong>字段的类型应为整型或枚举，接下来是冒号，冒号后面是一个数字，它指定了使用的位数。可以使用没有名称的字段来提供间距。每个成员都被称为位字段（bit field）。</strong>下面是一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">torgle_register</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> SN : <span class="number">4</span>;<span class="comment">// 4 bits for SN value</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> : <span class="number">4</span>;<span class="comment">// 4 bits unused</span></span><br><span class="line">    <span class="type">bool</span> goodIn : <span class="number">1</span>;<span class="comment">// valid input (1 bit)</span></span><br><span class="line">    boo goodTorgle : <span class="number">1</span>;<span class="comment">// successful torgling</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><h4 id="设置枚举量的值"><a href="#设置枚举量的值" class="headerlink" title="设置枚举量的值"></a>设置枚举量的值</h4><p>​可以创建多个值相同的枚举量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;zero, null = <span class="number">0</span>, one, numero_uno = <span class="number">1</span>&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​其中，zero和null都为0，one和umero_uno都为1。在C++早期的版本中，只能将int值（或提升为int的值）赋给枚举量，但这种限制取消了，因此可以使用long甚至long long类型的值。</p><h4 id="枚举的取值范围"><a href="#枚举的取值范围" class="headerlink" title="枚举的取值范围"></a>枚举的取值范围</h4><p>​最初，对于枚举来说，只有声明中指出的那些值是有效的。然而，C++现在通过强制类型转换，增加了可赋给枚举变量的合法值。<strong>每个枚举都有取值范围（range），通过强制类型转换，可以将取值范围中的任何整数值赋给枚举变量，即使这个值不是枚举值。</strong></p><p>​例如，假设bits和myflag的定义如下：其中6不是枚举值，但它位于枚举定义的取值范围内。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">bits</span>&#123;one = <span class="number">1</span>, two = <span class="number">2</span>, four = <span class="number">4</span>, eight = <span class="number">8</span>&#125;;</span><br><span class="line">bits myflag;</span><br><span class="line">muflag = <span class="built_in">bits</span>(<span class="number">6</span>);<span class="comment">// valid,because 6 is in bits range</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​取值范围的定义如下：</p><p>​首先，要找出上限，需要知道枚举量的最大值。找到大于这个最大值的、最小的2的幂，将它减去1，得到的便是取值范围的上限。例如，前面定义的bigstep的最大值枚举值是101。在2的幂中，比这个数大的最小值为128，因此取值范围的上限为127。</p><p>​其次，要计算下限，需要知道枚举量的最小值。如果它不小于0，则取值范围的下限为0；否则，采用与寻找上限方式相同的方式，但加上负号。例如，如果最小的枚举量为−6，而比它小的、最大的2的幂是−8（加上负号），因此下限为−7。 </p><p>​选择用多少空间来存储枚举由编译器决定。对于取值范围较小的枚举，使用一个字节或更少的空间；而对于包含long类型值的枚举，则使用4个字节。 </p><h3 id="指针、数组和自由储存空间"><a href="#指针、数组和自由储存空间" class="headerlink" title="指针、数组和自由储存空间"></a>指针、数组和自由储存空间</h3><p>​C++使用new来分配内存，使用delete来释放内存。使用new和delete时，应遵守以下规则。</p><ul><li>不要使用delete来释放不是new分配的内存。 </li><li>不要使用delete释放同一个内存块两次。 </li><li>如果使用new [ ]为数组分配内存，则应使用delete [ ]来释放。 </li><li>如果使用new 为一个实体分配内存，则应使用delete（没有方括号）来释放。</li><li>对空指针应用delete是安全的。</li></ul><h4 id="使用new创建动态结构"><a href="#使用new创建动态结构" class="headerlink" title="使用new创建动态结构"></a>使用new创建动态结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">getname</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    </span><br><span class="line">    name = <span class="built_in">getname</span>();</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot; at &quot;</span> &lt;&lt; (<span class="type">int</span>*) name &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> [] name;</span><br><span class="line"></span><br><span class="line">    name = <span class="built_in">getname</span>();</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot; at &quot;</span> &lt;&lt; (<span class="type">int</span>*) name &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> [] name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">getname</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">80</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter last name: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; temp;</span><br><span class="line">    <span class="type">char</span> *pn = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(temp) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(pn, temp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// Enter last name: Fredeldumpkin</span></span><br><span class="line"><span class="comment">// Fredeldumpkin at 0xf11630</span></span><br><span class="line"><span class="comment">// Enter last name: Pook</span></span><br><span class="line"><span class="comment">// Pook at 0xf11630</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​上面程序定义了一个函数getname( )，该函数返回一个指向输入字符串的指针。该函数将输入读入到一个大型的临时数组中，然后使用new [ ]创建一个刚好能够存储该输入字符串的内存块，并返回一个指向该内存块的指针。对于读取大量字符串的程序，这种方法可以节省大量内存（实际编写程序时，使用string类将更容易，因为这样可以使用内置的new和delete）。</p><h4 id="自动存储、静态存储和动态存储"><a href="#自动存储、静态存储和动态存储" class="headerlink" title="自动存储、静态存储和动态存储"></a>自动存储、静态存储和动态存储</h4><p>​根据用于分配内存的方法，C++有3种管理数据内存的方式：自动存储、静态存储和动态存储（有时也叫作自由存储空间或堆）。在存在时间的长短方面，以这3种方式分配的数据对象各不相同。下面简要地介绍每种类型（C++11新增了第四种类型—线程存储，这将在第9章简要地讨论）。 </p><ol><li><p>自动存储<br><strong>在函数内部定义的常规变量使用自动存储空间，被称为自动变量 （automatic variable），这意味着它们在所属的函数被调用时自动产生，在该函数结束时消亡。（存储在栈区）</strong></p></li><li><p>静态存储</p><p>​<strong>静态存储是整个程序执行期间都存在的存储方式。使变量成为静态的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用关键字static。（存储在全局区）</strong></p></li><li><p>动态存储</p><p>​<strong>new和delete运算符提供了一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，这在C++中被称为自由存储空间（free store）或堆（heap）。（存储在堆区）</strong></p></li></ol><h3 id="数组的代替品"><a href="#数组的代替品" class="headerlink" title="数组的代替品"></a>数组的代替品</h3><h4 id="模板类vecto"><a href="#模板类vecto" class="headerlink" title="模板类vecto"></a>模板类vecto</h4><p>​<strong>模板类vector类似于string类，也是一种动态数组。可以在运行阶段设置vector对象的长度，可在末尾附加新数据，还可在中间插入新数据。</strong>基本上，它是使用new创建动态数组的替代品。实际上，vector类确实使用new和delete来管理内存，但这种工作是自动完成的。 </p><p>​首先，要使用vector对象，必须包含头文件vector。</p><p>​其次，vector包含在名称空间std中。</p><p>​第三，模板使用不同的语法来指出它存储的数据类型。</p><p>​第四，vector类使用不同的语法来指定元素数。</p><p>​下面是一些示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">vd</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​其中，vi是一个vector&lt;int&gt;对象，vd是一个vector&lt;double&gt;对象。由于vector对象在插入或添加值时自动调整长度，因此可以将vi的初始长度设置为零。但要调整长度，需要使用vector包中的各种方法。</p><p>​一般而言，下面的声明创建一个名为vt的vector对象，它可存储n_elem个类型为typeName的元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;typeName&gt; <span class="title">vt</span><span class="params">(n_elem)</span></span>;</span><br></pre></td></tr></table></figure><p>​其中参数&lt;typeName&gt;可以是整形常量，也可以是整形变量。</p><h4 id="模板类array（C-11）"><a href="#模板类array（C-11）" class="headerlink" title="模板类array（C++11）"></a>模板类array（C++11）</h4><p>​vector类的功能比数组强大，但付出的代价是效率稍低。如果需要的是长度固定的数组，使用数组是更佳的选择，但代价是不那么方便和安全。有鉴于此，C++11新增了模板类array，它也位于名称空间std中。与数组一样，array对象的长度也是固定的，也使用栈（静态内存分配），而不是自由存储区，因此其效率与数组相同，但更方便，更安全。要创建array对象，需要包含头文件array。array对象的创建语法与vector稍有不同：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>, 5&gt; ai;</span><br><span class="line">    array&lt;<span class="type">double</span>, 4&gt; ad = &#123;<span class="number">1.2</span>, <span class="number">2.1</span>, <span class="number">3.43</span>, <span class="number">4.3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​推而广之，下面的声明创建一个名为arr的array对象，它包含n_elem个类型为typename的元素： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array&lt;typeName, n_elem&gt; arr;</span><br></pre></td></tr></table></figure><p>​与创建vector对象不同的是，n_elem不能是变量。 </p><p>​在C++11中，可将列表初始化用于vector和array对象，但在C++98中，不能对vector对象这样做。</p><h4 id="比较数组、vector对象和array对象"><a href="#比较数组、vector对象和array对象" class="headerlink" title="比较数组、vector对象和array对象"></a>比较数组、vector对象和array对象</h4><p>​下面示例展示数组、vector对象和array对象的相似和不同之处：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> a1[<span class="number">4</span>] = &#123;<span class="number">1.2</span>, <span class="number">2.4</span>, <span class="number">3.6</span>, <span class="number">4.8</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">a2</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    a2[<span class="number">0</span>] = <span class="number">1.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    a2[<span class="number">1</span>] = <span class="number">1.0</span> / <span class="number">5.0</span>;</span><br><span class="line">    a2[<span class="number">2</span>] = <span class="number">1.0</span> / <span class="number">7.0</span>;</span><br><span class="line">    a2[<span class="number">3</span>] = <span class="number">1.0</span> / <span class="number">9.0</span>;</span><br><span class="line"></span><br><span class="line">    array&lt;<span class="type">double</span>, 4&gt; a3 = &#123;<span class="number">3.14</span>, <span class="number">2.72</span>, <span class="number">1.62</span>, <span class="number">1.41</span>&#125;;</span><br><span class="line">    array&lt;<span class="type">double</span>, 4&gt; a4;</span><br><span class="line">    a4 = a3;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1[2]: &quot;</span> &lt;&lt; a1[<span class="number">2</span>] &lt;&lt; <span class="string">&quot; at &quot;</span> &lt;&lt; &amp;a1[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2[2]: &quot;</span> &lt;&lt; a2[<span class="number">2</span>] &lt;&lt; <span class="string">&quot; at &quot;</span> &lt;&lt; &amp;a2[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a3[2]: &quot;</span> &lt;&lt; a3[<span class="number">2</span>] &lt;&lt; <span class="string">&quot; at &quot;</span> &lt;&lt; &amp;a3[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a4[2]: &quot;</span> &lt;&lt; a4[<span class="number">2</span>] &lt;&lt; <span class="string">&quot; at &quot;</span> &lt;&lt; &amp;a4[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a1[2]: 3.6 at 0x61fdf0</span></span><br><span class="line"><span class="comment">// a2[2]: 0.142857 at 0x6c1630</span></span><br><span class="line"><span class="comment">// a3[2]: 1.62 at 0x61fdb0</span></span><br><span class="line"><span class="comment">// a4[2]: 1.62 at 0x61fd90</span></span><br></pre></td></tr></table></figure><p>​首先，注意到无论是数组、vector对象还是array对象，都可使用标准数组表示法来访问各个元素。其次，从地址可知，array对象和数组存储在相同的内存区域（即栈）中，而vector对象存储在另一个区域（自由存储区或堆）中。<strong>第三，注意到可以将一个array对象赋给另一个array对象；而对于数组，必须逐元素复制数据。</strong></p><p>​<strong>vector和array对象可以禁止数组的越界行为，通过使用成员函数at()的方法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a2.<span class="built_in">at</span>(<span class="number">1</span>) = <span class="number">2.3</span>;</span><br></pre></td></tr></table></figure><p>​<strong>中括号表示法和成员函数at()的差别在于，使用at()时，将在运行期间捕获非法索引，而程序默认将中断。这种额外检查的代价是运行时间更长，这就是C++让允许您使用任何一种表示法的原因所在。</strong></p><p>​另外，这些类还能够降低意外超界错误的概率。例如，它们包含成员函数begin()和end()，能够确定边界，以免无意间超界，这将在第16章讨论。</p><h2 id="第5章-循环和关系表"><a href="#第5章-循环和关系表" class="headerlink" title="第5章 循环和关系表"></a>第5章 循环和关系表</h2><h3 id="延时循环"><a href="#延时循环" class="headerlink" title="延时循环"></a>延时循环</h3><p>​<strong>ANSI C和C++库中有一个函数可以让系统时钟来完成延时的工作。这个函数名为clock( )，返回程序开始执行后所用的系统时间。</strong></p><p>​这有两个复杂的问题：首先，clock( )返回时间的单位不一定是秒；其次，该函数的返回类型在某些系统上可能是long，在另一些系统上可能是unsigned long或其他类型。</p><p>​<strong>头文件ctime（较早的实现中为time.h）提供了这些问题的解决方案。</strong></p><p>​<strong>首先，它定义了一个符号常量—CLOCKS_PER_SEC，该常量等于每秒钟包含的系统时间单位数。</strong> <strong>因此，将系统时间除以这个值，可以得到秒数。或者将秒数乘以CLOCK_PER_SEC，可以得到以系统时间单位为单位的时间。</strong></p><p>​<strong>其次，ctime将clock_t作为clock( )返回类型的别名，这意味着可以将变量声明为clock_t类型，编译器将把它转换为long、unsigned int或适合系统的其他类型。</strong></p><p>​下面是一个示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the delay time, in seconds: &quot;</span>;</span><br><span class="line">    <span class="type">float</span> secs;</span><br><span class="line">    cin &gt;&gt; secs;</span><br><span class="line">    <span class="type">clock_t</span> delay = secs * CLOCKS_PER_SEC;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;starting\a\n&quot;</span>;</span><br><span class="line">    <span class="type">clock_t</span> start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">clock</span>() - start &lt; delay)</span><br><span class="line">        ;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;done \a\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​该程序以系统时间单位为单位（而不是以秒为单位）计算延迟时 间，避免了在每轮循环中将系统时间转换为秒。</p><h3 id="基于范围的for循环（C-11）"><a href="#基于范围的for循环（C-11）" class="headerlink" title="基于范围的for循环（C++11）"></a>基于范围的for循环（C++11）</h3><p>​<strong>C++11新增了一种循环：基于范围（range-based）的for循环。</strong>这简化了一种常见的循环任务：对数组（或容器类，如vector和array）的每个元素执行相同的操作，如下例所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> prices[<span class="number">5</span>] = &#123;<span class="number">4.99</span>, <span class="number">10.99</span>, <span class="number">6.87</span>, <span class="number">7.99</span>, <span class="number">8.49</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">double</span> x : prices)</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>​其中，x最初表示数组prices的第一个元素。显示第一个元素后，不断执行循环，而x依次表示数组的其他元素。因此，上述代码显示全部5个元素，每个元素占据一行。总之，该循环显示数组中的每个值。 </p><p>​<strong>要修改数组的元素，需要使用不同的循环变量语法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">double</span> &amp;x : prices)</span><br><span class="line">    x = x * <span class="number">0.80</span><span class="comment">// 20% off sale</span></span><br></pre></td></tr></table></figure><p>​符号&amp;表明x是一个引用变量，这个主题将在第8章讨论。就这里而言，这种声明让接下来的代码能够修改数组的内容，而第一种语法不能。 </p><p>​<strong>还可结合使用基于范围的for循环和初始化列表：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x : &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">6</span>&#125;)</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><p>​然而，这种循环主要用于第16章将讨论的各种模板容器类。</p><h3 id="循环和文本输入"><a href="#循环和文本输入" class="headerlink" title="循环和文本输入"></a>循环和文本输入</h3><h4 id="使用原始的cin进行输入"><a href="#使用原始的cin进行输入" class="headerlink" title="使用原始的cin进行输入"></a>使用原始的cin进行输入</h4><p>​如果程序要使用循环来读取来自键盘的文本输入，则必须有办法知道何时停止读取。如何知道这一点呢？<strong>一种方法是选择某个特殊字符—有时被称为哨兵字符（sentinel character），将其作为停止标记。</strong>下面是一个案例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter characters; enter # to quit:\n&quot;</span>;</span><br><span class="line">    cin &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">        ++count;</span><br><span class="line">        cin &gt;&gt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; count &lt;&lt; <span class="string">&quot; characters read\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enter characters; enter # to quit:</span></span><br><span class="line"><span class="comment">// see ken run#really fast</span></span><br><span class="line"><span class="comment">// seekenrun</span></span><br><span class="line"><span class="comment">// 9 characters read</span></span><br></pre></td></tr></table></figure><p>​<strong>注意，这种做法在输出时省略了空格，原因在cin。读取char值时，与读取其他基本类型一样，cin将忽略空格和换行符。</strong>因此输入中的空格没有被回显，也没有被包括在计数内。 </p><p>​<strong>更为复杂的是，发送给cin的输入被缓冲。这意味着只有在用户按下回车键后，他输入的内容才会被发送给程序。</strong>这就是在运行该程序时，可以在#后面输入字符的原因。按下回车键后，整个字符序列将被发送给程序，但程序在遇到#字符后将结束对输入的处理。 </p><h4 id="使用cin-get-char-进行补救"><a href="#使用cin-get-char-进行补救" class="headerlink" title="使用cin.get(char)进行补救"></a>使用cin.get(char)进行补救</h4><p>​<strong>通常，逐个字符读取输入的程序需要检查每个字符，包括空格、制表符和换行符。cin所属的istream类（在iostream中定义）中包含一个能够满足这种要求的成员函数。具体地说，成员函数cin.get(ch)读取输入中的下一个字符（即使它是空格），并将其赋给变量ch。</strong>使用这个函数调用替换cin&gt;&gt;ch，可以修补上述程序的问题。</p><h4 id="使用哪个cin-get"><a href="#使用哪个cin-get" class="headerlink" title="使用哪个cin.get()"></a>使用哪个cin.get()</h4><p>​在第4章时，有过这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[ArSize];</span><br><span class="line">……</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Enter your name:\n&quot;</span>;</span><br><span class="line">cin.<span class="built_in">get</span>(name, ArSize).<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure><p>​其中最后一行相当于两个连续的调用函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>(name, ArSize);</span><br><span class="line">cin.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure><p>​cin.get( )的一个版本接受两个参数：数组名（字符串（char*类型） 的地址）和ArSize（int类型的整数）。接下来，程序使用了不接受任何参数的cin.get( )。而最近，我们这样使用过cin.get( )： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line">cin.<span class="built_in">get</span>(ch);</span><br></pre></td></tr></table></figure><h4 id="文件尾条件"><a href="#文件尾条件" class="headerlink" title="文件尾条件"></a>文件尾条件</h4><p>​上述程序表明，使用诸如#等符号来表示输入结束很难令人满意，因为这样的符号可能就是合法输入的组成部分，其他符号（如@和%）也如此。如果输入来自于文件，则可以使用一种功能更强大的技术—检测文件尾（EOF）。<strong>C++输入工具和操作系统协同工作，来检测文件尾并将这种信息告知程序。</strong> </p><p>​<strong>很多操作系统都允许通过键盘来模拟文件尾条件。在Unix中，可以在行首按下Ctrl+D来实现；在Windows命令提示符模式下，可以在任意位置按Ctrl+Z和Enter</strong>。有些C++实现支持类似的行为，即使底层操作系统并不支持。键盘输入的EOF概念实际上是命令行环境遗留下来的。</p><p>​<strong>检测到EOF后，cin将两位（eofbit和failbit）都设置为1。可以通过成员函数eof( )来查看eofbit是否被设置；如果检测到EOF，则cin.eof( )将 返回bool值true，否则返回false。同样，如果eofbit或failbit被设置为1，则fail( )成员函数返回true，否则返回false。</strong></p><p>​<strong>注意，eof( )和fail( )方法报告最近读取的结果；也就是说，它们在事后报告，而不是预先报告。因此应将cin.eof( )或cin.fail( )测试放在读取后</strong>，下面程序的设计体现了这一点。它使用的是fail( )，而不是eof( )，因为前者可用于更多的实现中。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter characters; enter # to quit:\n&quot;</span>;</span><br><span class="line">    cin.<span class="built_in">get</span>(ch);</span><br><span class="line">    <span class="keyword">while</span> (cin.<span class="built_in">fail</span>() == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">        ++count;</span><br><span class="line">        cin.<span class="built_in">get</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; count &lt;&lt; <span class="string">&quot; characters read\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enter characters; enter # to quit:</span></span><br><span class="line"><span class="comment">// The green bird sings in the winter.</span></span><br><span class="line"><span class="comment">// The green bird sings in the winter.</span></span><br><span class="line"><span class="comment">// Yes, but the crow flies in the dawn.</span></span><br><span class="line"><span class="comment">// Yes, but the crow flies in the dawn.</span></span><br><span class="line"><span class="comment">// &lt;CTRL&gt; + &lt;Z&gt; + &lt;ENTER&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 73 characters read</span></span><br></pre></td></tr></table></figure><ol><li><p><strong>EOF结束输入</strong><br> 前面指出过，cin方法检测到EOF时，将设置cin对象中一个指示EOF条件的标记。设置这个标记后，cin将不读取输入，再次调用cin也不管用。对于文件输入，这是有道理的，因为程序不应读取超出文件尾的内容。然而，对于键盘输入，有可能使用模拟EOF来结束循环，但稍后要读取其他输入。<strong>cin.clear( )方法可能清除EOF标记，使输入继续进行。</strong>这将在第17章详细介绍。<br>    <strong>不过要记住的是，在有些系统中，按Ctrl+Z实际上将结束输入和输出，而cin.clear( )将无法恢复输入和输出。</strong> </p></li><li><p><strong>常见的字符输入法</strong><br> 每次读取一个字符，直到遇到EOF的输入循环的基本设计如下：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (cin.<span class="built_in">get</span>(ch))</span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> ​<strong>方法cin.get(char)的返回值是一个cin对象。</strong>然而，istream类提供了一个可以将istream对象（如cin）转换为bool值的函数；<strong>当cin出现在需要bool值的地方（如在while循环的测试条件中）时，该转换函数将被调用。</strong>另外，如果最后一次读取成功了，则转换得到的bool值为true；否则为false。<strong>最后，由于cin.get(char)的返回值为cin，因此可以将循环精简成上述这种格式。</strong></p><p> ​这样，cin.get(char)只被调用一次，而不是两次：循环前一次、循环结束后一次。为判断循环测试条件，程序必须首先调用cin.get(ch)。如果成功，则将值放入ch中。然后，程序获得函数调用的返回值，即cin。接下来，程序对cin进行bool转换，如果输入成功，则结果为true，否则为false。<strong>三条指导原则（确定结束条件、对条件进行初始化以及更新条件）全部被放在循环测试条件中。</strong></p></li></ol><h4 id="另一个版本的cin-get"><a href="#另一个版本的cin-get" class="headerlink" title="另一个版本的cin.get()"></a>另一个版本的cin.get()</h4><p>​<strong>不接受任何参数的cin.get( )成员函数返回输入中的下一个字符。</strong>也就是说，可以这样使用它：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch = cin.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure><p>​<strong>该函数的工作方式与C语言中的getchar()相似，将字符编码作为int值返回；而cin.get(ch)返回一个对象，而不是读取的字符。</strong>同样，可以使用cout.put( )函数（参见第3章）来显示字符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">put</span>(ch);</span><br></pre></td></tr></table></figure><p>​<strong>该函数的工作方式类似C语言中的putchar( )，只不过其参数类型为char，而不是int。</strong></p><p>​最初，put( )成员只有一个原型—put(char)。可以传递一个int参数给它，该参数将被强制转换为char。C++标准还要求只有一个原型。然而，有些C++实现都提供了3个原型：put(char)、 put(signed char)和put(unsigned char)。在这些实现中，给put( )传递一个int参数将导致错误消息，因为转换int的方式不止一种。使<strong>用显式强制类型转换的原型（如cin.put(char(ch))）可使用int参数。</strong>  </p><p>​<strong>为成功地使用cin.get( )，需要知道其如何处理EOF条件。当该函数到达EOF时，将没有可返回的字符。相反，cin.get( )将返回一个用符号常量EOF表示的特殊值。</strong>该常量是在头文件iostream中定义的。EOF值必须不同于任何有效的字符值，以便程序不会将EOF与常规字符混淆。<strong>通常，EOF被定义为值−1，因为没有ASCII码为−1的字符，但并不需要知道实际的值，而只需在程序中使用EOF即可。</strong></p><p>​案例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    ch = cin.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        cout.<span class="built_in">put</span>(ch); </span><br><span class="line">        ++count;</span><br><span class="line">        ch = cin.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; count &lt;&lt; <span class="string">&quot; characters read\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>关于使用cin.get( )还有一个微妙而重要的问题。由于EOF表示的不是有效字符编码，因此可能不与char类型兼容。</strong>例如，在有些系统中，char类型是没有符号的，因此char变量不可 能为EOF值（−1）。由于这种原因，如果使用cin.get( )（没有参数）并测试EOF，则必须将返回值赋给int变量，而不是char变量。<strong>另外，如果将ch的类型声明为int，而不是char，则必须在显示ch时将其强制转换为char类型。</strong></p><p>​以下是一个优化版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((ch = cin.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        cout.<span class="built_in">put</span>(<span class="built_in">char</span>(ch));</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; count &lt;&lt; <span class="string">&quot; characters read\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这里分析一下<code>while ((ch = cin.get()) != EOF)</code>：</p><p>​子表达式ch&#x3D;cin.get( )两端的括号导致程序首先计算该表达式。为此，程序必须首先调用cin.get( )函数，然后将该函数的返回值赋给ch。由于赋值语句的值为左操作数的值，因此整个子表达式变为ch的值。如果这个值是EOF，则循环将结束，否则继续。</p><h4 id="cin-get-与cin-get-char-的区别"><a href="#cin-get-与cin-get-char-的区别" class="headerlink" title="cin.get( )与cin.get(char)的区别"></a>cin.get( )与cin.get(char)的区别</h4><p>​<strong>使用cin.get(ch)（有一个参数）进行输入时，将不会导致任何类型方面的问题。前面讲过，cin.get(char)函数在到达EOF时，不 会将一个特殊值赋给ch。事实上，在这种情况下，它不会将任何值赋给ch。ch不会被用来存储非char值。下表总结了cin.get(char)和cin.get()之间的差别。</strong></p><table><thead><tr><th align="center">属性</th><th align="left">cin.get(ch)</th><th align="left">ch &#x3D; cin.get()</th></tr></thead><tbody><tr><td align="center">传递输入字符的方式</td><td align="left">赋给参数ch</td><td align="left">将函数返回值赋给ch</td></tr><tr><td align="center">用于字符输入时函数的返回值</td><td align="left">istream对象（执行bool转换后为true)</td><td align="left">int类型的字符编码</td></tr><tr><td align="center">到达EOF时函数的返回值</td><td align="left">istream对象（执行bool转换后为false)</td><td align="left">EOF</td></tr></tbody></table><p>​<strong>那么应使用cin.get( )还是cin.get(char)呢？使用字符参数的版本更符合对象方式，因为其返回值是istream对象。这意味着可以将它们拼接起来。</strong></p><p>​例如，下面的代码将输入中的下一个字符读入到ch1中，并将接下来的一个字符读入到ch2中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>(ch1).<span class="built_in">get</span>(ch2);</span><br></pre></td></tr></table></figure><p>​这是可行的，因为函数调用cin.get(ch1)返回一个cin对象，然后便可以通过该对象调用get(ch2)。</p><p>​<strong>get( )的主要用途是能够将stdio.h的getchar( )和putchar( )函数转换为iostream的cin.get( )和cout.put( )方法。</strong>只要用头文件iostream替换stdio.h，并用作用相似的方法替换所有的getchar( )和putchar( )即可。（<strong>如果旧的代码使用int变量进行输入，而所用的实现包含put( )的多个原型，则必须做进一步的调整。</strong>）</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>​<strong>许多程序都逐字节地读取文本输入或文本文件，istream类提供了多种可完成这种工作的方法。如果ch是一个char变量，则下面的语句将输入中的下一个字符读入到ch中：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; ch;</span><br></pre></td></tr></table></figure><p>​<strong>然而，它将忽略空格、换行符和制表符。</strong></p><p>​<strong>下面的成员函数调用读取输入中的下一个字符（而不管该字符是什么）并将其存储到ch中：</strong> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>(ch);</span><br></pre></td></tr></table></figure><p>​<strong>成员函数调用cin.get( )返回下一个输入字符—包括空格、换行符和制表符，因此，可以这样使用它：</strong> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch = cin.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure><p>​<strong>cin.get（char）成员函数调用通过返回转换为false的bool值来指出已到达EOF，而cin.get( )成员函数调用则通过返回EOF值来指出已到达EOF，EOF是在文件iostream中定义的。</strong> </p><h2 id="第6章-分支语句和逻辑运算符"><a href="#第6章-分支语句和逻辑运算符" class="headerlink" title="第6章 分支语句和逻辑运算符"></a>第6章 分支语句和逻辑运算符</h2><h3 id="字符数组库cctype"><a href="#字符数组库cctype" class="headerlink" title="字符数组库cctype"></a>字符数组库cctype</h3><p>​C++从C语言继承了一个与字符相关的、非常方便的函数软件包，它可以简化诸如确定字符是否为大写字母、数字、标点符号等工作，这些函数的原型是在头文件cctype（老式的风格中为ctype.h）中定义的。</p><p>​<strong>例如，如果ch是一个字母，则isalpha（ch）函数返回一个非零值，否则返回0。同样，如果ch是标点符号（如逗号或句号），函数ispunct（ch）将返回true。</strong>（这些函数的返回类型为int，而不是bool，但通常bool转换能够将它们视为bool类型。） </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>) || (ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span>))</span><br><span class="line">    </span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isalpha</span>(ch))</span><br></pre></td></tr></table></figure><p>​isalpha( )不仅更容易使用，而且更通用。AND&#x2F;OR格式假设A-Z的字符编码是连续的，其他字符的编码不在这个范围内。这种假设对于ASCII码来说是成立的，但通常并非总是如此。 </p><p>​下述程序演示了一些cctype库函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter text for anlysis, and type @&quot;</span></span><br><span class="line">            <span class="string">&quot; to terminate input.\n&quot;</span>;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> whitespace = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> digits = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> chars = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> punct = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> others = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cin.<span class="built_in">get</span>(ch);</span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(ch))</span><br><span class="line">            chars++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isspace</span>(ch))</span><br><span class="line">            whitespace++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(ch))</span><br><span class="line">            digits++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">ispunct</span>(ch))</span><br><span class="line">            punct++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            others++;</span><br><span class="line">        cin.<span class="built_in">get</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; chars &lt;&lt; <span class="string">&quot; letters, &quot;</span></span><br><span class="line">         &lt;&lt; whitespace &lt;&lt; <span class="string">&quot; whitespace, &quot;</span></span><br><span class="line">         &lt;&lt; digits &lt;&lt; <span class="string">&quot; digits, &quot;</span></span><br><span class="line">         &lt;&lt; punct &lt;&lt; <span class="string">&quot; punctuations, &quot;</span></span><br><span class="line">         &lt;&lt; others &lt;&lt; <span class="string">&quot; others.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enter text for anlysis, and type @ to terminate input.</span></span><br><span class="line"><span class="comment">// AdrenalVision International producer Adrienne Vismonger</span></span><br><span class="line"><span class="comment">// announced production of their new 3-D film, a remake of</span></span><br><span class="line"><span class="comment">// &quot;My Dinner with Andre,&quot; scheduled for 2013. &quot;Wait until</span></span><br><span class="line"><span class="comment">// you see the the new scene with an enraged Collossipede!&quot;@</span></span><br><span class="line"><span class="comment">// 177 letters, 33 whitespace, 5 digits, 9 punctuations, 0 others.</span></span><br></pre></td></tr></table></figure><p>​该程序使用isalpha( )来检查字符是否为字母字符，使用isdigits( )来测试字符是否为数字字符，如 3，使用isspace( )来测试字符是否为空白，如换行符、空格和制表符，使用ispunct( )来测试字符是否为标点符号。<strong>注意，空白字符计数中包括换行符。</strong></p><p>​下表对cctype软件包中的函数进行了总结。</p><table><thead><tr><th align="left">函数名称</th><th>返回值</th></tr></thead><tbody><tr><td align="left">isalnum()</td><td>如果参数是字母数字，即字母或数字，该函数返回true</td></tr><tr><td align="left">isalpha()</td><td>如果参数是字母，该函数返回true</td></tr><tr><td align="left">iscntrl()</td><td>如果参数是控制字符，该函数返回true</td></tr><tr><td align="left">isdigit()</td><td>如果参数是数字（0～9），该函数返回true</td></tr><tr><td align="left">isgraph()</td><td>如果参数是除空格之外的打印字符，该函数返回true</td></tr><tr><td align="left">islower()</td><td>如果参数是小写字母，该函数返回true</td></tr><tr><td align="left">isprint()</td><td>如果参数是打印字符（包括空格），该函数返回true</td></tr><tr><td align="left">ispunct()</td><td>如果参数是标点符号，该函数返回true</td></tr><tr><td align="left">isspace()</td><td>如果参数是标准空白字符，如空格、进纸、换行符、回车、水平制表符或 者垂直制表符，该函数返回true</td></tr><tr><td align="left">isupper()</td><td>如果参数是大写字母，该函数返回true</td></tr><tr><td align="left">isxdigit()</td><td>如果参数是十六进制数字，即0～9、a～f或A～F，该函数返回true</td></tr><tr><td align="left">tolower()</td><td>如果参数是大写字符，则返回其小写，否则返回该参数</td></tr><tr><td align="left">toupper()</td><td>如果参数是小写字符，则返回其大写，否则返回该参数</td></tr></tbody></table><h3 id="读取数字的循环"><a href="#读取数字的循环" class="headerlink" title="读取数字的循环"></a>读取数字的循环</h3><p>​假设要编写一个将一系列数字读入到数组中的程序，并允许用户在 数组填满之前结束输入。一种方法是利用cin。请看下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br></pre></td></tr></table></figure><p>​如果用户输入一个单词，而不是一个数字，情况将如何呢？发生这种类型不匹配的情况时，将发生4种情况： </p><ul><li>n的值保持不变； </li><li>不匹配的输入将被留在输入队列中； </li><li>cin对象中的一个错误标记被设置； </li><li>对cin方法的调用将返回false（如果被转换为bool类型）。</li></ul><p>​<strong>方法返回false意味着可以用非数字输入来结束读取数字的循环。非数字输入设置错误标记意味着必须重置该标记，程序才能继续读取输入。clear( )方法重置错误输入标记，同时也重置文件尾（EOF条件，参见第5章）。输入错误和EOF都将导致cin返回false，第17章将讨论如何区分这两种情况。</strong></p><p>​下面来看两个演示这些技术的示例。</p><p>​假设要编写一个程序，来计算平均每天捕获的鱼的重量。这里假设每天最多捕获5条鱼，因此一个包含5个元素的数组将足以存储所有的数据，但也可能没有捕获这么多鱼。在下述程序中，如果数组被填满或者输入了非数字输入，循环将结束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Max = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> fish[Max];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please enter the weights of your fish.\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You may enter up to &quot;</span> &lt;&lt; Max</span><br><span class="line">         &lt;&lt; <span class="string">&quot; fish &lt;q to terminate&gt;/\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; fish #1: &quot;</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; Max &amp;&amp; cin &gt;&gt; fish[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (++i &lt; Max)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; fish #&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> total = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">        total += fish[j];</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No fish\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; total / i &lt;&lt; <span class="string">&quot; = average weight of &quot;</span></span><br><span class="line">             &lt;&lt; i &lt;&lt; <span class="string">&quot; fish\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Done.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Please enter the weights of your fish.</span></span><br><span class="line"><span class="comment">// You may enter up to 5 fish &lt;q to terminate&gt;/</span></span><br><span class="line"><span class="comment">//  fish #1: 30</span></span><br><span class="line"><span class="comment">//  fish #2: 35</span></span><br><span class="line"><span class="comment">//  fish #3: 25</span></span><br><span class="line"><span class="comment">//  fish #4: 40</span></span><br><span class="line"><span class="comment">//  fish #5: q</span></span><br><span class="line"><span class="comment">// 32.5 = average weight of 4 fish</span></span><br><span class="line"><span class="comment">// Done.</span></span><br></pre></td></tr></table></figure><p>​请注意下面的代码行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; Max &amp;&amp; cin &gt;&gt; fish[i])</span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>如果逻辑AND表达式的左侧为false，则C++将不会判断右侧的表达式。在这里，对右侧的表达式进行判定意味着用cin将输入放到数组中。如果i等于Max，则循环将结束，而不会将一个值读入到数组后面的位置中。</strong></p><p>​当用户输入的不是数字时，该程序将不再读取输入。下面来看一个继续读取的例子。</p><p>​假设程序要求用户提供5个高尔夫得分，以计算平均成绩。如果用户输入非数字输入，程序将拒绝，并要求用户继续输入数字。</p><p>​<strong>可以看到，可以使用cin输入表达式的值来检测输入是不是数字。程序发现用户输入了错误内容时，应采取3个步骤。</strong> </p><ol><li><p><strong>重置cin以接受新的输入。</strong> </p></li><li><p><strong>删除错误输入。</strong> </p></li><li><p><strong>提示用户再输入。</strong></p></li></ol><p>​<strong>请注意，程序必须先重置cin，然后才能删除错误输入。</strong>下述程序演示了如何完成这些工作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Max = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> golf[Max];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please enter the your golf scores.\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You must enter &quot;</span> &lt;&lt; Max &lt;&lt; <span class="string">&quot; rounds.\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Max; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;round #&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!(cin &gt;&gt; golf[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            cin.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">while</span> (cin.<span class="built_in">get</span>() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Please enter a number: &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> total = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Max; i++)</span><br><span class="line">        total += golf[i];</span><br><span class="line">    cout &lt;&lt; total / Max &lt;&lt; <span class="string">&quot; = average score &quot;</span></span><br><span class="line">         &lt;&lt; Max &lt;&lt; <span class="string">&quot; rounds\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Please enter the your golf scores.</span></span><br><span class="line"><span class="comment">// You must enter 5 rounds.</span></span><br><span class="line"><span class="comment">// round #1: 88</span></span><br><span class="line"><span class="comment">// round #2: 87</span></span><br><span class="line"><span class="comment">// round #3: must i?</span></span><br><span class="line"><span class="comment">// Please enter a number: 103</span></span><br><span class="line"><span class="comment">// round #4: 94</span></span><br><span class="line"><span class="comment">// round #5: 86</span></span><br><span class="line"><span class="comment">// 91.6 = average score 5 rounds</span></span><br></pre></td></tr></table></figure><p>​错误处理代码的关键部分如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!(cin &gt;&gt; golf[i]))</span><br><span class="line">&#123;</span><br><span class="line">    cin.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">while</span> (cin.<span class="built_in">get</span>() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please enter a number: &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​如果用户输入88，则cin表达式将为true，因此将一个值放到数组中；而表达式!(cin &gt;&gt; golf [i])为false，因此结束内部循环。然而，如果用户输入must i?，则cin表达式将为false，因此不会将任何值放到数组中；而表达式!(cin &gt;&gt; golf [i])将为true，因此进入内部的while循环。</p><p>​该循环的第一条语句使用clear( )方法重置输入，如果省略这条语句，程序将拒绝继续读取输入。接下来，程序在while循环中使用cin.get( )来读取行尾之前的所有输入，从而删除这一行中的错误输入。另一种方法是读取到下一个空白字符，这样将每次删除一个单词，而不是一次删除整行。最后，程序告诉用户，应输入一个数字。</p><h3 id="简单文件输入-x2F-输出"><a href="#简单文件输入-x2F-输出" class="headerlink" title="简单文件输入&#x2F;输出"></a>简单文件输入&#x2F;输出</h3><p>​C++使得将读取键盘输入和在屏幕上显示输出（统称为控制台输入&#x2F;输出）的技巧用于文件输入&#x2F;输出（文件I&#x2F;O）非常简单。第17章将更详细地讨论这些主题，这里只介绍简单的文本文件I&#x2F;O。 </p><h4 id="文本I-x2F-O和文本文件"><a href="#文本I-x2F-O和文本文件" class="headerlink" title="文本I&#x2F;O和文本文件"></a>文本I&#x2F;O和文本文件</h4><p>​文本I&#x2F;O的概念为，使用cin进行输入时，程序将输入视为一系列的字节，其中每个字节都被解释为字符编码。不管目标数据类型是什么，输入一开始都是字符数据——文本数据。然后，cin对象负责将文本转换为其他类型。</p><p>​这里展示一下这个处理如何进行，看一下使用不同数据类型的变量来存储时，cin是如何处理该输入行的。假设有如下示例输出行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">38.5</span> <span class="number">19.2</span></span><br></pre></td></tr></table></figure><ol><li><p>char 类型</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line">cin &gt;&gt; ch;</span><br></pre></td></tr></table></figure><p> ​<strong>输入行中的第一个字符被赋给ch。</strong>在这里，第一个字符是数字3，其字符编码（二进制）被存储在变量ch中。输入和目标变量都是字符，因此不需要进行转换。注意，这里存储的数值3，而不是字符3的编码。执行上述输入语句后，输入队列中的下一个字符为字符8，下一个输入操作将对其进行处理。 </p></li><li><p>int 类型</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br></pre></td></tr></table></figure><p> ​<strong>在这种情况下，cin将不断读取，直到遇到非数字字符。</strong>也就是说，它将读取3和8，这样句点将成为输入队列中的下一个字符。cin通过计算发现，这两个字符对应数值38，因此将38的二进制编码复制到变量n中。</p></li><li><p>double 类型</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br></pre></td></tr></table></figure><p> ​<strong>在这种情况下，cin将不断读取，直到遇到第一个不属于浮点数的字符。</strong>也就是说，cin读取3、8、句点和5，使得空格成为输入队列中的下一个字符。cin通过计算发现，这四个字符对应于数值38.5，因此将38.5的二进制编码（浮点格式）复制到变量x中。</p></li><li><p>char[] 类型</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> word[<span class="number">50</span>];</span><br><span class="line">cin &gt;&gt; word;</span><br></pre></td></tr></table></figure><p> ​<strong>在这种情况下，cin将不断读取，直到遇到空白字符。</strong>也就是说，它读取3、8、句点和5，使得空格成为输入队列中的下一个字符。然后，cin将这4个字符的字符编码存储到数组word中，并在末尾加上一个空字符。这里不需要进行任何转换。 </p></li><li><p>另一种char[] 类型</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> word[<span class="number">50</span>];</span><br><span class="line">cin.<span class="built_in">geline</span>(word, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p> ​<strong>在这种情况下，cin将不断读取，直到遇到换行符（示例输入行少于50个字符）。</strong>所有字符都将被存储到数组word中，并在末尾加上一个空字符。换行符被丢弃，输入队列中的下一个字符是下一行中的第一个字符。这里不需要进行任何转换。</p></li></ol><p>​<strong>对于输入，将执行相反的转换。即整数被转换为数字字符序列，浮点数被转换为数字字符和其他字符组成的字符序列（如284.53或−1.58E+06）。字符数据不需要做任何转换。</strong> </p><p>​这里的要点是，输入一开始为文本。因此，控制台输入的文件版本是文本文件，即每个字节都存储了一个字符编码的文件。并非所有的文件都是文本文件，例如，数据库和电子表格以数值格式（即二进制整数或浮点格式）来存储数值数据。</p><p>​本章讨论的文件I&#x2F;O相当于控制台I&#x2F;O，因此仅适用于文本文件。要创建文本文件，用于提供输入，可使用文本编译器，如DOS中的EDIT、Windows中的“记事本”和UNIX&#x2F;Linux系统中的vi或emacs。也可以使用字处理程序来创建，但必须将文件保存为文本格式。IDE中的源代码编辑器生成的也是文本文件，<strong>事实上，源代码文件就属于文本文件。同样，可以使用文本编辑器来查看通过文本输出创建的文件。</strong></p><h4 id="写入到文本文件"><a href="#写入到文本文件" class="headerlink" title="写入到文本文件"></a>写入到文本文件</h4><p>​对于文件输入，C++使用类似于cout的东西。下面复习一些有关将cout用于控制台输出的基本事实，为文件输出做准备。</p><ul><li>必须包含头文件iostream。 </li><li>头文件iostream定义了一个用处理输出的ostream类。 </li><li>头文件iostream声明了一个名为cout的ostream变量（对象）。 </li><li>必须指明名称空间std；例如，为引用元素cout和endl，必须使用编译指令using或前缀std::。</li><li>可以结合使用cout和运算符&lt;&lt;来显示各种类型的数据。</li></ul><p>​<strong>文件输出与此相似。</strong></p><ul><li>必须包含头文件fstream。 </li><li>头文件fstream定义了一个用于处理输出的ofstream类。 </li><li>需要声明一个或多个ofstream变量（对象），并以自己喜欢的方式对其进行命名，条件是遵守常用的命名规则。 </li><li>必须指明名称空间std；例如，为引用元素ofstream，必须使用编译指令using或前缀std::。 </li><li>需要将ofstream对象与文件关联起来。为此，方法之一是使用open( )方法。 </li><li>使用完文件后，应使用方法close( )将其关闭。 </li><li>可结合使用ofstream对象和运算符&lt;&lt;来输出各种类型的数据。</li></ul><p>​<strong>注意，虽然头文件iostream提供了一个预先定义好的名为cout的ostream对象，但用户必须声明自己的ofstream对象，为其命名，并将其同文件关联起来。</strong></p><p>​下面演示了如何声明这种对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ofstream outFile;</span><br><span class="line">ofstream fout;</span><br></pre></td></tr></table></figure><p>​下面演示了如何将这种对象与特定的文件关联起来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">outFile.<span class="built_in">open</span>(<span class="string">&quot;fish.txt&quot;</span>);<span class="comment">// outFile used to write to the fish.txt file</span></span><br><span class="line"><span class="type">char</span> filename[<span class="number">50</span>];</span><br><span class="line">cin &gt;&gt; filename;<span class="comment">// user specifies a name</span></span><br><span class="line">fout.<span class="built_in">open</span>(filename);<span class="comment">// fout used to read specified file</span></span><br></pre></td></tr></table></figure><p>​<strong>注意，方法open( )接受一个C-风格字符串作为参数，这可以是一个字面字符串，也可以是存储在数组中的字符串。</strong> </p><p>​下面演示了如何使用这种对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> wt = <span class="number">125.8</span>;</span><br><span class="line">outFile &lt;&lt; wt;<span class="comment">// write a number to fish.txt</span></span><br><span class="line"><span class="type">char</span> line[<span class="number">81</span>] = <span class="string">&quot;Objects are closer than they appear.&quot;</span>;</span><br><span class="line">fout &lt;&lt; line &lt;&lt; endl;<span class="comment">// write a line of text</span></span><br></pre></td></tr></table></figure><p>​<strong>重要的是，声明一个ofstream对象并将其同文件关联起来后，便可以像使用cout那样使用它。所有可用于cout的操作和方法（如&lt;&lt;、endl和setf( )）都可用于ofstream对象（如前述示例中的outFile和fout）。</strong> </p><p>​总之，使用文件输出的主要步骤如下：</p><ol><li><p>包含头文件fstream。 </p></li><li><p>创建一个ofstream对象。 </p></li><li><p>将该ofstream对象同一个文件关联起来。 </p></li><li><p>就像使用cout那样使用该ofstream对象。</p></li></ol><p>​下述程序演示了这种方法。它要求用户输入信息，然后将信息显示到屏幕上，再将这些信息写入到文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> automobile[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">double</span> a_price;</span><br><span class="line">    <span class="type">double</span> d_price;</span><br><span class="line"></span><br><span class="line">    ofstream outFile;</span><br><span class="line">    outFile.<span class="built_in">open</span>(<span class="string">&quot;carinfo.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the make and model of automobile: &quot;</span>;</span><br><span class="line">    cin.<span class="built_in">getline</span>(automobile, <span class="number">50</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the model year: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; year;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the original asking price: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; a_price;</span><br><span class="line">    d_price = <span class="number">0.913</span> * a_price;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; fixed;</span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br><span class="line">    cout.<span class="built_in">setf</span>(ios_base::showpoint);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Make and model: &quot;</span> &lt;&lt; automobile &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Year: &quot;</span> &lt;&lt; year &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Was asking $&quot;</span> &lt;&lt; a_price &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Now asking $&quot;</span> &lt;&lt; d_price &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    outFile &lt;&lt; fixed;</span><br><span class="line">    outFile.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br><span class="line">    outFile.<span class="built_in">setf</span>(ios_base::showpoint);</span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;Make and model: &quot;</span> &lt;&lt; automobile &lt;&lt; endl;</span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;Year: &quot;</span> &lt;&lt; year &lt;&lt; endl;</span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;Was asking $&quot;</span> &lt;&lt; a_price &lt;&lt; endl;</span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;Now asking $&quot;</span> &lt;&lt; d_price &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    outFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enter the make and model of automobile: Flitz Perky</span></span><br><span class="line"><span class="comment">// Enter the model year: 2009</span></span><br><span class="line"><span class="comment">// Enter the original asking price: 13500</span></span><br><span class="line"><span class="comment">// Make and model: Flitz Perky</span></span><br><span class="line"><span class="comment">// Year: 2009</span></span><br><span class="line"><span class="comment">// Was asking $13500.00</span></span><br><span class="line"><span class="comment">// Now asking $12325.50</span></span><br></pre></td></tr></table></figure><p>​该程序的最后一部分与cout部分相同，只是将cout替换为outFile而已。</p><p>​屏幕输出是使用cout的结果。如果查看该程序的可执行文件所在的目录，将看到一个名为carinfo.txt的新文件（根据编译器的配置，该文件也可能位于其他文件夹），其中包含使用outFile生成的输出。如果使用文本编辑器打开该文件，将发现其内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Make <span class="keyword">and</span> model: Flitz Perky</span><br><span class="line">Year: <span class="number">2009</span></span><br><span class="line">Was asking $<span class="number">13500.00</span></span><br><span class="line">Now asking $<span class="number">12325.50</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​outFile将cout显示到屏幕上的内容写入到了文件carinfo.txt中。</p><p>​下面是程序相关解析：</p><p>​在上述程序中，声明一个ofstream对象后，便可以使用方法open( )将该对象特定文件关联起来，并在程序使用完成后关闭该文件。<strong>注意，方法close( )不需要使用文件名作为参数，这是因为outFile已经同特定的文件关联起来。如果忘记关闭文件，程序正常终止时将自动关闭它。</strong></p><p>​<strong>outFile可使用cout可使用的任何方法。它不但能够使用运算符&lt;&lt;，还可以使用各种格式化方法，如setf( )和precision( )。这些方法只影响调用它们的对象。</strong></p><p>​<strong>最后对于open( )方法，在这里，该程序运行之前，文件carinfo.txt并不存在。在这种情况 下，方法open( )将新建一个名为carinfo.txt的文件。如果在此运行该程序，文件carinfo.txt将存在，默认情况下，open( )将首先截断该文件，即将其长度截短到零——丢其原有的内容，然后将新的输出加入到该文件中。</strong>第17章将介绍如何修改这种默认行为。 </p><p>​打开文件用于接受输入时可能失败。例如，指定的文件可能已经存在，但禁止对其进行访问。因此需要检查打开文件的操作是否成功。</p><h4 id="读取文本文件"><a href="#读取文本文件" class="headerlink" title="读取文本文件"></a>读取文本文件</h4><p>​文本文件输入，它是基于控制台输入的。控制台输入涉及多个方面，下面首先总结这些方面。</p><ul><li>必须包含头文件iostream。 </li><li>头文件iostream定义了一个用处理输入的istream类。 </li><li>头文件iostream声明了一个名为cin的istream变量（对象）。 </li><li>必须指明名称空间std；例如，为引用元素cin，必须使用编译指令using或前缀std::。 </li><li>可以结合使用cin和运算符&gt;&gt;来读取各种类型的数据。 </li><li>可以使用cin和get( )方法来读取一个字符，使用cin和getline( )来读取一行字符。 </li><li>可以结合使用cin和eof( )、fail( )方法来判断输入是否成功。 </li><li>对象cin本身被用作测试条件时，如果最后一个读取操作成功，它将被转换为布尔值true，否则被转换为false。</li></ul><p>​<strong>文件输出与此相似。</strong></p><ul><li>必须包含头文件fstream。 </li><li>头文件fstream定义了一个用于处理输入的ifstream类。 </li><li>需要声明一个或多个ifstream变量（对象），并以自己喜欢的方式对其进行命名，条件是遵守常用的命名规则。 </li><li>必须指明名称空间std；例如，为引用元素ifstream，必须使用编译指令using或前缀std::。 </li><li>需要将ifstream对象与文件关联起来，为此，方法之一是使用open( )方法。使用完文件后，应使用close( )方法将其关闭。 </li><li>可结合使用ifstream对象和运算符&gt;&gt;来读取各种类型的数据。 </li><li>可以使用ifstream对象和get( )方法来读取一个字符，使用ifstream对象和getline( )来读取一行字符。 </li><li>可以结合使用ifstream和eof( )、fail( )等方法来判断输入是否成功。 </li><li>ifstream对象本身被用作测试条件时，如果最后一个读取操作成功，它将被转换为布尔值true，否则被转换为false。</li></ul><p>​<strong>注意，虽然头文件iostream提供了一个预先定义好的名为cin的istream对象，但用户必须声明自己的ifstream对象，为其命名，并将其同文件关联起来。</strong></p><p>​下面演示了如何声明这种对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifstream inFile;</span><br><span class="line">ifstream fin;</span><br></pre></td></tr></table></figure><p>​下面演示了如何将这种对象与特定的文件关联起来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inFile.<span class="built_in">open</span>(<span class="string">&quot;bowling.txt&quot;</span>);</span><br><span class="line"><span class="type">char</span> filename[<span class="number">50</span>];</span><br><span class="line">cin &gt;&gt; filename;</span><br><span class="line">fin.<span class="built_in">open</span>(filename);</span><br></pre></td></tr></table></figure><p>​下面演示了如何使用这种对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> wt;</span><br><span class="line">inFile &gt;&gt; wt;</span><br><span class="line"><span class="type">char</span> line[<span class="number">81</span>];</span><br><span class="line">fin.<span class="built_in">getline</span>(line, <span class="number">81</span>);</span><br></pre></td></tr></table></figure><p>​<strong>声明一个ifstream对象并将其同文件关联起来后，便可以像使用cin那样使用它。所有可用于cin的操作和方法都可用于ifstream对象（如前述示例中的inFile和fin）。</strong> </p><p>​**如果试图打开一个不存在的文件用于输入，这种错误将导致后面使用ifstream对象进行输入时失败。检查文件是否被成功打开的首先方法是使用方法is_open( )**，为此，可以使用类似于下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inFile.<span class="built_in">open</span>(<span class="string">&quot;bowling.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!inFile.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​如果文件被成功地打开，方法is_open( )将返回true；因此如果文件没有被打开，表达式!inFile.isopen( )将为true。</p><p>​<strong>函数exit( )的原型是在头文件cstdlib中定义的，在该头文件中，还定义了一个用于同操作系统通信的参数值EXIT_FAILURE。函数exit( )终止程序。</strong></p><p>​<strong>方法is_open( )是C++中相对较新的内容。如果编译器不支持它，可使用较老的方法good( )来代替。第17章将讨论，方法good( )在检查可能存在的问题方面，没有is_open( )那么广泛。</strong> </p><p>​下述程序演示了这些操作。它要求打开用户指定的文件，读取其中的数字，然后指出文件中包含多少个值以及它们的和与平均值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> filename[SIZE];</span><br><span class="line">    ifstream inFile;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter name of data file: &quot;</span>;</span><br><span class="line">    cin.<span class="built_in">getline</span>(filename, SIZE);</span><br><span class="line">    inFile.<span class="built_in">open</span>(filename);</span><br><span class="line">    <span class="keyword">if</span> (!inFile.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Could not open the file &quot;</span> &lt;&lt; filename &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Program terminating.\n&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> value;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    inFile &gt;&gt; value;</span><br><span class="line">    <span class="keyword">while</span> (inFile.<span class="built_in">good</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        sum += value;</span><br><span class="line">        inFile &gt;&gt; value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inFile.<span class="built_in">eof</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;End of file reacher.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (inFile.<span class="built_in">fail</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Input terminated by data mismatch.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Input terminated for unknown reason.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No data processed.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Items read: &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Average: &quot;</span> &lt;&lt; sum / count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    inFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enter name of data file: scores.txt</span></span><br><span class="line"><span class="comment">// End of file reacher.</span></span><br><span class="line"><span class="comment">// Items read: 12</span></span><br><span class="line"><span class="comment">// Sum: 204.5</span></span><br><span class="line"><span class="comment">// Average: 17.0417</span></span><br></pre></td></tr></table></figure><p>​<strong>要运行上述程序，首先必须创建一个包含数字的文本文件。</strong>为此，可以使用文本编辑器（如用于编写源代码的文本编辑器）。假设该文件名为scores.txt，包含的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span> <span class="number">19</span> <span class="number">18.5</span> <span class="number">13.5</span> <span class="number">14</span></span><br><span class="line"><span class="number">16</span> <span class="number">19.5</span> <span class="number">20</span> <span class="number">18</span> <span class="number">12</span> <span class="number">18.5</span></span><br><span class="line"><span class="number">17.5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>程序还必须能够找到这个文件。通常，除非在输入的文件名中包含路径，否则程序将在可执行文件所属的文件夹中查找。</strong></p><p>​Windows文本文件的每行都以回车字符和换行符结尾；通常情况下，C++在读取文件时将这两个字符转换为换行符，并在写入文件时执行相反的转换。</p><p>​下面是程序相关解析：</p><p>​读取文件时，有几点需要检查。<strong>首先，程序读取文件时不应超过EOF。</strong>如果最后一次读 取数据时遇到EOF，方法eof( )将返回true。</p><p>​<strong>其次，程序可能遇到类型不匹配的情况。</strong>例如，上述程序期望文件中只包含数字。如果最后一次读取操作中发生了类型不匹配的情况，方法fail( )将返回true（如果遇到了EOF，该方法也将返回true）。</p><p>​<strong>最后，可能出现意外的问题，如文件受损或硬件故障。</strong>如果最后一次读取文件时发生了这样的问题，方法bad( )将返回true。</p><p>​<strong>不要分别检查这些情况，一种更简单的方法是使用good( )方法，该方法在没有发生任何错误时返回true：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (inFile.<span class="built_in">good</span>())</span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>然后，如果愿意，可以使用其他方法来确定循环终止的真正原因：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (inFile.<span class="built_in">eof</span>())</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;End of file reacher.\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (inFile.<span class="built_in">fail</span>())</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Input terminated by data mismatch.\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Input terminated for unknown reason.\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>​这些代码紧跟在循环的后面，用于判断循环为何终止。由于eof( )只能判断是否到达EOF，而fail( )可用于检查EOF和类型不匹配，因此上述代码首先判断是否到达EOF。这样，如果执行到了else if测试，便可排除EOF，因此，如果fail( )返回true，便可断定导致循环终止的原因是类型不匹配。</p><p>​<strong>方法good( )指出最后一次读取输入的操作是否成功，这一点至关重要。</strong>这意味着应该在执行读取输入的操作后，立刻应用这种测试。为此，一种标准方法是，在循环之前（首次执行循环测试前）放置一条输入语句，并在循环的末尾（下次执行循环测试之前）放置另一条输入语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inFile &gt;&gt; value;</span><br><span class="line"><span class="keyword">while</span> (inFile.<span class="built_in">good</span>())</span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">    inFile &gt;&gt; value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>表达式inFile &gt;&gt; value的结果为inFile，而在需要一个bool值的情况下，inFile的结果为 inFile.good( )，即true或false。</strong>因此，可以将两条输入语句用一条用作循环测试的输入语句代替。也就是说，可以将上述循环结构替换为如下循环结构从而精简代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (inFile &gt;&gt; value)</span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>这种设计仍然遵循了在测试之前进行读取的规则，因为要计算表达式inFile &gt;&gt; value的值，程序必须首先试图将一个数字读取到value中。</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;C-Primer-plus-学习笔记&quot;&gt;&lt;a href=&quot;#C-Primer-plus-学习笔记&quot; class=&quot;headerlink&quot; title=&quot;C++ Primer plus 学习笔记&quot;&gt;&lt;/a&gt;C++ Primer plus 学习笔记&lt;/h1&gt;&lt;h2 id=&quot;第1章-预备知识&quot;&gt;&lt;a href=&quot;#第1章-预备知识&quot; class=&quot;headerlink&quot; title=&quot;第1章 预备知识&quot;&gt;&lt;/a&gt;第1章 预备知识&lt;/h2&gt;&lt;h3 id=&quot;C-简史&quot;&gt;&lt;a href=&quot;#C-简史&quot; class=&quot;headerlink&quot; title=&quot;C++简史&quot;&gt;&lt;/a&gt;C++简史&lt;/h3&gt;&lt;p&gt;​	C++融合了3种不同的编程方式：&lt;strong&gt;C语言代表的过程性语言，C++在C语言基础上添加的类代表的面向对象语言，C++模板支持的泛型编程。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="c++语法" scheme="https://sixteen-nights.github.io/categories/c-%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="c++" scheme="https://sixteen-nights.github.io/tags/c/"/>
    
    <category term="书籍学习" scheme="https://sixteen-nights.github.io/tags/%E4%B9%A6%E7%B1%8D%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
